<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2019%2F02%2F14%2FLinux-CentOS%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[title: CentOS版本说明 tags: CentOS copyright: true comments: true toc: true date: 2018-12-19 15:29:55 categories: Linux password: CentOS-7.0-1406-x86_64-DVD.iso 标准安装版，一般下载这个就可以了 CentOS-7.0-1406-x86_64-NetInstall.iso 网络安装镜像 CentOS-7.0-1406-x86_64-Everything.iso 对完整版安装盘的软件进行补充，集成所有软件。 CentOS-7.0-1406-x86_64-GnomeLive.iso GNOME桌面版 CentOS-7.0-1406-x86_64-KdeLive.iso KDE桌面版 CentOS-7.0-1406-x86_64-livecd.iso 光盘上运行的系统，类拟于winpe CentOS-xxxx-LiveCD.ios 和CentOS-xxxx-bin-DVD.iso有什么区别？前者只有700M，后者有3.8G。其差别不仅仅在大小上，其更本质的差别是，CentOS-xxxx-LiveCD.ios只能加载到内存里运行，不能安装。CentOS-xxx-bin-DVD1.iso才可以安装到硬盘上。 CentOS-xxx-bin-DVD1.iso，CentOS-xxx-bin-DVD2.iso分别是干什么的？前者是3.8G，后者是500M。其差别是DVD1是CentOS的安装文件，DVD2是CentOS的一些软件（就简单实用CentOS来说是不需要的）。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F02%2F14%2FLinux-Shell%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[title: Shell编程入门 tags: Shell编程 copyright: true comments: true toc: true date: 2018-12-19 15:29:55 categories: Linux password: [toc] 认识Shell环境 Shell是工作在Linux内核与用户之间的==解释程序==，相当于操作系统的“外壳”，是向Linux内核传达用户指令的“翻译官”，通常指BASH（/bin/bash）,常见的还有zsh、tcsh，用于和操作系统内核交互，操作系统内核控制底层硬件 windows下的Shell为cmd.exe 查看当前的Shell的命令为：echo $SHELL 可以手动选择Shell环境，直接在Shell中输入shell如：tcsh，相当于新建了一个子环境（父–子进程） shell操作有交互式和非交互式两种 交互式 非交互式 人工干预、智能化程度低 需提前设计、智能化难度大 逐条解释执行、效率低 批量执行、效率高 方便在后台静悄悄地运行 shell脚本 shell脚本指提前写好的可执行代码，用来完成特定任务的文件，特点为：顺序、批处理，解释型程序 shell脚本编写步骤： 1. 理清任务 自然语言：步骤拆分、顺序化整理 2. 编写可执行语句 脚本语言：各步骤如何实现 3. 完善脚本 界面友好／结构规范／代码优化 shell脚本一般以.sh结尾，==第一行 #!/bin/bash== 用来申明Shell环境 shell脚本的免交互及输出处理 免交互：通过选项 ==–stdin== 可以从标准输入读取字串；也可以从键盘或由另一个命令给出 123// 修改root密码passwd --stdin root //从键盘读入echo 1234567 | passwd --stdin root //由echo命令给出 输出处理： 忽略无关输出:黑洞设备/dev/null 12相当于只能写入、不能读出的单向文件；存放到其中的数据都会丢失，用法：可执行语句 &amp;&gt; /dev/null，如：echo 1234567 | passwd --stdin root &amp;&gt; /dev/null 记录错误输出：根据需要，将出错信息保存到指定文件 12是针对后台脚本的有效排错手段，适用于不便交互但又需要查看报错的情况，用法：可执行语句 2&gt;/路径／文件，如：useradd root 2&gt;/tmp/err.log 命令的组合运用 顺序分割–==使用分号==，格式：命令1；命令2；命令3…,依次执行，只有先后，没有逻辑关系 逻辑“与”分割–==使用&amp;&amp;==，格式：命令1 &amp;&amp; 命令2 &amp;&amp; 命令3…,逻辑关系为“而且”（and），期望所有命令都能执行成功，一旦出现失败，后续命令不再执行 逻辑“或”分割–==使用||==，格式：命令1 || 命令2 || 命令3…,逻辑关系为“或者”（or），任何一条成功都符合期望，只在前面的命令失败时，后续命令才执行 管道–==使用|==，格式：命令1|命令2，后续命令要能正确处理传来的文本，否则无意义，如： 1find /etc -type f | wc -l //计算／etc下文件数量，将结果交给wc统计行数 shell脚本的运行方式 作为指定shell解释程序的参数 12-sh 代码文件路径 === bash 代码文件路径-. 代码文件路径 === source 代码文件路径 作为可独立运行的脚本程序 12为shell代码文件添加x权限，指定脚本路径即可运行.如：chmod +x ／root／first.sh；/root/first.sh 标准输入输出和重定向 Unix/Linux基本思想：普通文件、目录、鼠标、键盘…都是以文件形式存在；要访问硬件设备，必须找对应的设备文件 I/O交互设备 类型 设备文件 文件描述号 默认设备 备注 标准输入 /dev/stdin 0 键盘 从此设备接收用户输入的数据 标准输出 /dev/stdout 1 显示器 通过此设备向用户报告正常的命令输出结果 标准错误输出 /dev/stderr 2 显示器 通过此设备报告执行中的错误信息 重定向：重新指定命令执行是I/O设备的方向 根据I／O方向和类型区分 类型 操作符 用途 举例 重定向输入 &lt; 将文本输入来源由键盘改为指定的文件 mial -s ‘A Test Mail’ root@localhost &lt; /root/mail.txt 重定向输出 &gt; 将命令行的正常输出保存到文件，而非显示器 echo ‘nameserver 8.8.8.8’ &gt; /etc/resolv.conf 重定向输出 &gt;&gt; 与“&gt;”类似，但操作是追加而不是覆盖 重定向错误 2&gt; 将命令行的错误输出保存到文件，而非显示器 重定向错误 2&gt;&gt; 与“2&gt;”类似，但操作是追加而不是覆盖 混合重定向 &amp;&gt; 相当于“&gt;”和“2&gt;” 脚本逻辑 变量值及范围控制 引号在赋值中的应用 双引号 123- 在双引号内允许$扩展，可调用其他变量的值- 出现特殊字符时，可采用\符号转义- 当变量值不包括空格、制表符时，双引号通常被省略，如：A=CentOS7 单引号 12- 所有字符均视为该字符本身（无特殊含义）- 不允许\转义 read读入变量值 1234* 基本格式 - read 变量名.. .. - read -p &quot;提示信息&quot; 变量名 .. .. //read -p &quot;svr5 login&quot; YOUR_NAME - 启用read命令的 -s 选项，可关闭输入回显，适合敏感信息，提高安全性，如密码 变量的作用范围 局部变量：只在定义此变量的shell环境有效；自定义变量默认都是局部变量 全局变量：在当前shell及所有子shell环境下有效；子shell中若赋值同名变量，与父shell中变量无关 发布全局变量 123export 局部变量名[=变量值] .. .. - 直接定义／赋值指定的变量，作为全局变量发布 - 对已有的局部变量，只需发布不需赋值 数值运算及处理 bash内置机制仅支持整数运算 基本运算类别 加减乘除求模 ±*／% 1234561. expr工具：==expr 数值1 运算符 数值2== 乘法操作需转义2. 使用$[]表达式： ==$[数值1 运算符 数值2]== * 乘法操作无需转义，运算符两侧可以无空格，引用变量可省略$符号，如：echo $[x+100-Y*2/7]* 支持混合运算，乘除优先* 支持乘方运算,如：echo $[10**3] 自增表达式 121. 加减乘除求模自增，如：i+=2 或 i=i+2 或 $[i+=2]2. 如果步长为1，则支持如： --i，++i/i--，i++ let命令操作变量 1操作变量值运算，并保存新结果，适用于不需要输出的情况，如：let x++ 使用随机整数 环境变量RANDOM:随机生成0～32767之间的一个整数 扩大随机数范围：多个随机数相乘 缩小随机数范围：取余数，如：$[RANDOM%1000]取0～999的整数 整数序列 使用seq命令 1234567使用格式：默认分隔符为\n- seq 末数 ;默认从1开始，步长为1- seq 首数 末数- seq 首数 步长 末数参数选项： -s：定义分隔符，如：seq -s&apos; &apos; 3,结果“1 2 3” -w：等宽显示,不足前面补0 bc计算器 bc运算器支持高精度的数值运算，输入bc进入交互式预算界面，quit退出，设置scale=n可约束小数位，也支持小数值的比较，大多数Linux系统已内置 使用举例： echo “scale=4;123.4*2.5” | bc echo “A&gt;A&gt;A&gt;B” | bc Shell变量 变量：以固定名称存放的可能会变化的值 定义／赋值变量 12345变量名=变量值1. 如果变量名已存在，则相当于赋值2. 等号两边不能有空格3. 变量区分大小写4. 变量名不能以数字开头，不要使用关键字和特殊字符 查看／引用变量：$变量名 或 ${变量名} 取消变量：退出shell变量自动失效 或 ==unset 变量名== 方式手动取消 变量的分类 存储类型：shell不作为高级编程语言，对存储类型的要求比较松散 使用类型 类型 说明 备注 环境变量 变量名通常大写，由系统维护，用来设置工作环境，其中只有个别变量用户可以直接修改 配置文件：/etc/profile,~/.bash_profile 位置变量 由bash内置，用来存储在执行脚本时提供的命令行参数 n,从1开始,当n&gt;10，格式为==n,从1开始,当n&gt;10，格式为 ==n,从1开始,当n&gt;10，格式为=={n}== 预定义变量 由bash内置，一类有特殊用途的变量，可以直接调用，但不能直接赋值或修改 参见下表与定义变量定义 自定义变量 用户自主设置、修改及使用 env-列出所有环境变量； set-列出所有变量 常见环境变量：PWD,PATH,USER,LOGNAME,UID,SHELL,HOME,PS1,PS2… 变量名 含义 备注 $0 当前所在进程或脚本名 $$ 当前运行进程PID $? 命令执行后的状态值，0-正常 1或其他-异常 $# 已加载位置变量个数 如传入参数个数判断: if[ $# -ne 2 ] $* 所有位置变量的值 条件测试 返回状态值：$? 专用测试工具test 123格式：* test 选项 参数...* [ 选项 参数... ] 文件状态检测：test的参数则为文件或目录 测试选项 含义 举例 -e 检测对象是否存在Exist [ -e /etc/test ];echo $? -d 检测对象是否为目录Directory -f 检测对象是否为文件File -r 检测对象是否有可读权限Read -w 检测对象是否有可写权限Write -x 检测对象是否有可执行权限eXcute 整数值比较 测试选项 含义 举例 -eq 等于Equal [ $(who|wc -l) -eq 10 ]//判断登陆用户数等于10 -ne 不等于Not Equal -ge 大于或等于 Greater or Equal -le 小于或等于 Lesser or Equal -gt 大于 Greater Than -lt 小于 Lesser Than 组合多个条件 123格式：* test 测试条件1 -a或-o 测试条件2...* [[ 测试条件1 &amp;&amp;或|| 测试条件2...]] 字符串比较 123格式：* [ 字符串1 选项 字符串2 ]* [ 选项 字符串 ] 测试选项 含义 举例/说明 = 两字符串相同 [ $USER = ‘root’ ] &amp;&amp; echo $USER != 两字符串不同 -z 字符串值为空 Zero -n 字符串值不为空 Not zero 将条件取反 1234格式：[ ! 测试条件 ]举例：[ ! 100 -gt 200] &amp;&amp; echo YES 字符串处理 截取字符串 使用expr命令，==expr substr $var1 起始位置 截取长度== 使用cut命令 12* 命令输出|cut -c 起始位置-结束位置，echo $var1|cut -c 5-6* 命令输出|cut -d &apos;分隔符&apos; -f 字段编号....,echo &quot;CentOS6.5&quot; |cut -d &apos;t&apos; -f2 //OS6.5，相当于java中的split[2] 使用${} 123格式：* $&#123;var1:起始位置:截取长度&#125;* $&#123;var1::截取长度&#125; //默认从头开始 字符串替换 使用${} 123格式：* $&#123;var1/old/new&#125; //只替换一个* $&#123;var1//old/new&#125; //替换全部 tr单字替换工具 123格式：* 命令输出|tr &apos;abc&apos; &apos;ABC&apos; //abc替换为大写ABC* 命令输出|tr -d &apos;abc&apos; //删除所有的abc 路径分割 dirname “路径字符串”:取目录位置 basename “路径字符串”:取基本名称 使用随机字符串 随机数变量：RANDOM 特殊设备文件：/dev/urandom UUID生成命令：uuidgen 随机信息的转换：md5sum 依据输入文本计算出256位(32字符)的MD5编码值 echo $RANDOM |md5sum head -1 /dev/urandom|md5sum 命令替换 反撇号` 适用场景：在命令行潜入另一个命令的输出结果；将命令的输出保存到指定变量 优先执行反撇号内的命令，并将执行结果作为输入 举例：rpm -qf which tr $(可执行命令)，优点为==可嵌套使用==，举例：rpm -qf $(which tr) 流程控制 if语句 12345678910111213141516171819//单分支if 条件测试 then 命令序列fi//双分支if 条件测试 then 命令序列1 else 命令序列2fi//多分支（嵌套）if 条件测试1 then 命令序列1elif 条件测试2 ;then 命令序列2else 命令序列nfi 说明：如果then要跟着条件测试写在一行，则需在then前加封号，如： 123if 条件测试 ;then 命令序列fi for循环 1234for 变量名 in 值列表do 命令序列done while循环 1234while 条件测试do 命令序列done case分支 123456789case 变量值 in模式1) 命令序列1;;模式2) 命令序列2;; .. ..*) 默认命令序列esac 中断及退出控制 类型 含义 break 跳出当前所在循环体，执行循环体后的语句块 continue 跳过循环体内余下的语句，重新判断条件以便执行下一次循环 exit 退出脚本，可以指定返回的状态值，默认返回0 编写服务脚本 shell函数 type 名称 //查看名称对应类型 12345678910111213基本格式:function 函数名()&#123; 命令序列 .. ..&#125;或🔥函数名()&#123; 命令序列 .. ..&#125;调用： 函数名传参： 函数名 参数1 参数2 .. .. //传递的值作为函数的位置参数 系统服务管理 查看服务列表、自启状态 chkconfig --list [服务名] chkconfig 服务名 on/off 启动／停止／重启服务 service 服务名 start/stop/restart /etc/init.d/服务名 start/stop/restart ntsysv:可视化设置自启动状态 shell脚本直接交给service控制，则将脚本或者脚本的快捷方式放到/etc/init.d／下即可 shell脚本交给chkconfig工具管理,需设置适用级别、启动／停止顺序、服务说明 添加设置 1234#!/bin/bash## chkconfig:2345 10 95# description:服务相关说明 添加服务：chkconfig --add 服务名 文件的排序集统计 ls列表排序 -S:按文档大小降序排列 -t:按文档的修改时间降序排列 -r:反序排列 uniq去重工具 12用法1：uniq 文件用法2: 命令|uniq 缺点：==未排序的文本会出现重复现象==，需配合其他方式先排序，再去重 方法：sort 文件名|uniq -c sort工具 12345678用法1:sort 文件用法2:命令|sort常用选项：* -u: 去除重复行* -n：按数字升序排列* -r：反向排序* -k：优先对第几列内容排序，即优先对哪个字段排序，只是字段是通过显示顺序编号的 文本处理的的特殊应用 tac、rev反序输出 tac：以行为单位反序，与cat命令效果相反 rev: 以字符为单位反序，与echo命令效果相反 tee整合重定向 举例：uname -r|tee un.txt unix2dos与dos2unix转换 windows和linux系统文本格式转换 1234安装：yum -y install unix2dos dos2unix基本用法：* unix2dos Linux文件* dos2unix Windows文件 xargs多参数处理 背景：ls、mv、rm、cp等命令给出的参数长度不能超过2.5M，基于*匹配、find等方式处理大量文件时容易出错 多参数的分散处理 利用find… … -exec… … 查找处理 //仅适用于处理文件或目录参数，如：find / -exec ls -lh {} ; xargs工具:根据给定的参数组（以行为单位）分次执行目标命令行 12345用法1：提供参数的命令 | xargs 目标命令，如：find /|args ls -lh用法2: xargs --arg-file=提供参数的文件 目标命令选项：* -I：定义标记，如：ls txt.log* | xargs -I&#123;&#125; cp &#123;&#125; &#123;&#125;.new* -d: 制定分割符，默认按行分割，如：head -1 /etc/passwd |xargs -d: -I&#123;&#125; echo &#123;&#125; expect预期交互控制 基于TCL编写的自动化交互式程序，可以用在Shell脚本中，为FTP、SSH等交互过程自动输送预先准备的文本或指令，而无需人工干预，出发的依据是预期会出现的特征提示文本 安装：yum -y install expect 手动交互 自动交互 12345678910111213cat mike-ftp.sh--------------------spawn ftp 192.168.4.5expect &quot;):&quot;send &quot;mike\r&quot;expect &quot;Password:&quot;send &quot;123456\r&quot;expect &quot;ftp&gt;&quot;send &quot;put install.log\r&quot;expect &quot;ftp&gt;&quot;send &quot;quit\r&quot;---------------------epxect mike-ftp.sh 调整执行环境：添加Sha-Bang环境声明 1234567891011121314cat mike-ftp.sh-----------------------#!/usr/bin/expectspawn ftp 192.168.4.5expect &quot;):&quot;send &quot;mike\r&quot;expect &quot;Password:&quot;send &quot;123456\r&quot;expect &quot;ftp&gt;&quot;send &quot;put install.log\r&quot;expect &quot;ftp&gt;&quot;send &quot;quit\r&quot;------------------------sh mike-ftp.sh SSH登陆免交互举例 12345678#!/usr/bin/expectset host 192.168.4.5set user mikeset password &quot;1234567&quot;spawn ssh $user@$hostexpect &quot;password:&quot;&#123;send &quot;$password\r&quot;&#125;expect &quot;\[$user\@&quot;&#123;send &quot;pwd&gt;/tmp/$user.txt;exit\r&quot;&#125;expect eof 应用技巧 正则表达式 使用“一串符号”来描述有共同属性的数据 egrep测试工具 用法1:egrep [选项] ‘正则表达式’ 文件 用法2:前置命令|egrep [选项] ‘正则表达式’ 选项 12345-i：忽略大小写-v: 取反-c：统计匹配行数-q：静默、无任何输出-n：显示出所匹配结果所在的行号 基本元字符 类型 含义 示例 说明 ^ 匹配行首 ^abc 或 ^# 以abc开头的行 或 以#开头的行（比如注释行） $ 匹配行尾 abc$ 或 ^$ 以abc结尾的行 或 空行 . 单个字符 . 除换行符\n以外的任意单个字符 + 最少匹配一次 a+ 或 (abc)+ 一个或多个连续的a 或 一个或多个连续的abc ? 最多匹配一次 a? 或 (abc)? 0个或1个a 或 0或1个abc * 匹配任意次数 a* 或 (abc)* 或 .* 0个或多个连续的a 或 0个或多个连续的abc 或 任意长度的任意字符串 {n} 匹配n次 (ab){3} 匹配ababab {n,m} 匹配n～m次 (ab){1,3} 匹配ab、abab、ababab {n,} 匹配至少n次 (ab){2,} 匹配2个及以上连续的ab [] 匹配范围内的单个字符 [a-z] 匹配任意小写字母 []内加^ 可取反 [^a-z] 匹配任意非小写字母 () 组合为整体 (ab) 连续的ab 或者 root|bin 匹配root、bin \b 单词边界 \broot\b 匹配root，不匹配keroot、rooty、brooty等字符串 &lt; 单词的开头 &lt;th 匹配以th开头的单词 &gt; 单词的结尾 th&gt; 匹配以th结尾的单词 awk文本过滤 awk:模式扫描及处理语言，创始人Aho、Weinberger、Kernighan，基于模式匹配检查输入的文本，逐行处理并print结果，目前最常用的实际是GNU版本的gawk 用法1:前置命令|awk [选项] ‘[条件]{编辑指令}’ 用法2:awk [选项] ‘[条件]{编辑指令}’ 文件，如：awk -F “:” ‘{print $1,$2} /etc/passwd’ 条件的表现形式 正则表达式，/正则表达式/ 🔥 ~匹配、!~不匹配,如：awk -F: ‘/^ro/{print}’ /etc/passwd 数值／字符串比较 逻辑比较 运算符 选项 12-F:指定分隔符，可省略，默认空格或Tab位，如：awk -F: &apos;$1==ENVIRON[&quot;USER&quot;]&#123;print $3&#125;&apos; /etc/passwd //输出当前用户的UID信息-f:调用awk脚本进行处理 awk内置变量 变量 用途 FS 保存或设置字段分隔符，如 FS=“：” $n 指定分隔符的第n个字段，如$1、$3分别表示第1、第3列 $0 当前读入的整行文本内容 NF 记录当前处理的字段个数（列数） NR 记录当前已读入行的数量（行数） FNR 保存当前处理行在元文本内的序号（行号） FILENAME 当前处理的文件名 ENVIRON 调用Shell环境变量，格式：ENVIRON[“变量名”] awk处理的时机：可单独使用，也可以同时一起使用，具体如下： 行前处理,BEGIN{}:读入第一行文本之前执行，一般用来初始化操作 逐行处理,{}：逐行读入文本执行相应的处理，是最常见的编辑指令块 行后处理，END{}：处理完最后一行文本之后执行，一般用来输出处理结果 1awk &apos;BEGIN&#123;print NR&#125;END&#123;print NR&#125;&apos; m.txt awk的流程控制 if分支，如：if(条件){编辑指令1}else if(条件){编辑指令12}…else{编辑指令n} 1awk -F: &apos;BEGIN&#123;i=0;j=0&#125;&#123;if($3&lt;500)&#123;i++&#125;else&#123;j++&#125;&#125;END&#123;print i,j&#125;&apos; /etc/passwd while循环，如：while(条件){编辑指令} do while循环，如：do {编辑指令}while(条件) for循环,如：for(初值；条件；步长){编辑指令} 关键字 含义 break 结束当前的循环体 continue 中止本次循环，转入下一次循环 next 跳过当前行，读入下一行文本开始处理 exit 结束文本读入，转入END{}执行，没有则直接退出 sed文本流处理 sed:Stream EDitor，流式编辑器，基于模式匹配过滤及修改文本，逐行处理并将结果输出到屏幕，可实现文本过滤／删除／替换／复制／剪切，以及导入／导出等各种操作 用法1:前置命令|sed [选项] ‘编辑指令’，如：se -n /etc/inittab |sed -n ‘4,7p’ 用法2:sed [选项] ‘编辑指令’ 文件 1编辑指令由“[定址符]处理动作”组成，[定址符]的格式为“[地址1，[地址2]]” 选项： 123456-n:屏蔽默认输出-i:直接修改文件内容-f:使用sed脚本-e:可指定多个处理动作-r:启用扩展的正则表达式，若与其他选项一起使用，应作为首个选项&#123;&#125;:可组合多个命令，以分号分隔 处理动作：替换操作的分隔符“／”可用其他字符，如#、&amp;等以便于修改文件路径 操作符 用途 指令示例 p 打印行 2,4p 输出2，3，4行 🔥 2p；4p输出第2行、4行 d 删除行 2,4d 删除第2，3，4行 s 字符串替换 s/old/new/ 将每行第1个old替换为new s/old/new/3 将每行第3个old替换为new s/old/new/g 将所有的old替换为new 4,+10p 加10行 输出第4行及其后10行内容 n 表示下一行 p:n输出奇数行 n:p输出偶数行 $= 输出文件的行数 sed -n ‘$=’ a.txxt i 行前插入文本 2iYY 在第2行前添加文本行YY 4，7iYY 在第4-7行每一行钱添加文本行YY a 行后插入文本 2aYY 在第2行后插入YY c 替换当前行 2cYY 将第2行内容修改为YY r 读取文件，结合-i选项才会存入，否则只输出 3r b.txt 在第3行下发插入文本b.txt w 保存到文件，以覆盖方式 3w b.txt 将第3行保存到b.txt sed复制剪切 模式空间:存放当前处理的行，将处理结果输出；若当前行不符合处理条件则原样输出；处理完当前行再读入下一行来处理 保存空间:作用类似剪贴板，默认存放一个空行\n 选项： 123456-H：模式空间 追加 到 保持空间 ，即复制-h：模式空间 覆盖 到 保持空间 ，即复制-G：保持空间 追加 到 模式空间 ，即粘贴-g：保持空间 覆盖 到 模式空间 ，即粘贴sed &apos;1,3H;$G&apos; reg.txt //把第1～3行复制到文件末尾 实战脚本 基本知识 查看用户信息：id gsuis awk&amp;sed应用实战]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F02%2F14%2FLinux-RHEL-7-%E4%B8%AD-systemctl-%E7%9A%84%E7%94%A8%E6%B3%95%EF%BC%88%E6%9B%BF%E4%BB%A3service-%E5%92%8C-chkconfig%EF%BC%89%2F</url>
    <content type="text"><![CDATA[title: RHEL 7 中 systemctl 的用法（替代service 和 chkconfig） tags: CentOS copyright: true comments: true toc: true date: 2018-12-19 15:29:55 categories: Linux password: systemctl是RHEL 7 的服务管理工具中主要的工具，它融合之前service和chkconfig的功能于一体。可以使用它永久性或只在当前会话中启用/禁用服务。 Systemctl是一个systemd工具，主要负责控制systemd系统和服务管理器。 Systemd是一个系统管理守护进程、工具和库的集合，用于取代System V初始进程。Systemd的功能是用于集中管理和配置类UNIX系统 启用服务就是在当前“runlevel”的配置文件目录/etc/systemd/system/multi-user.target.wants/里，建立/usr/lib/systemd/system里面对应服务配置文件的软链接；禁用服务就是删除此软链接，添加服务就是添加软连接 Systemctl接受服务（.service），挂载点（.mount），套接口（.socket）和设备（.device）作为单元。 启动一个服务：systemctl start postfix.service 关闭一个服务：systemctl stop postfix.service 重启一个服务：systemctl restart postfix.service 显示一个服务的状态：systemctl status postfix.service 在开机时启用一个服务：systemctl enable postfix.service 在开机时禁用一个服务：systemctl disable postfix.service 查看服务是否开机启动：systemctl is-enabled postfix.service 查看已启动的服务列表：systemctl list-unit-files|grep enabled 查看启动失败的服务列表：systemctl --failed 使用命令 systemctl is-enabled postfix.service 得到的值可以是enable、disable或static，这里的 static 它是指对应的 Unit 文件中没有定义[Install]区域，因此无法配置为开机启动服务。 更多：https://linux.cn/article-5926-1.html]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F02%2F14%2FLinux-%E8%AE%BE%E7%BD%AE%E7%BD%91%E7%BB%9C%E8%87%AA%E5%8A%A8%E5%90%AF%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[title: CentOS设置网络自动启动 tags: CentOS copyright: true comments: true toc: true date: 2018-12-19 15:29:55 categories: Linux password: 设置网络自启动 修改/etc/sysconfig/network-scripts/ifcfg-ethX文件，修改其中ONBOOT===no==的值为yes即可 如果想要自己设置静态ip，需要在上边文件的最后添加以下内容： 1234IPADDR=192.168.7.106 #静态IP GATEWAY=192.168.7.1 #默认网关 NETMASK=255.255.255.0 #子网掩码 DNS1=192.168.7.1 #DNS 配置 重启服务即可]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F02%2F14%2FLinux-%E7%A6%81%E7%94%A8SELinux%E6%97%B6%E9%85%8D%E7%BD%AE%E9%94%99%E8%AF%AF%E5%AF%BC%E8%87%B4%E7%B3%BB%E7%BB%9F%E4%B8%8D%E8%83%BD%E5%A4%9F%E5%90%AF%E5%8A%A8%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[title: 禁用SELinux时配置错误导致系统不能够启动的解决方法 tags: CentOS copyright: true comments: true toc: true date: 2018-12-19 15:29:55 categories: Linux password: CentOS在安装某些软件的时候，需要关闭SELinux，在修改配置文件/etc/selinux/config过程中，设置方法为： 12# SELINUX=enforcingSELINUX=disabled 如果设置之后，没有设置回来，则启动的时候就会无法启动，解决办法为： 系统启动的时候，按下‘e’键进入grub编辑界面， 编辑grub菜单，选择“kernel /vmlinuz-2.6.23.1-42.fc8 ro root=/dev/vogroup00/logvol00 rhgb quiet” 一栏 按‘e’键进入编辑 在末尾增加enforcing=0，即： kernel /vmlinuz-2.6.23.1-42.fc8 ro root=/dev/vogroup00/logvol00 rhgb quiet enforcing=0 按‘b’键继续引导，OK顺利前进。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F02%2F14%2F%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL%E4%B8%8EMariaDB%E5%AF%B9%E6%AF%94%2F</url>
    <content type="text"><![CDATA[title: MySQL与MariaDB对比 tags: MySQL copyright: true comments: true toc: true date: 2018-12-10 20:38:05 categories: 数据库 password: [toc] MySQL与MariaDB对比 MySQL： MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，目前属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件。 MariaDB 甲骨文收购 MySQL 后，由于甲骨文对 MySQL 的开发和维护更多倾向于闭门的立场，很多 MySQL 的开发者和用户放弃了它。在社区驱动下，促使更多人移到 MySQL 的另一个叫 MariaDB 的分支，在原有 MySQL 开发人员的带领下，MariaDB 的开发遵循开源的理念，并确保它的二进制格式与 MySQL 兼容。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F02%2F14%2F%E6%95%B0%E6%8D%AE%E5%BA%93-2018-12-10-MongoDB%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[title: MongoDB tags: MongoDB copyright: true comments: true toc: true date: 2018-12-10 20:38:05 categories: 数据库 password: ##集群环境:三台服务器 server1:10.62.0.128主;server2:10.62.0.135从;server3:10.62.0.159从 每一台分为6个片：shard1~shard6端口为47017,47018,47019,47020,47021,47022；每一片建三个副本集；配置服务器端口号：37017；路由服务器端口号：30000； (1).解压安装文件 [gsunis@gsunis Desktop]$ tar zxvf mongodb-linux-x86_64-3.0.6.tgz (2).将mongoDB文件移动到/home/gsunis/mongodb目录下 [root@gsunis Desktop]# mv mongodb-linux-x86_64-3.0.6 /home/gsunis/mongodb (3).数据存储目录 [root@gsunis bin]# mkdir -p /home/gsunis/data/db (4).启动mongod服务 [root@gsunis Desktop]# cd /home/gsunis/mongodb/bin [root@gsunis bin]# ./mongod --port 27017 --dbpath=/home/gsunis/data/db (5).启动mongo客户端 打开新的Terminal [gsunis@gsunis Desktop]$ su 查看mongod服务启动情况 [root@gsunis Desktop]# netstat -ntpl | grep 27017 [root@gsunis Desktop]# cd /home/gsunis/mongodb/bin/ [root@gsunis bin]# ./mongo ###正常关闭mongoDB服务 ./mongo use admin db.shutdownServer() 或者ps -ef|grep mongodb kill -2 pid ##以上是简单的安装mongodb，下面是开始建立集群，分片和建立副本集 ###创建目录 mkdir -p /data/conf mkdir -p /data/data1 mkdir -p /data/data2 mkdir -p /data/data3 mkdir -p /data/data4 mkdir -p /data/data5 mkdir -p /data/data6 (6).编辑mongo配置文件 sudo vi conf.cnf //conf.cnf port=37017 dbpath=/home/gsunis/data/conf logappend = true fork=true logpath=/home/gsunis/data/conf/mongodb.log nojournal=false configsvr=true profile=1 sudo vi db1.cnf //db1.cnf replSet=shard1 port=47017 dbpath=/home/gsunis/data/data1 logappend = true fork=true logpath=/home/gsunis/data/data1/mongodb.log nojournal=false shardsvr=true profile=1 sudo vi db2.cnf //db2.cnf replSet=shard2 port=47018 dbpath=/home/gsunis/data/data2 logappend = true fork=true logpath=/home/gsunis/data/data2/mongodb.log nojournal=false shardsvr=true profile=1 sudo vi db3.cnf //db3.cnf replSet=shard3 port=47019 dbpath=/home/gsunis/data/data3 logappend = true fork=true logpath=/home/gsunis/data/data3/mongodb.log nojournal=false shardsvr=true profile=1 sudo vi db4.cnf //db4.cnf replSet=shard4 port=47020 dbpath=/home/gsunis/data/data4 logappend = true fork=true logpath=/home/gsunis/data/data4/mongodb.log nojournal=false shardsvr=true profile=1 sudo vi db5.cnf //db5.cnf replSet=shard5 port=47021 dbpath=/home/gsunis/data/data5 logappend = true fork=true logpath=/home/gsunis/data/data5/mongodb.log nojournal=false shardsvr=true profile=1 sudo vi db6.cnf //db6.cnf replSet=shard6 port=47022 dbpath=/home/gsunis/data/data6 logappend = true fork=true logpath=/home/gsunis/data/data6/mongodb.log nojournal=false shardsvr=true profile=1 (7).编写启动mongo服务的脚本 sudo vi mg.sh #!/bin/bash instance=$1 action=$2 case &quot;$action&quot; in 'start') /home/gsunis/mongodb/bin/mongod -f /home/gsunis/data/&quot;$instance&quot;.cnf ;; 'stop') /home/gsunis/mongodb/bin/mongod -f /home/gsunis/data/&quot;$instance&quot;.cnf --shutdown;; 'restart') /home/gsunis/mongodb/bin/mongod -f /home/gsunis/data/&quot;$instance&quot;.cnf --shutdown /home/gsunis/mongodb/bin/mongod -f /home/gsunis/data/&quot;$instance&quot;.cnf;; esac (8).启动mongo服务脚本 sudo vi start.sh #!/bin/bash rm /data/conf/*.lock rm /data/data1/*.lock rm /data/data2/*.lock rm /data/data3/*.lock rm /data/data4/*.lock rm /data/data5/*.lock rm /data/data6/*.lock /home/gsunis/data/mg.sh db1 start /home/gsunis/data/mg.sh db2 start /home/gsunis/data/mg.sh db3 start /home/gsunis/data/mg.sh db4 start /home/gsunis/data/mg.sh db5 start /home/gsunis/data/mg.sh db6 start sudo vi stop.sh #!/bin/bash /home/gsunis/data/mg.sh conf stop /home/gsunis/data/mg.sh db1 stop /home/gsunis/data/mg.sh db2 stop /home/gsunis/data/mg.sh db3 stop /home/gsunis/data/mg.sh db4 stop /home/gsunis/data/mg.sh db5 stop /home/gsunis/data/mg.sh db6 stop ###准备工作做好，先启动配置服务器（先启动主，依次启动两从机） /home/gsunis/data/mg.sh conf start ###再启动路由服务器（先启动主，依次启动两从机） /home/gsunis/mongodb/bin/mongos --configdb 10.62.0.128:37017,10.62.0.135:37017,10.62.0.159:37017 --port 30000 --chunkSize 1 --logpath /home/gsunis/data/mongos1.log --logappend --fork ###最后启动mongod（先启动主，依次启动两从机） /home/gsunis/mongodb/data/start.sh (9).shard服务器副本集的建立（只需要在主机上做即可，两从机会自动复制） ./mongo --port 47017 config = {_id: 'shard1', members: [ {_id: 0, host: '10.62.0.128:47017'}, {_id: 1, host: '10.62.0.135:47017'}, {_id: 2, host: '10.62.0.159:47017'}] } rs.initiate(config) Ctrl + C 退出 rs.add({&quot;_id&quot;:2,“host”:“10.62.0.135:47017”}) #在线增加复制集 ./mongo --port 47018 config = {_id: 'shard2', members: [ {_id: 0, host: '10.62.0.128:47018'}, {_id: 1, host: '10.62.0.135:47018'}, {_id: 2, host: '10.62.0.159:47018'}] } rs.initiate(config) ./mongo --port 47019 config = {_id: 'shard3', members: [ {_id: 0, host: '10.62.0.128:47019'}, {_id: 1, host: '10.62.0.135:47019'}, {_id: 2, host: '10.62.0.159:47019'}] } rs.initiate(config) ./mongo --port 47020 config = {_id: 'shard4', members: [ {_id: 0, host: '10.62.0.128:47020'}, {_id: 1, host: '10.62.0.135:47020'}, {_id: 2, host: '10.62.0.159:47020'}] } rs.initiate(config) ./mongo --port 47021 config = {_id: 'shard5', members: [ {_id: 0, host: '10.62.0.128:47021'}, {_id: 1, host: '10.62.0.135:47021'}, {_id: 2, host: '10.62.0.159:47021'}] } rs.initiate(config) ./mongo --port 47022 config = {_id: 'shard6', members: [ {_id: 0, host: '10.62.0.128:47022'}, {_id: 1, host: '10.62.0.135:47022'}, {_id: 2, host: '10.62.0.159:47022'}] } rs.initiate(config) 配置sharding:登录到mongos，添加shard节点 ./mongo --port 30000 use admin db.runCommand({addshard:&quot;shard1/10.62.0.128:47017,10.62.0.159:47017,10.62.0.135:47017&quot;}); db.runCommand({addshard:&quot;shard2/10.62.0.128:47018,10.62.0.159:47018,10.62.0.135:47018&quot;}); db.runCommand({addshard:&quot;shard3/10.62.0.128:47019,10.62.0.159:47019,10.62.0.135:47019&quot;}); db.runCommand({addshard:&quot;shard4/10.62.0.128:47020,10.62.0.159:47020,10.62.0.135:47020&quot;}); db.runCommand({addshard:&quot;shard5/10.62.0.128:47021,10.62.0.159:47021,10.62.0.135:47021&quot;}); db.runCommand({addshard:&quot;shard6/10.62.0.128:47022,10.62.0.159:47022,10.62.0.135:47022&quot;}); use config db.shards.find() 启动路由服务出错 错误： 解决方法： (1).关闭所有mongo相关服务 (2).先启配置服务 Config Server (3).启动路由服务 mongos (4).最后启动所有mongod服务 mongod ###远程copy scp /home/gsunis/Tools/mongodb-linux-x86_64-3.0.6.tgz gsunis@10.62.0.135:/home/gsunis/]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F02%2F14%2F%E6%95%B0%E6%8D%AE%E5%BA%93-2018-12-10-MongoDB%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[title: MongoDB tags: MongoDB copyright: true comments: true toc: true date: 2018-12-10 20:38:05 categories: 数据库 password: (1).解压安装文件 [gsunis@gsunis Desktop]$ tar zxvf mongodb-linux-x86_64-3.0.6.tgz (2).将mongoDB文件移动到/usr/local/mongodb目录下 [root@gsunis Desktop]# mv mongodb-linux-x86_64-3.0.6 /usr/local/mongodb export PATH=/usr/local/mongodb/bin:$PATH (3).数据存储目录 [root@gsunis bin]# mkdir -p /home/gsunis/data/db mkdir -p /data/conf mkdir -p /data/data1 mkdir -p /data/data2 mkdir -p /data/data3 mkdir -p /data/data4 mkdir -p /data/data5 mkdir -p /data/data6 (4).启动mongod服务 [root@gsunis Desktop]# cd /usr/local/mongodb/bin [root@gsunis bin]# ./mongod --port 27017 --dbpath=/home/gsunis/data/db (5).启动mongo客户端 打开新的Terminal [gsunis@gsunis Desktop]$ su 查看mongod服务启动情况 [root@gsunis Desktop]# netstat -ntpl | grep 27017 [root@gsunis Desktop]# cd /usr/local/mongodb/bin/ [root@gsunis bin]# ./mongo (6).编辑mongo配置文件 sudo vi conf.cnf //conf.cnf rest=true port=37017 dbpath=/home/gsunis/data/conf logappend = true fork=true logpath=/home/gsunis/data/conf/mongodb.log nojournal=false configsvr=true profile=1 sudo vi db1.cnf //db1.cnf replSet=shard1 rest=true port=47017 dbpath=/home/gsunis/data/data1 logappend = true fork=true logpath=/home/gsunis/data/data1/mongodb.log nojournal=false shardsvr=true profile=1 sudo vi db2.cnf //db2.cnf replSet=shard2 rest=true port=47018 dbpath=/home/gsunis/data/data2 logappend = true fork=true logpath=/home/gsunis/data/data2/mongodb.log nojournal=false shardsvr=true profile=1 sudo vi db3.cnf //db3.cnf replSet=shard3 rest=true port=47019 dbpath=/home/gsunis/data/data3 logappend = true fork=true logpath=/home/gsunis/data/data3/mongodb.log nojournal=false shardsvr=true profile=1 sudo vi db4.cnf //db4.cnf replSet=shard4 rest=true port=47020 dbpath=/home/gsunis/data/data4 logappend = true fork=true logpath=/home/gsunis/data/data4/mongodb.log nojournal=false shardsvr=true profile=1 sudo vi db5.cnf //db5.cnf replSet=shard5 rest=true port=47021 dbpath=/home/gsunis/data/data5 logappend = true fork=true logpath=/home/gsunis/data/data5/mongodb.log nojournal=false shardsvr=true profile=1 sudo vi db6.cnf //db6.cnf replSet=shard6 rest=true port=47022 dbpath=/home/gsunis/data/data6 logappend = true fork=true logpath=/home/gsunis/data/data6/mongodb.log nojournal=false shardsvr=true profile=1 (7).编写启动mongo服务的脚本 sudo vi mg.sh #!/bin/bash instance=$1 action=$2 case &quot;$action&quot; in 'start') /usr/local/mongodb/bin/mongod -f /home/gsunis/data/&quot;$instance&quot;.cnf ;; 'stop') /usr/local/mongodb/bin/mongod -f /home/gsunis/data/&quot;$instance&quot;.cnf --shutdown;; 'restart') /usr/local/mongodb/bin/mongod -f /home/gsunis/data/&quot;$instance&quot;.cnf --shutdown /usr/local/mongodb/bin/mongod -f /home/gsunis/data/&quot;$instance&quot;.cnf;; esac (8).启动docker实例的mongo服务脚本 sudo vi start.sh #!/bin/bash rm /data/conf/*.lock rm /data/data1/*.lock rm /data/data2/*.lock rm /data/data3/*.lock rm /data/data4/*.lock rm /data/data5/*.lock rm /data/data6/*.lock /home/gsunis/data/mg.sh conf start /home/gsunis/data/mg.sh db1 start /home/gsunis/data/mg.sh db2 start /home/gsunis/data/mg.sh db3 start /home/gsunis/data/mg.sh db4 start /home/gsunis/data/mg.sh db5 start /home/gsunis/data/mg.sh db6 start sudo vi start.sh #!/bin/bash rm /data/conf/*.lock rm /data/data1/*.lock rm /data/data2/*.lock rm /data/data3/*.lock rm /data/data4/*.lock rm /data/data5/*.lock rm /data/data6/*.lock /home/gsunis/data/mg.sh conf stop /home/gsunis/data/mg.sh db1 stop /home/gsunis/data/mg.sh db2 stop /home/gsunis/data/mg.sh db3 stop /home/gsunis/data/mg.sh db4 stop /home/gsunis/data/mg.sh db5 stop /home/gsunis/data/mg.sh db6 stop 正常关闭mongoDB服务 ./mongo use admin db.shutdownServer() (9).shard服务器副本集的建立 ./mongo --port 47017 config = {_id: 'shard1', members: [ {_id: 0, host: '10.62.0.128:47017'}, {_id: 1, host: '10.62.0.159:47017'}] } rs.initiate(config) Ctrl + C 退出 ./mongo --port 47018 config = {_id: 'shard2', members: [ {_id: 0, host: '10.62.0.128:47018'}, {_id: 1, host: '10.62.0.159:47018'}] } rs.initiate(config) ./mongo --port 47019 config = {_id: 'shard3', members: [ {_id: 0, host: '10.62.0.128:47019'}, {_id: 1, host: '10.62.0.159:47019'}] } rs.initiate(config) ./mongo --port 47020 config = {_id: 'shard4', members: [ {_id: 0, host: '10.62.0.128:47020'}, {_id: 1, host: '10.62.0.159:47020'}] } rs.initiate(config) ./mongo --port 47021 config = {_id: 'shard5', members: [ {_id: 0, host: '10.62.0.128:47021'}, {_id: 1, host: '10.62.0.159:47021'}] } rs.initiate(config) ./mongo --port 47022 config = {_id: 'shard6', members: [ {_id: 0, host: '10.62.0.128:47022'}, {_id: 1, host: '10.62.0.159:47022'}] } rs.initiate(config)]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F02%2F14%2F%E5%85%B6%E4%BB%96-svn%E8%BF%81%E7%A7%BB%2F</url>
    <content type="text"><![CDATA[title: SVN迁移 tags: SVN copyright: true comments: true toc: true date: 2018-12-19 15:29:55 categories: 工具 password: SVN_Root为所有SVN操作根目录，包括所有的软件、资源库等 Soft：为搭建SVN环境相关的软件 Subversion：为SVN服务端软件安装目录 SVN_BAK：为SVN备份文件 repos:SVN仓库的根目录 ReadMe：当前目录说明文件 所有命令行操作需要管理员权限 服务启动： svnserve.exe -d -r D:\SVN_Root\repos SVN还原 svnadmin load D:\SVN_Root\repos\repos &lt; D:\repos.dump 注册为系统服务 sc create svn binpath= ““D:\SVN_Root\Subversion\bin\svnserve.exe” --service -r D:\SVN_Root\repos” displayname= “Subversion Server” depend= Tcpip start= auto 项目更换服务器，需迁移SVN，现记录过程。 Subversion简介 Subversion（简称SVN）是一款功能强大的开源版本控制工具，支持Linux和Windows平台。 SVN可以有两个访问方式，一种是独立服务器直接访问，即利用svnserve命令启动服务，通过svn://yourdomain.com/project进行访问和操作。另一种结合apache，利用HTTP协议，通过http://yourdomain.com/svn/project进行访问及各类操作。如果服务器需要在互联网上共享，一般选择后一种方式。 通常情况下，如果选择SVN Server和Apache HTTP Server各自独立安装，配置起来会比较繁琐。 软件下载 服务器：Subversion v1.7 http://sourceforge.net/projects/win32svn/ 客户端：Tortoisesvn V1.7 http://tortoisesvn.net/downloads.html 结构说明 D:/svnroot ├─project1 │ ├─conf │ ├─dav │ ├─db │ │ ├─revprops │ │ ├─revs │ │ └─transactions │ ├─hooks │ └─locks └─project2 ├─conf ├─dav ├─db │ ├─revprops │ ├─revs │ └─transactions ├─hooks └─locks 其中：svnroot文件夹为存放所有仓库，也是服务启动的时候需指定的目录，下面的各项为项目目录 启动服务 启动独立服务方式 svnserve –d –r e:/svn_repository/ 访问方法：svn://localhost/dev，或file:///3:/svn_repository/dev 启动apache方式 cd D:/Program Files/CollabNet Subversion Server/httpd/bin httpd.exe 访问方法：http://localhost/svn/dev/ 本项目所使用过程 所有命令行操作需要管理员权限 1.服务启动： svnserve.exe -d -r D:\SVN_Root\repos 2.SVN备份（从源服务器备份，如：192.168.11.121）： A：svnadmin dump d:\svn\repos\project1&gt; dump.dump &gt;D:\repos.dump .dump后缀不能丢 B：备份d:\svn\repos\project1下conf目录 3.SVN还原（拷贝.dump文件到目的服务器，如：192.168.7.116）： A：svnadmin create D:\SVN_Root\repos\project1 B：svnadmin load D:\SVN_Root\repos\project1 &lt; D:\repos.dump C：拷贝2.B中备份的conf文件夹覆盖D:\SVN_Root\repos\project1下conf文件 4.注册为系统服务 sc create svn binpath= ““D:\SVN_Root\Subversion\bin\svnserve.exe” --service -r D:\SVN_Root\repos” displayname= “Subversion Server” depend= Tcpip start= auto 荐读： svnadmin命令： http://blog.csdn.net/wzq9706/article/details/7319728 http://www.ityen.com/archives/529 svn命令：http://blog.sina.com.cn/s/blog_963453200101eiuq.html，svn命令也可通过Tortoisesvn客户端操作代替]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程]]></title>
    <url>%2F2019%2F01%2F02%2FJava-2019-01-02-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[ExecutorService Semaphore 并发实现一个计数器：引入问题 并发与高并发： Java内存模型-写一篇文章 Java内存模型：Java Memory Model（JMM） CPU包括运算逻辑部件、寄存器部件和控制部件等。寄存器在CPU上 Java堆：Heap运行时数据区，有垃圾回收来负责，可以动态分配大小，生存期也不必提前告诉编译器，是在运行时动态分配内存的，由于需要动态分配，所以速度比栈慢 Java栈：Stack速度仅次于寄存器，数据可以共享，缺点是栈中的数据的大小及生存期必须是确定的， 线程之间操作必须通过主内存 https://www.cnblogs.com/zhehan54/p/6130030.html 实现并发的方式有多种：比如多进程、多线程、IO多路复用。 进程是资源（CPU、内存等）分配的基本单位 自定义注解 https://blog.csdn.net/motui/article/details/79012846 线程安全性-原子性 compareAndSwapXXX：当前值和底层值对比，如果一样则执行，如果不一样，则重新获取再比较 AtomicLong LongAdder https://blog.csdn.net/jesonjoke/article/list/1 http://www.cnblogs.com/hongten/p/hongten_oracle_plsql.html https://me.csdn.net/jesonjoke]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac系统神器：Homebrew]]></title>
    <url>%2F2018%2F12%2F19%2F%E5%85%B6%E4%BB%96-02-Homebrew%2F</url>
    <content type="text"><![CDATA[Homebrew Homebrew是一款Mac OS平台下的软件包管理工具，拥有安装、卸载、更新、查看、搜索等很多实用的功能。简单的一条指令，就可以实现包管理，而不用你关心各种依赖和文件路径的情况，十分方便快捷。 可以类比Homebrew的功能类似于前端技术的npm，RetHat系列的yum，Ubuntu系统的apt-get 安装 参考官网，使用非常简单： https://brew.sh/index_zh-cn 安装完之后可更新源： brew update/brew upgrade Homebrew使用 搜索软件：brew search 软件名，如brew search wget 安装软件：brew install 软件名，如brew install wget 卸载软件：brew remove 软件名，如brew remove wget 在macOS系统上，git、node都推荐通过Homebrew安装]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>mac工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UML类图大全]]></title>
    <url>%2F2018%2F12%2F19%2F%E5%85%B6%E4%BB%96-UML%E7%B1%BB%E5%9B%BE%E5%A4%A7%E5%85%A8%2F</url>
    <content type="text"><![CDATA[http://www.cnblogs.com/riky/archive/2007/04/07/704298.html UML类关系图小结 在UML类图中，常见的有以下几种关系: 泛化（Generalization）, 实现（Realization），关联（Association)，聚合（Aggregation），组合(Composition)，依赖(Dependency)。 泛化（Generalization） 【泛化关系】：是一种继承关系，表示一般与特殊的关系，它指定了子类如何特化父类的所有特征和行为。例如：PLC是设备的一种，即既有设备的属性，也有PLC的特性。 【箭头指向】：带三角箭头的实线，箭头指向父类 实现（Realization） 【实现关系】：是一种类与接口的关系，表示类是接口所有特征和行为的实现。 【箭头指向】：带三角箭头的虚线，箭头指向接口 关联（Association) 【关联关系】：是一种拥有的关系，它使一个类知道另一个类的属性和方法；如：老师与学生，丈夫与妻子关联可以是双向的，也可以是单向的。双向的关联可以有两个箭头或者没有箭头，单向的关联有一个箭头。 【代码体现】：成员变量 【箭头及指向】：带普通箭头的实心线，指向被拥有者 聚合（Aggregation） 【聚合关系】：是整体与部分的关系，且部分可以离开整体而单独存在。如车和轮胎是整体和部分的关系，轮胎离开车仍然可以存在。 聚合关系是关联关系的一种，是强的关联关系；关联和聚合在语法上无法区分，必须考察具体的逻辑关系。 【代码体现】：成员变量 【箭头及指向】：带空心菱形的实心线，菱形指向整体 组合(Composition) 【组合关系】：是整体与部分的关系，但部分不能离开整体而单独存在。如公司和部门是整体和部分的关系，没有公司就不存在部门。 组合关系是关联关系的一种，是比聚合关系还要强的关系，它要求普通的聚合关系中代表整体的对象负责代表部分的对象的生命周期。 【代码体现】：成员变量 【箭头及指向】：带实心菱形的实线，菱形指向整体 依赖(Dependency) 【依赖关系】：是一种使用的关系，即一个类的实现需要另一个类的协助，所以要尽量不使用双向的互相依赖. 【代码表现】：局部变量、方法的参数或者对静态方法的调用 【箭头及指向】：带箭头的虚线，指向被使用者 各种关系的强弱顺序： 泛化 = 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖 下面这张UML图，比较形象地展示了各种类图关系：]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>UML类图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gitbook使用]]></title>
    <url>%2F2018%2F12%2F19%2F%E5%85%B6%E4%BB%96-gitbook%2F</url>
    <content type="text"><![CDATA[https://my.oschina.net/huangyong/blog/372491 http://www.widuu.com/chinese_docker/userguide/dockerhub.html gitbook教程 简介及安装 Gitbook是一个开源的跨平台电子书解决方案。通过Gitbook，可以使用Markdown或者AsciiDoc来编写电子书，然后生成静态网页电子书，pdf，mobi，epub格式 在使用GitBook 之前, 我们需要先安装一些必须的工具，Node.js、GitBook、GitBook Editor、Git版本控制器 静态站点：GitBook默认输出该种格式 PDF：需要安装gitbook-pdf依赖 eBook：需要安装ebook-convert itBook官方客户端编辑器，支持Win、Linux、Mac系统 https://www.gitbook.com/ 在线网站，提供在线编写工具，有客户端，免费版本文章默认公开 安装： npm install -g gitbook-cli //想在系统上的任何地方的gitbook命令，需要安装“gitbook CLI” npm install gitbook -g gitbook -V 使用gitbook 创建项目 本地命令创建 mkdir MyFirstBook cd MyFirstBook gitbook init https://www.gitbook.com/ 创建在线版本，即托管到 GitBook.com 账号：github登陆（chetaofeng@163.com） 生成图书 输出为静态网站 在自己的电脑上编辑好图书之后，可以使用Gitbook 的命令行进行本地预览： gitbook build //生成网站，此命令会生成_book目录，而这个目录中的文件，即是生成的静态网站内容 gitbook serve //启动服务 http://localhost:4000 gitbook build --output=/tmp/gitbook //需自己创建好目标目录 输出PDF npm install gitbook-pdf -g //依赖 gitbook pdf【路径/文件名.pdf】 输出电子书mobi 由于 GitBook 生成 mobi 格式电子书依赖 Calibre 的 ebook-convert，所以需下载安装 Calibre Calibre 安装完毕后，对于 Mac OS X 系统，还需要先设置一下软链接： 1ln -s /Applications/calibre.app/Contents/MacOS/ebook-convert /usr/local/bin gitbook mobi【路径/文件名.mobi】 编辑内容 README.md 此文件是简单的电子书介绍，可以把所制作的电子书做一下简单的描述 SUMMARY.md 此为电子书的导航目录文件，每当新增一个章节文件就需要向此文件中添加一条记录。对于 Kindle 电子书来说，此文件所呈现的目录结构就是开头的目录内容和“前往”的目录导航 如果需要“子章节”可以使用 Tab 缩进来实现（最多支持三级标题），如下所示： 1234567# Summary* [第一章](section1/README.md) * [第一节](section1/example1.md) * [第二节](section1/example2.md)* [第二章](section2/README.md) * [第一节](section2/example1.md) Glossary.md 对于电子书内容中需要解释的词汇可在此文件中定义。词汇表会被放在电子书末尾。其格式如下所示： 12# 电子书电子书是指将文字、图片、声音、影像等讯息内容数字化的出版物和植入或下载数字化文字、图片、声音、影像等讯息内容的集存储和显示终端于一体的手持阅读器。 book.json “book.json”是电子书的配置文件，可以看作是电子书的“原数据”，比如 title、description、isbn、language、direction、styles 等，更多:https://toolchain.gitbook.com/ 普通章节.md 文件 每编写一个 .md 文件，不要忘了在“SUMMARY.md”文件中添加一条记录 电子书封面图片 GitBook 帮助文档建议封面图片的尺寸为 1800*2360 像素并且遵循建议： 没有边框 清晰可见的书本标题 任何重要的文字在小版本中应该可见 图片的格式为 jpg 格式 把图片重命名为“cover.jpg”放到电子书项目文件夹即可 高级功能 想要gitBook更美观，或者更符合我们自己的需求，则通过book.json配置进行自定义、以及安装一些常用的插件等 Book.json配置 GitBook 在编译书籍的时候会读取书籍源码顶层目录中的 book.js 或者 book.json。参考： 1234567891011121314151617181920&#123; //样式风格配置格式 &quot;styles&quot;: &#123; &quot;website&quot;: &quot;styles/website.css&quot;, &quot;ebook&quot;: &quot;styles/ebook.css&quot;, &quot;pdf&quot;: &quot;styles/pdf.css&quot;, &quot;mobi&quot;: &quot;styles/mobi.css&quot;, &quot;epub&quot;: &quot;styles/epub.css&quot; &#125;, //插件安装配置格式 &quot;plugins&quot;: [&quot;myplugin&quot;], &quot;pluginsConfig&quot;: &#123; &quot;myPlugin&quot;: &#123; &quot;message&quot;: &quot;Hello World&quot; &#125; &#125; &#125; 自定义插件扩展 插件是扩展GitBook功能最好的方法。使得GitBook功能更加强大 插件搜索：https://plugins.gitbook.com/ 插件安装：npm install 【gitbook-plugin-toggle-chapters】 --save-dev 通过Book.json配置插件 123456&quot;plugins&quot;: [&quot;toggle-chapters&quot;], &quot;pluginsConfig&quot;: &#123; &quot;myPlugin&quot;: &#123; &quot;message&quot;: &quot;Hello World&quot; &#125; &#125; 常用插件：http://zhaoda.net/2015/11/09/gitbook-plugins/ Android的离线打包 通过Gitbook，将电子书打包成静态网站。再将静态网站放到Android APP的assets目录下，作为离线网站，打包成一个离线电子书应用（Android APP） 按照Gitbook规范，编写gitbook电子书 通过Gitbook，将电子书打包成静态网站 使用git将工程gitbook-android克隆下来，https://github.com/snowdream/gitbook-android?spm=5176.100239.blogcont31432.7.rKGSpR 将静态网站放在gitbook-android工程的assets/book目录下 在“gitbook-android\app\src\main\res\values\strings.xml”中修改app_name 在“gitbook-android\app\build.gradle”中修改包名 applicationId “com.github.snowdream.apps.gitbook” 新增以下四个keystore相关的环境变量，用于APK签名. KEYSTORE KEYSTORE_PASSWORD KEY_ALIAS KEY_PASSWORD 在gitbook-android工程目录下，运行gradle assembleRelease --info即可。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>gitbook</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[postman]]></title>
    <url>%2F2018%2F12%2F19%2F%E5%85%B6%E4%BB%96-postman%2F</url>
    <content type="text"><![CDATA[https://www.cnblogs.com/haoduoyu/p/5864775.html 插件网 http://www.cnplugins.com/tool/specify-postman-methods.html http://www.cnplugins.com/tool/specify-postman-methods.html https://www.cnblogs.com/s380774061/p/4624326.html 推荐 https://blog.csdn.net/five3/article/details/53021084 推荐 https://blog.csdn.net/u013613428/article/details/51557804 推荐 https://blog.csdn.net/xiaosongbk/article/details/52801207 token问题 https://blog.csdn.net/u011320646/article/details/77141876 token问题 http://www.graphicsmagick.org/ http://baijiahao.baidu.com/s?id=1574259218782197&amp;wfr=spider&amp;for=pc https://github.com/dmytrodanylyk/folding-plugin]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>postman</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac系统安装]]></title>
    <url>%2F2018%2F12%2F19%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-01-mac%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[U盘启动 U盘启动：目的是为了在没有装系统的情况下进行临时启动，它可以启动DOS、备份还原软件或内存中运行的PE系统。现在大部分的电脑都支持U盘启动。U盘启动在系统奔溃和快速安装系统时能起到很大的作用。 mac系统安装启动盘制作 准备一个 8GB 或更大容量的 U盘，并备份好里面的所有资料 下载好需要安装的系统。在App Store中搜索系统，如：MacOS Sierra，完成下载。 打开 “应用程序 → 实用工具 → 磁盘工具”，将U盘「抹掉」(格式化) 成「Mac OS X 扩展（日志式）」格式、GUID 分区图，并将U盘命名为「Sierra」。(注意：这个盘符名称将会与后面的命令一一对应，如果你改了这盘符的名字，必须保证后面的命令里的名称也要一致) 打开 “应用程序→实用工具→终端”，将下面的一段命令复制并粘贴进去： 1sudo /Applications/Install\ macOS\ Sierra.app/Contents/Resources/createinstallmedia --volume /Volumes/Sierra --applicationpath /Applications/Install\ macOS\ Sierra.app --nointeraction 回车并执行该命令，这时会提示让你输入管理员密码，便会开始制作过程了： 如上图，这时系统已经在制作中了，请耐心等待直到屏幕最后出现 Done. 字样即表示大功告成了 mac系统U盘安装 （此步骤可选：如果想格式化磁盘则进行此操作）启动时按住[command + r]，进入磁盘管理工具抹掉磁盘即可 先在目标电脑上插上 U 盘，然后重启你的 Mac，然后一直按住[option」(alt)] 按键不放，直到屏幕显示多出一个 USB 启动盘的选项。 选择 U 盘的图标回车，即可通过 U 盘来安装 macOS Sierra 了！这时，你可以直接覆盖安装系统(升级)，也可以在磁盘工具里面格式化抹掉整个硬盘，或者重新分区等实现全新的干净的安装 启动过程中电脑会重启，重启的时候，拔掉U盘 安装软件 在登陆App Store之后，往常安装过的软件在&quot;已购项目&quot;列表中有，不用每次安装系统后再一一去查找安装过的程序。 非App Store安装的程序，在安装时，又是会提示app出现某些安装包已损坏、显示未激活、打开崩溃等的提示！！这种多是因为新系统屏蔽了任何来源的设置，所以需要大家打开“允许任何来源”方可安装，可按如下方式操作 步骤1：Spotlight搜索(快捷键：command+空格或右上角搜索的符号)：搜索 “终端” 步骤2：直接复制粘贴 sudo spctl --master-disable 回车 步骤3：输入你的 开机密码 步骤4：回到系统偏好设置 的“安全与隐私”，勾选 “允许任何来源”完成安装. macOS一些其他维护相关知识 官方技术支持网址：https://support.apple.com/zh-cn 关于 Mac 启动时您看到的屏幕：在从 OS X 启动 Mac 时，系统会显示不同的屏幕，以让您了解 Mac 的启动方式，或是启动可能未完成的原因。 https://support.apple.com/zh-cn/HT204156 启动 Mac 时显示闪烁的问号 如果启动时在 Mac 屏幕上看到闪烁的问号，这意味着您的 Mac 无法找到自身的系统软件。 https://support.apple.com/zh-cn/HT204323 如何重新安装 macOS https://support.apple.com/zh-cn/HT204904 关于 macOS 恢复功能 https://support.apple.com/zh-cn/HT201314 使用 Time Machine 备份或恢复 Mac https://support.apple.com/zh-cn/HT201250 如何重置 Mac 上的 NVRAM Command-Option-P-R https://support.apple.com/zh-cn/HT204063 重置 Mac 上的系统管理控制器 (SMC) Shift-Control-Option https://support.apple.com/zh-cn/HT201295 如何识别 MacBook Pro 机型 https://support.apple.com/zh-cn/HT201300]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac虚拟机安装及设置]]></title>
    <url>%2F2018%2F12%2F19%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-03-mac%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%8F%8A%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[简介 Parallels Desktop是一款运行在 Mac 电脑上的极为优秀的虚拟机软件。用户可以在 Mac OS X 下非常方便运行 Windows、Linux 等操作系统及应用。 安装 PD为收费软件，链接: https://pan.baidu.com/s/1CBa7tIghlF7JIiJTtuqdYQ 提取码: es9m，有经济能力的希望支持正版 PD安装操作系统需准备一个系统ISO镜像,虚拟机系统安装过程和普通系统安装过程基本一致。 windows10镜像下载： https://www.microsoft.com/zh-cn/software-download/windows10ISO/ 系统安装完成之后，需安装Parallels Tools，否则使用时鼠标使用等方面会有很多不便，注意安装Parallels Tools时注意PD版本，防止有和系统不兼容。 如下图： PD使用注意事项 虚拟机系统安装完之后在虚拟机系统的【配置】中进行系统内存、硬盘相关参数设置 虚拟机系统安装完之后在虚拟机系统的【配置】中进行系统共享文件夹设置，方便系统间数据共享 虚拟机初试安装后，再进行系统其他重要软件安装前，请先保存快照，再进行操作，操作不成功还可回退 虚拟机系统更新、相关开发环境设置完成之后，建议移动硬盘保存虚拟机，方便后期恢复和循环使用 虚拟机系统文件在右键【显示包内容】后，如下 其中.hdd文件为硬盘文件，可在虚拟机系统故障时优先保存此文件，或者将此文件复制替换到备份的虚拟机系统即可恢复]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git安装配置]]></title>
    <url>%2F2018%2F12%2F19%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-04-git%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[简介 官网：https://git-scm.com/ Git是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。 Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。 详细学习，推荐： http://www.runoob.com/git/git-tutorial.html 廖雪峰大神的git教程 https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000 git的前世今生： https://blog.csdn.net/csdnprogram/article/details/52155078 工作原理 本地 工作区（Working Directory）：就是你在电脑里能看到的目录 版本库（Repository）：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库 Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。 我们把文件往Git版本库里添加的时候，是分两步执行的： 第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区； 第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。 远程配合 git安装 参考教程：https://git-scm.com/book/zh/v2/起步-安装-Git 各平台都支持安装包安装方式 mac系统 12&gt; brew install git&gt; git --version //验证安装 git全局设置 config 配置有system级别 global（用户级别） 和local（当前仓库）三个 设置先从system-》global-》local,底层配置会覆盖顶层配置 查看git不同级别配置信息 123git config --system --listgit config --global --listgit config --和local --list git安装完成后，还需要最后一步设置，在命令行输入： 12$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;email@example.com&quot; 因为Git是分布式版本控制系统，所以，每个机器都必须自报家门 git账号关联流程 生成SSHkey ssh-keygen命令用于为“ssh”生成、管理和转换认证密钥，它支持RSA和DSA两种认证密钥. ssh-keygen(选项) 12345678910-b：指定密钥长度； -e：读取openssh的私钥或者公钥文件； -C：添加注释； -f：指定用来保存密钥的文件名； -i：读取未加密的ssh-v2兼容的私钥/公钥文件，然后在标准输出设备上显示openssh兼容的私钥/公钥； -l：显示公钥文件的指纹数据； -N：提供一个新密语； -P：提供（旧）密语；-q：静默模式； -t：指定要创建的密钥类型。 登陆git服务器，添加public key信息 测试登陆 1234测试是否成功,第一此输入命令，需输入yes后再次输入测试命令后出现类似&quot;Hi...&quot;，表示配置成功&gt; ssh -T git@github.com&gt; ssh -T git@gitee.com&gt; ssh -T git@gitlab.com git单账号关联 12&gt; ssh-keygen -t rsa -C xxxxx@gmail.com（注册github时的email）&gt; cat ~/.ssh/id_rsa.pub 登陆网站，如github／gitee／gitlab等，在如设置／Settings中有SSH and GPG keys中【add new keys】，将id_rsa.pub内容添加，会自动识别标题,设置完成之后测试登陆 git多账号设置关联 多账号配置是通过.ssh文件夹下config文件实现，操作如下： 123456&gt; touch ~/.ssh/config &gt; chmod 600 ~/.ssh/config &gt; ssh-keygen -f ~/.ssh/id_rsa.github -t rsa -C &quot;chetaofeng@163.com&quot;&gt; ssh-keygen -f ~/.ssh/id_rsa.gitee -t rsa -C &quot;chetaofeng@163.com&quot;&gt; ssh-keygen -f ~/.ssh/id_rsa.gitlab -t rsa -C &quot;chetaofeng@163.com&quot; config文件内容如下： 1234567891011121314151617# githubHost github.com HostName github.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa.github# giteeHost gitee.com HostName gitee.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa.gitee# gitlabHost gitlab.com HostName gitlab.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa.gitlab Host： 是我们在输入命令的时候的名字 比如我这里是lab 那么我使用ssh命令的时候需要使用 ssh lab HostName： 是目标主机的主机名，也就是平时我们使用ssh后面跟的地址名称。 Port：指定的端口号。 User：指定的登陆用户名。 IdentifyFile：指定的私钥地址。 .gitignore文件 不添加到版本库的内容记录，创建项目后一定要添加.gitignore文件 开发环境中配置 在Jetbrains系列开发工具中，【Version Control】界面中github选项默认有，进行设置即可 gitlab／gitee没有配置选项，需先安装相应插件，如下： 以前配置gitlab的时候，是通过Other Settings-&gt;GitLab Settings设置如下： GitLab Server Url: https://gitlab.com/ GitLab API Key： https://gitlab.com/profile/account git项目权限管理 Git项目一般有五种身份权限，分别是： Owner 项目所有者，拥有所有的操作权限 Master 项目的管理者，除更改、删除项目元信息外其它操作均可 Developer 项目的开发人员，做一些开发工作，对受保护内容无权限 Reporter 项目的报告者，只有项目的读权限，可以创建代码片断 Guest 项目的游客，只能提交问题和评论内容 私服项目使用推荐流程 以下为项目owner需进行工作 在私服先创建项目，添加人员并设置人员权限 在本地webstorm中clone项目 在clone项目中添加.gitignore文件 添加.gitignore及相关需要版本控制的文件夹到版本控制（选中项后右键操作） 提交项目并备注为初始提交 以下为项目成员需做工作 在本地webstorm中clone项目 创建项目分支（可一人一个，也可通过项目模块进行分支创建），如果直接在master分支，则无法成功push项目提示被rejected 进行代码编写 提交需管理分支 在gitlab私服网页发起合并请求，并添加详细描述 等待相关人员进行合并 合并结束后更新master分支 创建分支继续工作]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node安装配置]]></title>
    <url>%2F2018%2F12%2F19%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-05-node%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[相关概念 nodejs：在项目开发时的所需要的代码库 nvm：nodejs 版本管理工具。 npm：nodejs包管理工具，在安装的 nodejs 的时候，npm也会跟着一起安装，它是包管理工具，管理nodejs中的第三方插件 yarn：Yarn是由Facebook、Google、Exponent 和 Tilde 联合推出了一个新的 JS 包管理工具 ， 是为了弥补 npm 的一些缺陷而出现的 即：一个nvm可以管理多个node版本和npm版本 nvm安装 官网： https://github.com/creationix/nvm 安装：curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.34.0/install.sh | bash 安装完成后的提示界面会有类似一下的提示信息： 12export NVM_DIR=&quot;$HOME/.nvm&quot;[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \. &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm 在~/.bash_profile中添加以上内容(如果没有这个文件则创建)后保存；通过source ~/.bash_profile使设置生效。 安装完成后关闭终端，重新打开终端输入 nvm 验证一下是否安装成功 注：curl看系统是否已安装，如果没有安装则：sudo apt-get install curl nvm常用命令 nvm install stable ## 安装最新稳定版 node，当前是node v9.5.0 (npm v5.6.0) nvm install ## 安装指定版本，可模糊安装，如：安装v4.4.0，既可nvm install v4.4.0，又可nvm install 4.4 nvm uninstall ## 删除已安装的指定版本，语法与install类似 nvm use ## 切换使用指定的版本node nvm ls ## 列出所有安装的版本 nvm ls-remote ## 列出所有远程服务器的版本（官方node version list） nvm current ## 显示当前的版本 nvm alias ## 给不同的版本号添加别名 nvm unalias ## 删除已定义的别名 nvm reinstall-packages ## 在当前版本 node 环境下，重新全局安装指定版本号的 npm 包 nvm安装node nvm install stable yarn 快速、可靠、安全的依赖管理工具 安装 brew install yarn brew install yarn --without-node Yarn和npm命令对比 npm yarn npm install yarn install npm install react --save yarn add react npm uninstall react --save yarn remove react npm install react --save-dev yarn add react --dev npm update --save yarn upgrade]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS安装设置]]></title>
    <url>%2F2018%2F12%2F19%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-07-CentOS%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[https://blog.csdn.net/ganeshys2017/article/details/81300246 http://www.cnblogs.com/linnuo/p/6257204.html https://blog.csdn.net/lwwl12/article/details/78247307]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDK安装配置]]></title>
    <url>%2F2018%2F12%2F19%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-06-Java%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[JDK下载 http://www.oracle.com/technetwork/java/javase/downloads/index.html https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html 环境变量设置说明 （jdk 需要配置三个环境变量； 1.5之后可以不再设置classpath，但建议保留classpath设置） CLASS_PATH 保证class文件能够在任意目录下运行 PATH 保证javac可以在任意目录下运行 mac系统 环境变量配置文件执行的顺序： /etc/profile /etc/paths ~/.bash_profile ~/.bash_login ~/.profile ~/.bashrc /etc/profile和/etc/paths是系统级别的，系统启动就会加载，剩下的是用户级别的。 下载dmg安装包后直接安装后，通过java -version；java；javac验证，个人发现最新版本中不用系统环境变量配置，重启电脑验证过， 配置环境变量的方式： 找到JDK安装目录，如： 1/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home 编辑文件~/.bash_profile 文件 12345JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/HomePATH=$JAVA_HOME/bin:$PATH:.export JAVA_HOMEexport PATH 使配置生效：source .bash_profile 输入 echo $JAVA_HOME 显示刚才配置的路径 验证安装 Linux系统 安装前，请在终端中通过java命令查看是否系统已默认安装OpenJDK，如果有，则先卸载 下载安装包后解压，如：sudo tar -zxvf jdk-8u77-linux-x64.tar.gz,得到jdk1.8.0_77文件夹 sudo mkdir /usr/java sudo cp -r jdk1.8.0_77/ /usr/java/ 配置环境变量,sudo vim /etc/profile,在前面添加 123export JAVA_HOME=/usr/java/jdk1.8.0_77export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH source /etc/profile 使配置立即生效 检查新安装的jdk:java -version;java;javac]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu系统安装后的设置]]></title>
    <url>%2F2018%2F12%2F19%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-08-Ubuntu%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E5%90%8E%E7%9A%84%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[修改默认源为国内源 cd /etc/apt cp /etc/apt/sources.list /etc/apt/sources.list.bak 备份/etc/apt/sources.list 在/etc/apt/sources.list文件前面添加源条目,具体源条目可百度，如阿里源： 1234567891011#添加阿里源deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse 更新源 12sudo apt-get updatesudo apt-get upgrade 系统分辨率设置 安装Ubuntu系统后分辨率为800*600且无法修改，通过以下方式修改： 首先打开终端Terminal，输入: sudo apt-get install xdiagnose sudo xdiagnose 启动【X 诊断工具设置】，点击【Apply】 sudo reboot 重启系统 再次打开设置发现分辨率可以设置了,如设置为：1280*800 chrome浏览器安装 wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb sudo dpkg -i google-chrome-stable_current_amd64.deb]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JetBrains系列软件安装配置]]></title>
    <url>%2F2018%2F12%2F19%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-09-JetBrains%E7%B3%BB%E5%88%97%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[软件破解 软件破解请参考： http://idea.lanyus.com/ 使用前请将“0.0.0.0 account.jetbrains.com”添加到hosts文件中 在网页获取注册码，在注册页面填入注册码即可 Android Studio安装 以下为相关软件下载，2／3中软件为采用第三方模拟器的时候需要下载，利用自带模拟器则可跳过下载 下载Android Studio安装软件： https://developer.android.google.cn/studio/#downloads 下载virtualbox： https://www.virtualbox.org/wiki/Linux_Downloads 下载Genymotion： https://www.genymotion.com/download 安装前请确保网络状态良好，现在安装Android Studio，所需Android SDK、自带模拟器镜像、gradle等都可以在线直接通过开发工具下载安装 mac系统 直接安装dmg安装包即可 Linux系统 进入安装包所在目录下，如：android-studio-ide-181.5056338-linux.zip sudo mkdir /usr/JetBrains sudo cp android-studio-ide-181.5056338-linux.zip /usr/JetBrains cd /usr/JetBrains sudo unzip android-studio-ide-181.5056338-linux.zip cd android-studio/bin 命令行启动AndroidStuido： ./studio.sh，正常的话应该会出现软件的配置设置 软件启动，因为没有Android SDK，会弹出提示界面，点击cancle之后会自动下载Android SDK，然后创建测试项目，过程中运行所需资源都会自动下载，耐心等待即可 设置启动图标启动Android Studio sudo vim /usr/share/applications/android-studio.desktop 编辑文件内容： 123456[Desktop Entry]Type=ApplicationName=Android StudioComment=Android Studio Integrated Development EnvironmentIcon=/usr/JetBrains/android-studio/bin/studio.pngExec=/usr/JetBrains/android-studio/bin/studio.sh 在启动器别表即可找到Android Studio启动图标，点击启动即可 模拟器 Android程序调试可通过真机、自带模拟器、第三方模拟器调试 第三方模拟器大多使用Genymotion，官网下载：https://www.genymotion.com/download/ android Studio安装Genymotion插件使用 安装过程遇到的问题 linux中启动模拟器出现grant current user access to /dev/kvm错误 解决方法：打开terminal,输入代码who／whoami查找当前用户名；sudo chown username -R /dev/kvm 注意username是你用的用户名 无法修改模拟器创建时的选项 emulated performance 解决方法： Nexus 5X和Nexus 5镜像不支持，换成其他镜像即可 https://blog.csdn.net/wshish920907/article/details/78249528 InteliJ IDEA安装 下载地址：http://www.jetbrains.com/idea/?fromMenu Linux系统 进入安装包所在目录下，如：ideaIU-2016.1.2.tar.gz sudo cp android-studio-ide-181.5056338-linux.zip /usr/JetBrains，如果没有JetBrains则自己创建 cd /usr/JetBrains sudo tar -zxvf ideaIU-2016.1.2.tar.gz sudo mv idea-IU-145.971.21 idea cd idea/bin 命令行启动Idea： ./idea.sh，正常的话应该会出现软件的配置设置 软件启动，创建任意Java程序，配置JDK路径，然后创建测试项目，过程中运行所需资源都会自动下载，耐心等待即可 设置启动图标启动Idea sudo vim /usr/share/applications/idea.desktop，当然软件启动后也会提示是否创建快捷访问链接，可通过IDEA创建启动图标 编辑文件内容： 123456[Desktop Entry]Type=ApplicationName=InteliJ IDEAComment=InteliJ IDEA Integrated Development EnvironmentIcon=/usr/JetBrains/idea/bin/idea.pngExec=/usr/JetBrains/idea/bin/idea.sh 在启动器别表即可找到InteliJ IDEA启动图标，点击启动即可 WebStorm安装 下载地址：http://www.jetbrains.com/webstorm/download/#section=linux webstorm安装请参考AndroidStudio和IDEA 设置启动图标启动Idea sudo vim /usr/share/applications/idea.desktop，当然软件启动后也会提示是否创建快捷访问链接，可通过IDEA创建启动图标 编辑文件内容： 123456[Desktop Entry]Type=ApplicationName=WebStormComment=WebStorm Integrated Development EnvironmentIcon=/usr/JetBrains/WebStorm/bin/webstorm.pngExec=/usr/JetBrains/WebStorm/bin/webstorm.sh]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[aa]]></title>
    <url>%2F2018%2F12%2F19%2FJava-2018-12-19-aa%2F</url>
    <content type="text"><![CDATA[https://www.cnblogs.com/god--love-you/p/6133390.html springboot https://blog.csdn.net/forezp/column/info/15397/1 https://blog.csdn.net/vbirdbest/article/category/7490600/3 https://github.com/lenve/vhr netty https://waylau.com/netty-4-user-guide/ https://github.com/doocs/advanced-java https://blog.csdn.net/qq_38765404/article/details/78615572 http://www.cnblogs.com/felixzh/p/5869212.html oracle https://www.cnblogs.com/kane1990/p/OracleNetManager.html https://blog.csdn.net/u011179993/article/details/51554324 https://www.cnblogs.com/yadongliang/p/5840203.html http://blog.51cto.com/mazongfei/2126876 https://blog.csdn.net/weixin_37480339/article/details/81017214 https://blog.csdn.net/wangjialiang/article/details/7867791 http://blog.sina.com.cn/s/blog_13689d7d40102y3d3.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[CentOS 图形界面 命令行界面切换 - CentOS]]></title>
    <url>%2F2018%2F12%2F19%2FLinux-CentOS-%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2-%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%95%8C%E9%9D%A2%E5%88%87%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[一、修改/etc/inittab文件中的 id:3:initdefault ， 将3改为5则为图形界面 ，反之则为命令行界面，修改完后重新启动系统生效 二、如果用户已经启动了字符CentOS界面，想要进入图形CentOS界面可以使用如下命令 startx 三、运行级别说明，用 init -x 切换级别，如想进入图形界面则输入 init -5 即可切换； 1234567* 0 所有进程将被终止，机器将有序的停止，关机时系统处于这个运行级别 * 1 单用户模式。用于系统维护，只有少数进程运行，同时所有服务也不启动 * 2 多用户模式。和运行级别3一样，只是网络文件系统（NFS）服务没被启动 * 3 多用户模式。允许多用户登录系统，是系统默认的启动级别 * 4 留给用户自定义的运行级别 * 5 多用户模式，并且在系统启动后运行X-Window，给出一个图形化的登录窗口 * 6 所有进程被终止，系统重新启动 图形界面问题处理 Centos7解决图形界面卡死问题 1killall -9 gnome-shell]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CentOS查看硬件信息]]></title>
    <url>%2F2018%2F12%2F19%2FLinux-CentOS%E6%9F%A5%E7%9C%8B%E7%A1%AC%E4%BB%B6%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"><![CDATA[操作系统信息：lsb_release -a ；uname -a 查看网卡型号：lspci | grep Ethernet controller 查看硬盘信息：df -ah 查看内存信息：cat /proc/meminfo 查看CPU信息：more /proc/cpuinfo | grep “model name”]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS下yum源的搭建与使用]]></title>
    <url>%2F2018%2F12%2F19%2FLinux-CentOS%E4%B8%8Byum%E6%BA%90%E7%9A%84%E6%90%AD%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[[toc] yum简介 yum就是为了解决依赖关系而存在的 yum源就相当是一个目录项，当我们使用yum机制安装软件时，若需要安装依赖软件，则yum机制就会根据在yum源中定义好的路径查找依赖软件，并将依赖软件安装好 YUM是“Yellow dog Updater, Modified”的缩写，是一个软件包管理器，YUM从指定的地方（相关网站的rpm包地址或本地的rpm路径）自动下载RPM包并且安装，能够很好的解决依赖关系问题 yum两种源：本地yum源和网络yum源 yum工作机制 服务器端 在服务器上面存放了所有的RPM软件包，然后以相关的功能去分析每个RPM文件的依赖性关系，将这些数据记录成文件存放在服务器的某特定目录内 客户端 如果需要安装某个软件时，先下载服务器上面记录的依赖性关系文件(可通过WWW或FTP方式)，通过对服务器端下载的纪录数据进行分析，然后取得所有相关的软件，一次全部下载下来进行安装 yum文件 在/etc/yum.repos.d 目录下存放的就是yum源的设定文件 yum repolist all //此命令可查看启用的源配置文件 *.repo各配置项说明 1234567* [base]：代表容器的名字，里面的名称则可以随意取，但是不能有两个相同的容器名称， 否则 yum 会不晓得该到哪里去找容器相关软体清单档案* name：只是说明一下这个容器的意义而已，重要性不高* mirrorlist=：列出这个容器可以使用的映射站台，如果不想使用，可以注解到这行* baseurl=：这个最重要，因为后面接的就是容器的实际网址！ mirrorlist 是由 yum 程式自行去捉映射站台， baseurl 则是指定固定的一个容器网址* enable=1：就是让这个容器被启动 * gpgcheck=1：指定是否需要查阅RPM档案内的数位签章！0表示不检测* gpgkey=：就是数位签章的公钥档所在位置！使用预设值即可 更改yum源与更新系统 备份/etc/yum.repos.d/CentOS-Base.repo: 1mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup 进入yum源配置文件所在文件夹 1cd /etc/yum.repos.d/ 下载163或其他的yum源配置文件，放入/etc/yum.repos.d/(操作前请做好相应备份) 1wget http://mirrors.163.com/.help/CentOS6-Base-163.repo 运行yum makecache生成缓存:yum makecache 更新系统:yum -y update yum基本使用 参数说明: 123456789101112131415161718-y : 如果在工作过程中如要使用者响应,这个参数可以直接回答yeslist : 列出在yum server 上面有的RPM套件install: 安装某个套件update : 升级某个套件,如果update后面没有接套件名称,即更新目前主机所有已安装的套件.info : 列出某个套件的详细信息,相当于rpm -qi package内容clean : 将已下载到本机的packages或headers移除remove : 移除已经安装在系统中的某个套件yum localinstall package 本地安装软件包yum update 全部更新yum update package 更新指定程序包packageyum check-update 检查可更新的程序yum info 显示安装包信息yum list 显示所有已经安装和可以安装的程序包 yum search 查找软件包yum remove | erase package1 删除程序包yum clean headers 清除headeryum clean packages 清除下载的rpm包yum clean all 清除header与rpm包 yum源服务器的搭建 yum源的搭建可分为三步：①搭建Apache服务器②挂载ISO镜像，将镜像中的包放至Apache服务器目录下③ISO镜像的包比较老旧，可以定时同步其他源中的包到本地 客户端访问yum源服务器]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS修改Root密码]]></title>
    <url>%2F2018%2F12%2F19%2FLinux-Linux%E4%B8%8Bscp%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[scp简介 scp是secure copy的简写，用于在Linux下进行远程拷贝文件的命令，和它类似的命令有cp，不过cp只是在本机进行拷贝不能跨服务器，而且scp传输是加密的。可能会稍微影响一下速度。 scp作用说明 我们需要获得远程服务器上的某个文件，远程服务器既没有配置ftp服务器，没有开启web服务器，也没有做共享，无法通过常规途径获得文件时，只需要通过scp命令便可轻松的达到目的 我们需要将本机上的文件上传到远程服务器上，远程服务器没有开启ftp服务器或共享，无法通过常规途径上传是，只需要通过scp命令便可以轻松的达到目的。 使用举例 123456789#将本地文件拷贝到服务器上scp -rp /path/filename username@remoteIP:/path #将远程文件从服务器下载到本地scp -rp username@remoteIP:/path/filename /path #压缩传输tar cvzf - /path/ | ssh username@remoteip &quot;cd /some/path/; cat -&gt; path.tar.gz&quot; #压缩传输一个目录并解压tar cvzf - /path/ | ssh username@remoteip &quot;cd /some/path/; tar xvzf -&quot; 脚本方式举例 123456#!/bin/bash ssh root@192.168.0.23 &lt;&lt; remotessh killall -9 java cd /data/apache-tomcat-7.0.53/webapps/ exit remotessh 远程执行的内容在“&lt;&lt; remotessh ” 至“ remotessh ”之间，在远程机器上的操作就位于其中，注意的点：&lt;&lt; remotessh，ssh后直到遇到remotessh这样的内容结束，remotessh可以随便修改成其他形式。在结束前，加exit退出远程节点 参数 -v 和大多数 linux 命令中的 -v 意思一样 , 用来显示进度 . 可以用来查看连接 , 认证 , 或是配置错误 -C 使能压缩选项 -4 强行使用 IPV4 地址 -6 强行使用 IPV6 地址]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS系统GRUB]]></title>
    <url>%2F2018%2F12%2F19%2FLinux-CentOS%E7%B3%BB%E7%BB%9FGRUB%2F</url>
    <content type="text"><![CDATA[[toc] 简介 Grub（GRand Unified Bootloader）是统一资源引导器，也就是引导加载器；它的工作是提供一个菜单，允许用户选择要启动的系统或不同的内核版本；把用户选定的内核装载到RAM中的特定空间中，然后解压、展开，而后把系统控制权移交给内核 它目前有两个版本： GRUB 0.X：Grub Legacy GRUB 1.X：Grub2 Grub Legacy概述 Grub Legacy是最经典的Grub程序。它分为三个部分stage1、stage1_5和stage2 stage1 即写入mbr中存储的bootloader程序。它的任务就是将stage1_5（此时并不能算是磁盘分区/boot/grub/下的stage1_5,因为stage1无法识别文件系统）载入内存执行 stage1_5 位于mbr之后的扇区，通过提供基本文件系统驱动让stage1中的bootloader程序能识别磁盘分区/boot/grub/上的stage2文件并载入内存执行 注意：此处若是boot分区的文件系统类型不属于stage1_5的中的一个，则会借助ramdisk来加载在/lib64/moudles/下额外的文件系统驱动。 stage2 这个程序主要给用户提供一个比较友好的启动菜单，而后去加载位于同一个磁盘分区/boot/的内核文件（例如 vmlinuz-2.6.32-573.el6.x86_64） Grub的配置文件和功用 配置文件：/boot/grub/grub.conf，保证grub和内核等在一个目录；此外它创建了一个链接文件/etc/grub.conf指向配置文件来保证用户使用配置文件一致性 配置项： 12345678910default=#：设定默认启动的菜单项：菜单项（title）编号从0开始timeout=#：指定菜单项等待选项选择的时长；splashimage=(hd#,#)/PATH/TO/XPM_PIC_FILE：指明菜单背景图片文件路径；hiddemenu：隐藏菜单password [--md5] STRING：菜单编辑认证；title TITLE：定义菜单项“标题”，可出现多次； root（hd#，#）：grub查找stage2及kernel文件所在设备分区：为grub的“根” kernel /PATH/TO/VMLINUZ_FILE [PARAMETERS]：启动的内核 initrd /PATH/TO/INITRAMFS_FILE：内核匹配的ramfs文件 password [--md5] STRING：启动选定的内核或者操作系统进行认证； 示例： /boot/grub/menu.lst 或者 /boot/grub/grub.conf CentOS下这两个文件是绑定的 123456789101112131415161718192021222324# grub.conf generated by anaconda # # Note that you do not have to rerun grub after making changes to this file # NOTICE: You have a /boot partition. This means that # all kernel and initrd paths are relative to /boot/, eg. # root (hd1,0) # kernel /vmlinuz-version ro root=/dev/VolGroup00/LogVol00 # initrd /initrd-version.img #boot=/dev/sdb default=0 timeout=5 splashimage=(hd0,0)/grub/splash.xpm.gz hiddenmenu title CentOS (2.6.18-274.3.1.el5) root (hd0,0) kernel /vmlinuz-2.6.18-274.3.1.el5 ro root=/dev/VolGroup00/LogVol00 initrd /initrd-2.6.18-274.3.1.el5.img title CentOS (2.6.18-238.el5) root (hd0,0) kernel /vmlinuz-2.6.18-238.el5 ro root=/dev/VolGroup00/LogVol00 initrd /initrd-2.6.18-238.el5.img title Other rootnoverify (hd0,3) chainloader +1 功用 123456781. 提供菜单、并提供交互式接口* e：编辑模式，用于编辑菜单* c：命令模式，交互式接口2. 加载用户选择的内核或操作系统* 允许传递参数给内核；可隐藏此菜单（通过grub.conf中的hiddenmenu）3. 为菜单提供了保护机制* 为编辑菜单进行认证（title上定义的password）* 为启用内核或者操作系统进行认证（title下的password字段） Grub的命令行接口和编辑功能 进入grub的命令行界面和编辑界面 启动机器时，按ESC键可进入内核选择界面 按c可进入命令行界面 按e可进入编辑界面 rub的命令行命令和编辑命令 grub的命令行命令 1234567help：获取帮助信息help KEYWORD：获取某一具体命令的帮助信息find (hd#,#)/PATH/TO/SOMEFFILE：查找文件（内核文件等）root (hd#,#)：设定那个磁盘是根，执行后，fnd不需指磁盘了；kernel /PATH/TO/KERNEL_FILE：设定本次启动时用到的内核文件；initrd /PATH/TO/OMOTRAMFS_FILE：设定为选定的initrd文件boot：引导启动选定的内核； grub的编辑命令 123456b：boot，启动e：edit，编辑选中的项o：在选中行的下一行新加一行O：在选中行的上一行添加一行d：删除选中行ESC：可以退出编辑界面进入主界面 grub的安装 grub-install 使用格式：grub-install --root-directory=/PATH/TO/rootDIR DEVICE 示例：grub-install --root-directory=/ /dev/sda3 2. grub命令（shell中输入） grub&gt; root (hd0,0) grub&gt; setup (hd0)]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell脚本调试]]></title>
    <url>%2F2018%2F12%2F19%2FLinux-Shell%E8%84%9A%E6%9C%AC%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[前言 shell编程在unix/linux世界中使用得非常广泛，熟练掌握shell编程也是成为一名优秀的unix/linux开发者和系统管理员的必经之路 与其它高级语言相比，shell解释器缺乏相应的调试机制和调试工具的支持，其输出的错误信息又往往很不明确 调试方法 通过echo方式 123功能: 最简单的调试方法，可以在任何怀疑出错的地方用echo打印变量场合: 所有怀疑可能有问题的地方示例: echo $VAR 通过test的方式 返回值为0为真,1表假 1test -f /test.sh | echo $? 使用调试工具-bashdb 使用shell调试器bashdb，这是一个类似于GDB的调试工具，可以完成对shell脚本的断点设置，单步执行，变量观察等许多功能 用法：bashdb -c script.sh 或者 bashdb script.sh 通过trap来调试 123456789作用: 用于捕获指定的信号并执行预定义的命令语法: trap `command` signal说明: signal是要捕获的信号,command是捕获到指定的信号，所要执行的命令, 可以用kill -l命令看到系统中全部可用的信号名,捕获信号后所执行的命令,可以是一条或多条合法的Shell语句,也可以是一个函数名, Shell脚本执行时，会产生三个伪信号(之所以称为伪信息，因这是shell自己产生，而非操作系统产生)，通过使用trap 捕获这三个伪信号并输出信息对调试大有帮助Shell脚本执行时，会产生三个伪信号(之所以称为伪信息，因这是shell自己产生，而非操作系统产生)，通过使用trap 捕获这三个伪信号并输出信息对调试大有帮助.SHELL三个伪信号:* EXIT 从一个函数中退出或整个执行完毕* ERR 当一个命令执行不成功，返回非0状态时* DEBUG 脚本中每一条命令执行之前 1234567891011121314151617#!/bin/basherrorTrap()&#123; echo &quot;[LINE:$1]Error: Command or function exited with status $?&quot;&#125;foo()&#123; return 1;&#125;trap &apos;errorTrap $LINENO&apos; ERRabcfoo脚本输出:[root@localhost:shell]# bash test.shtest.sh: line 12: abc: command not found[LINE:12]Error: Command or function exited with status 127[LINE:9]Error: Command or function exited with status 1 在调试过程中，为了跟踪某些变量的值，我们常常需要在shell脚本的许多地方插入相同的echo语句来打印相关变量的值，这种做法显得烦琐而笨拙。而通过捕获DEBUG信号，我们只需要一条trap语句就可以完成对相关变量的全程跟踪。 1234567891011#!/bin/bashtrap &apos;echo “before execute line:$LINENO, a=$a,b=$b,c=$c”&apos; DEBUGa=1if [ &quot;$a&quot; -eq 1 ]then b=2else b=1fic=3echo &quot;end&quot; 其执行输出结果如下： 123456before execute line:3, a=,b=,c=before execute line:4, a=1,b=,c=before execute line:6, a=1,b=,c=before execute line:10, a=1,b=2,c=before execute line:11, a=1,b=2,c=3end 使用tee命令 在shell脚本中管道以及输入输出重定向使用得非常多，在管道的作用下，一些命令的执行结果直接成为了下一条命令的输入。如果我们发现由管道连接起来的一批命令的执行结果并非如预期的那样，就需要逐步检查各条命令的执行结果来判断问题出在哪儿，但因为使用了管道，这些中间结果并不会显示在屏幕上，给调试带来了困难，此时我们就可以借助于tee命令了 tee命令会从标准输入读取数据，将其内容输出到标准输出设备,同时又可将内容保存成文件 12ipaddr=`/sbin/ifconfig | grep &apos;inet addr:&apos; | grep -v &apos;127.0.0.1&apos;| tee temp.txt | cut -d : -f3 | awk &apos;&#123;print $1&#125;&apos;` 使用&quot;调试钩子&quot; 在C语言程序中，我们经常使用DEBUG宏来控制是否要输出调试信息，在shell脚本中我们同样可以使用这样的机制，这样的代码块通常称之为“调试钩子”或“调试块”.如下列代码所示： 123if [ “$DEBUG” = “true” ]; thenecho “debugging” #此处可以输出调试信息fi 通过选项方式 -n:选项只做语法检查，而不执行脚本 //sh -n script_name.sh -x:启动调试 //sh -x script_name.sh 进入调试模式后，Shell依次执行读入的语句，产生的输出中有的带加号，有的不带。带加号表示该条语句是Shell执行的；不带加号表示该语句是Shell产生的输出；前面有“++”号的行是执行trap机制中指定的命令。&quot;+&quot;号后面显示的是经过了变量替换之后的命令行的内容，有助于分析实际执行的是什么命令 1231).在命令行提供参数：$ sh -x script.sh2).脚本开头提供参数：#!/bin/sh -x3).在脚本中用set命令启用or禁用参数：其中set -x表启用，set +x表禁用 -c:该选项使Shell解析器从字符串而非文件中读取并执行命令,如：bash -c ‘x=1;y=2;let z=x+y;echo “z=$z”’ -v：区别于-x参数,该选项打印命令行的原始内容，-x参数打印出经过替换后命令行的内容，适用于仅想显示命令行的原始内容 Ctrl + Z:中断调试，观察结果，然后再按fg键继续调试即可 调试代码块:-x选项是调试整个脚本的，如果脚本很大，会很不方便，还有一种方法是调试某一块代码的 12345set -x...code block...set +x shell内置的环境变量 $LINENO：代表shell脚本的当前行号，类似于C语言中的内置宏__LINE__ FUNCNAME：函数的名字，它是一个数组变量，其中包含了整个调用链上所有的函数的名字，故变量FUNCNAME：函数的名字，它是一个数组变量，其中包含了整个调用链上所有的函数的名字，故变量FUNCNAME：函数的名字，它是一个数组变量，其中包含了整个调用链上所有的函数的名字，故变量{FUNCNAME[0]}代表shell脚本当前正在执行的函数的名字，而变量FUNCNAME[1]则代表调用函数{FUNCNAME[1]}则代表调用函数FUNCNAME[1]则代表调用函数{FUNCNAME[0]}的函数的名字，余者可以依此类推 $PS4： 常见错误诊断 xxx.sh: cannot shift 1这种错误一般是参数传递有误，比如没有给参数，或者参数个数少了。因为shell脚本使用shift来获取下一个参数，如果个数不对，shift命令就会失败 xxx.sh: ^M: not found 12^M是Windows上的回车符\r在UNIX上的显示形式。这种情况多半是在Windows上编辑了shell脚本，然后拿到UNIX/Linux上执行。如下处理即可：tr -d &quot;\015&quot; &lt; oldfile.sh &gt; newfile.sh //\r的ASCII码是\015]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VI编辑器使用]]></title>
    <url>%2F2018%2F12%2F19%2FLinux-VI%E7%BC%96%E8%BE%91%E5%99%A8%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[vi编辑器是所有Unix及Linux系统下标准的编辑器，它的强大不逊色于任何最新的文本编辑器，对Unix及Linux系统的任何版本，vi编辑器是完全相同的。 vi的基本概念 命令行模式command mode 控制屏幕光标的移动，字符、字或行的删除，移动复制某区段及进入Insert mode下，或者到 last line mode； 插入模式（Insert mode） 只有在Insert mode下，才可以做文字输入，按「ESC」键可回到命令行模式 底行模式（last line mode） 将文件保存或退出vi，也可以设置编辑环境，如寻找字符串、列出行号…… 不过一般我们在使用时把vi简化成两个模式，就是将底行模式（last line mode）也算入命令行模式command mode） vi的基本操作 进入vi的命令 123456vi filename:打开或新建文件，并将光标置于第一行首vi +n filename：打开文件，并将光标置于第n行首vi + filename ：打开文件，并将光标置于最后一行首vi +/pattern filename：打开文件，并将光标置于第一个与pattern匹配的串处vi -r filename ：在上次正用vi编辑时发生系统崩溃，恢复filenamevi filename....filename ：打开多个文件，依次编辑 退出vi及保存文件 在「命令行模式（command mode）」下，按一下「：」冒号键进入「Last line mode」 123: w filename （输入 「w filename」将文章以指定的文件名filename保存）: wq (输入「wq」，存盘并退出vi): q! (输入q!， 不存盘强制退出vi) 移动光标 12345678910111213按「h」、「j」、「k」、「l」，分别控制光标左、下、上、右移一格。按「ctrl」+「b」：屏幕往&quot;后&quot;移动一页按「ctrl」+「f」：屏幕往&quot;前&quot;移动一页按「ctrl」+「u」：屏幕往&quot;后&quot;移动半页按「ctrl」+「d」：屏幕往&quot;前&quot;移动半页按数字「0」：移到文章的开头按「G」：移动到文章的最后按「$」：移动到光标所在行的&quot;行尾&quot;按「^」：移动到光标所在行的&quot;行首&quot;按「w」：光标跳到下个字的开头按「e」：光标跳到下个字的字尾按「b」：光标回到上个字的开头按「#l」：光标移到该行的第#个位置，如：5l,56l 删除文字 123456「x」：每按一次，删除光标所在位置的&quot;后面&quot;一个字符「#x」：例如，「6x」表示删除光标所在位置的&quot;后面&quot;6个字符「X」：大写的X，每按一次，删除光标所在位置的&quot;前面&quot;一个字符「#X」：例如，「20X」表示删除光标所在位置的&quot;前面&quot;20个字符「dd」：删除光标所在行「#dd」：从光标所在行开始删除#行 复制 12345「yw」：将光标所在之处到字尾的字符复制到缓冲区中「#yw」：复制#个字到缓冲区「yy」：复制光标所在行到缓冲区「#yy」：例如，「6yy」表示拷贝从光标所在的该行&quot;往下数&quot;6行文字「p」：将缓冲区内的字符贴到光标所在位置。注意：所有与&quot;y&quot;有关的复制命令都必须与&quot;p&quot;配合才能完成复制与粘贴功能 恢复上一次操作 1「u」：如果您误执行一个命令，可以马上按下「u」，回到上一个操作。按多次&quot;u&quot;可以执行多次恢复 跳至指定的行 12「ctrl」+「g」列出光标所在行的行号「#G」：例如，「15G」，表示移动光标至文章的第15行行首 列出行号 1命令行模式：输入「set nu」后，会在文件中的每一行前面列出行号 跳到文件中的某一行 1命令行模式：「#」号表示一个数字，在冒号后输入一个数字，再按回车键就会跳到该行了，如输入数字15，再回车，就会跳到文章的第15行 查找字符 12* 「/关键字」：先按「/」键，再输入您想寻找的字符，如果第一次找的关键字不是您想要的，可以一直按「n」会往后寻找到您要的关键字为止;* 「?关键字」：先按「?」键，再输入您想寻找的字符，如果第一次找的关键字不是您想要的，可以一直按「n」会往前寻找到您要的关键字为止]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XShell使用]]></title>
    <url>%2F2018%2F12%2F19%2FLinux-XShell%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[简介 Xshell是一款服务器终端模拟软件，用户可以使用Xshell软件在Windows、Mac OS电脑上访问不同系统的服务器主机，让你可以方便对其进行控制管理。 创新的设计和优良的体验，让用户以最高效率对服务器进行管理 功能特色 可以保存多个vps登陆信息，免去每次输入的烦恼 设置命令快捷按钮 通过代理登陆vps 鼠标右键粘贴可将本地粘贴板内容复制到vps Xshell 注册说明 公司名字随便填 注册码 690313-111999-999313 注意事项 安装完成之后键盘输入无反应，解决方法： 1文件--属性--终端--编码 改成Unicode(UTF-8)]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cat和EOF的使用+action用法]]></title>
    <url>%2F2018%2F12%2F19%2FLinux-cat%E5%92%8CEOF%E7%9A%84%E4%BD%BF%E7%94%A8-action%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[简介 cat：用于显示文本文件内容，全部输出 EOF： “end of file”，表示文本结束符 EOF“通常与”&lt;&lt;“结合使用，“&lt;&lt;EOF“表示后续的输入作为子命令或子shell的输入，直到遇到”EOF“，再次返回到主调shell，可将其理解为分界符（delimiter） 当shell看到”&lt;&lt;“知道其后面输入的分界符，当shell再次看到分界符时，两个分界符中间的部分将作为标准输入,其使用形式如下： 12345交互式程序(命令)&lt;&lt;EOFcommand1command2...EOF //最后的”EOF“必须单独占一行，必须顶行写，前面不能用制表符或者空格 cat+EOF的使用 第一种形式和第二种形式没有什么本质的区别，第一种形式将内容直接输出到标准输出（屏幕），而第二种形式将标准输出进行重定向，将本应输出到屏幕的内容重定向到文件 cat&lt;&lt;EOF cat&lt;filename或者cat&gt;&gt;filename&lt;&lt;EOF ==说明==：关于“&gt;”、“&gt;&gt;”、“&lt;”、“&lt;&lt;”等的意思，请自行查看bash的介绍 EOF与-EOF的区别 如果结束分解符EOF前有制表符或者空格，则EOF不会被当做结束分界符，只会继续被当做stdin来输入。 而&lt;&lt;-就是为了解决这一问题: 如果重定向的操作符是&lt;&lt;-，那么分界符（EOF）所在行的开头部分的制表符（Tab）都将被去除 action “” /bin/true 的用法 action是个bash的函数.true命令啥都不做，只设置退出码为0 使用举例：==action “操作成功！” /bin/true== 123456789101112# Run some action. Log its output.action() &#123; local STRING rc STRING=$1 echo -n &quot;$STRING &quot; shift &quot;$@&quot; &amp;&amp; success $&quot;$STRING&quot; || failure $&quot;$STRING&quot; rc=$? echo return $rc&#125;]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux 磁盘分区工具]]></title>
    <url>%2F2018%2F12%2F19%2FLinux-linux-%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[GParted是一款linux下的功能非常强大的分区工具，和windows下的‘分区魔术师’类似，操作和显示上也很相似。GParted可以方便的创建、删除分区，也可以调整分区的大小和移动分区的位置。GParted支持多种linux下常见的分区格式，包括ext2、ext4、fat、hfs、jfs、reiser4、reiserfs、xfs，甚至ntfs。另外官方还提供了 LiveCD 和 LiveUSB 版本的 GParted，方便在没有主系统的情况下对硬盘进行分区！ GParted可以用于创建、删除、移动分区，调整分区大小，检查、复制分区等操作。可以用于调整分区已安装新操作系统、备份特定分区到另一块硬盘等。 GParted使用libparted来识别、调整分区表，并有各个文件系统工具来处理分区上的文件系统。这些文件系统工具并不是必须的，但要处理一中文件系统就必须先安装相应的工具。 GParted使用C++写成，使用gtkmm提供GTK+界面。 GParted项目还提供了一个包含GParted和全部文件系统工具的Live CD，也可以制作成Live USB或使用其他介质。这个Live CD系统基于Debian GNU/Linux。其它Linux Live CD版本也大多包含GParted，如Knoppix等。 运行环境：Win2003,WinXP,Win2000,Win9X软件大小：140.3 MB 下载地址： http://centoscn.com/plus/download.php?open=2&amp;id=139&amp;uhash=b720444ddecfffb41999608b]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS修改Root密码]]></title>
    <url>%2F2018%2F12%2F19%2FLinux-%E4%BF%AE%E6%94%B9Root%E5%AF%86%E7%A0%81%2F</url>
    <content type="text"><![CDATA[进入单用户模式 开机按ESC，选择内核后按e，后选择Kernerl再按e，在“&lt;rhgb quiet”后输入空格1或s或S或Single回车，按b键重启进入命令行模式 修改密码：passwd root 重启：init 5]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Vundle管理配置Vim基本插件]]></title>
    <url>%2F2018%2F12%2F19%2FLinux-%E4%BD%BF%E7%94%A8Vundle%E7%AE%A1%E7%90%86%E9%85%8D%E7%BD%AEVim%E5%9F%BA%E6%9C%AC%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[说明 官网：https://github.com/VundleVim/Vundle.vim Vundle是基于Git仓库的插件管理软件。Vundle将插件的安装简化为类似yum软件安装的过程 其特色在于使用git来管理插件,更新方便，支持搜索，一键更新，从此只需要一个vimrc走天下 配置说明 在Github vim-scripts 用户下的repos,只需要写出repos名称 在Github其他用户下的repos, 需要写出”用户名/repos名” 不在Github上的插件，需要写出git全路径 具体步骤： 需要有git环境，CentOS7自带，可通过git命令查看 安装Vundle：git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim 修改.vimrc／vimrc文件，在CentOS7中是vimrc文件，修改前先备份. 将以下内容放置到文件最开头，最小配置如下： 123456789101112set nocompatibl filetype offset rtp+=~/.vim/bundle/Vundle.vimcall vundle#begin()Plugin &apos;VundleVim/Vundle.vim&apos;call vundle#end()filetype plugin indent on 在Plugin之后，添加自己想要安装的插件 4. 插件安装： 12345# 在vim中:PluginInstall# 在终端vim +PluginInstall +qall 命令说明 1234567:PluginList -列举出列表中(.vimrc中)配置的所有插件:PluginInstall -安装列表中全部插件:PluginInstall! -更新列表中全部插件:PluginSearch foo -查找foo插件:PluginSearch! foo -刷新foo插件缓存:PluginClean -清除列表中没有的插件:PluginClean! -清除列表中没有的插件 常用插件说明 rename.vim：在Vim中为文件重命名。 vim-coffee-script：在Vim中舒心 的编写、编译Coffeescript。 vim-mkdir：当你在Vim中新建文件的时候， 自动帮你创建不存在的目录。 vim-surround：快速的删除、修改和添加 括号、引号、XML标签等等。 matchit：用%去在两个对应的字符间跳转。 tComment：快速注释、反注释代码。 emmet-vim：Emmet的Vim版。 tabular：快速对齐。 snipmate.vim：快速的代码片段。 vim-easymotion：在文件中快速定位。 vim-instant-markdown：Vim中对 Markdown文档的实时预览。 NERDTree:一个用于浏览文件系统的树形资源管理外挂,它可以让你像使用Windows档案总管一样在VIM中浏览文件系统并且打开文件或目录 MiniBufExplorer:提供多文件同时编辑功能，并在编辑器上方显示文件的标签 一款状态栏增强插件，可以让你的Vim状态栏非常的美观，同时包括了buffer显示条扩展smart tab line以及集成了一些插件 网络上配置收藏 https://github.com/deepzz0/dotfiles/blob/master/.vimrc 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950if &amp;compatible set nocompatibleendfiletype offset rtp+=~/.vim/bundle/vundle/call vundle#rc()&quot; Let Vundle manage VundleBundle &apos;gmarik/vundle&apos;&quot; Define bundles via Github reposBundle &apos;christoomey/vim-run-interactive&apos;Bundle &apos;croaky/vim-colors-github&apos;Bundle &apos;danro/rename.vim&apos;Bundle &apos;kchmck/vim-coffee-script&apos;Bundle &apos;kien/ctrlp.vim&apos;Bundle &apos;pbrisbin/vim-mkdir&apos;Bundle &apos;scrooloose/syntastic&apos;Bundle &apos;slim-template/vim-slim&apos;Bundle &apos;thoughtbot/vim-rspec&apos;Bundle &apos;tpope/vim-bundler&apos;Bundle &apos;tpope/vim-endwise&apos;Bundle &apos;tpope/vim-fugitive&apos;Bundle &apos;tpope/vim-rails&apos;Bundle &apos;tpope/vim-surround&apos;Bundle &apos;vim-ruby/vim-ruby&apos;Bundle &apos;vim-scripts/ctags.vim&apos;Bundle &apos;vim-scripts/matchit.zip&apos;Bundle &apos;vim-scripts/tComment&apos;Bundle &quot;mattn/emmet-vim&quot;Bundle &quot;scrooloose/nerdtree&quot;Bundle &quot;Lokaltog/vim-powerline&quot;Bundle &quot;godlygeek/tabular&quot;Bundle &quot;msanders/snipmate.vim&quot;Bundle &quot;jelera/vim-javascript-syntax&quot;Bundle &quot;altercation/vim-colors-solarized&quot;Bundle &quot;othree/html5.vim&quot;Bundle &quot;xsbeats/vim-blade&quot;Bundle &quot;Raimondi/delimitMate&quot;Bundle &quot;groenewege/vim-less&quot;Bundle &quot;evanmiller/nginx-vim-syntax&quot;Bundle &quot;Lokaltog/vim-easymotion&quot;Bundle &quot;tomasr/molokai&quot;if filereadable(expand(&quot;~/.vimrc.bundles.local&quot;)) source ~/.vimrc.bundles.localendiffiletype on]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux 配置文件启动顺序]]></title>
    <url>%2F2018%2F12%2F19%2FLinux-01-linux-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%90%AF%E5%8A%A8%E9%A1%BA%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[https://www.cnblogs.com/GO-NO-1/p/9084713.html [toc] 启动顺序概述 当用户打开PC的电源，BIOS开机自检，按BIOS中设置的启动设备(通常是硬盘)启动，接着启动设备上安装的引导程序lilo或grub开始引导 Linux，Linux首先进行内核的引导，接下来执行init程序，init程序调用了rc.sysinit和rc等程序，rc.sysinit和rc 当完成系统初始化和运行服务的任务后，返回init；init启动了mingetty后，打开了终端供用户登录系统，用户登录成功后进入了Shell，这 样就完成了从开机到登录的整个启动过程。 0.BIOS加电自检 首先被启动执行的就是这个BIOS（BasicInput/Output System）程序。访问硬盘先头512Bit的MBR（Master Boot Record） 经BIOS的控制，将MBR中的Boot Record调入内存中。这里就要说说Linux的Boot程序了，Linux的Boot程序有GRUB和LILO，而CentOS默认的Boot程序是GRUB 通过Boot程序，访问硬盘中的Linux内核程序 将内核程序调入内存中 1.内核的引导(核内引导) Red Hat可以使用lilo或grub等引导程序开始引导Linux系统，当引导程序成功完成引导任务后，Linux从它们手中接管了CPU的控制权， 然后CPU就开始执行Linux的核心映象代码，开始了Linux启动过程。 内核程序调用完成后，通过内核访问硬盘中将要用到的其他文件。 内核第一个执行的文件是/sbin/init，而这个文件的设置和定义文件是/etc/inittab这个文件，也就是说/sbin/init按照/etc/inittab的定义来执行下一步的启动 2.运行init init是一个由内核启动的用户级进程。它的进程号是1，从这一点就能看出，init进程是系统所有进程的起点，Linux在完成核内引导以后，就开始运行init程序 init程序需 要读取配置文件/etc/inittab。inittab是一个不可执行的文本文件，它有若干行指令所组成 inittab的格式如下。其中以#开始的行是注释行，除了注释行之外，每一行都有以下格式： 1234567id:runlevel:action:process* id:是指入口标识符，它是一个字符串，对于getty或mingetty等其他login程序项，要求id与tty的编号相同，否则getty程序将不能正常工作。* runlevel: 是init所处于的运行级别的标识，一般使用0－6以及S或s。 - 0、1、6运行级别被系统保留：其中0作为shutdown动作，1作为重启至单用户模 式，6为重启；S和s意义相同，表示单用户模式，且无需inittab文件，因此也不在inittab中出现 - runlevel可以是并列的多个值，以匹配多个运行级别，对大多数action来说，仅当runlevel与当前运行级别匹配成功才会执行* action:描述其后的process的运行方式的。action可取的值包括：initdefault、sysinit、boot、bootwait等* process为具体的执行程序。程序后面可以带参数 加载内核 执行init程序 12345* /etc/rc.d/rc.sysinit #由init执行的第一个脚本 - 主要做在各个运行模式中相同的初始化工作，包括： 调入keymap以及系统字体 启动swapping 设置主机名、设置NIS域名检查(fsck)并mount文件系统打开quota 装载声卡模块设置系统时钟等等* /etc/rc.d/rc $RUNLEVEL #$RUNLEVEL为缺省的运行模式* /etc/rc.d/rc.local #相应级别服务启动之后、在执行该文件(其实也可以把需要执行的命令写到该文件中) * /sbin/mingetty # 等待用户登录 3.系统初始化 在init的配置文件中有这么一行:si::sysinit:/etc/rc.d/rc.sysinit ,它调用执行了/etc/rc.d/rc.sysinit，而rc.sysinit是一个bash shell的脚本，它主要是完成一些系统初始化的工作，rc.sysinit是每一个运行级别都要首先运行的重要脚本。它主要完成的工作有：激活交换分 区，检查磁盘，加载硬件模块以及其它一些需要优先执行任务。 4.启动对应运行级别的守护进程 在rc.sysinit执行后，将返回init继续其它的动作，通常接下来会执行到/etc/rc.d/rc程序。 以运行级别3为例，init将执行配置文件inittab中的以下这行： ==l5:5:wait:/etc/rc.d/rc 5== 12345* 这一行表示以5为参数运行/etc/rc.d/rc，/etc/rc.d/rc是一个Shell脚本，它接受5作为参数，去执行/etc/rc.d /rc5.d/目录下的所有的rc启动脚本* /etc/rc.d/rc5.d/目录中的这些启动脚本实际上都是一些链接文件，而不是真正的rc启动脚本， 真正的rc启动脚本实际上都是放在/etc/rc.d/init.d/目录下* 这些rc启动脚本有着类似的用法，它们一般能接受start、stop、 restart、status等参数* /etc/rc.d/rc5.d/中的rc启动脚本通常是K或S开头的链接文件，对于以以S开头的启动脚本，将以start参数来运行；调用的顺序按xx 从小到大来执行* 如果发现存在相应的脚本也存在K打头的链接，而且已经处于运行态了(以/var/lock/subsys/下的文件作 为标志)，则将首先以stop为参数停止这些已经启动了的守护进程，然后再重新运行 5.建立终端 rc执行完毕后，返回init。这时基本系统环境已经设置好了，各种守护进程也已经启动了。init接下来会打开6个终端，以便用户登录系统 通过按Alt+Fn(n对应1-6)可以在这6个终端中切换。在inittab中的以下6行就是定义了6个终端： 1234561:2345:respawn:/sbin/mingetty tty12:2345:respawn:/sbin/mingetty tty23:2345:respawn:/sbin/mingetty tty34:2345:respawn:/sbin/mingetty tty45:2345:respawn:/sbin/mingetty tty56:2345:respawn:/sbin/mingetty tty6 从 上面可以看出在2、3、4、5的运行级别中都将以respawn方式运行mingetty程序，mingetty程序能打开终端、设置模式。同时它会显示 一个文本登录界面，这个界面就是我们经常看到的登录界面，在这个登录界面中会提示用户输入用户名，而用户输入的用户将作为参数传给login程序来验证用 户的身份。 6.登录系统，启动完成 当我们看到mingetty的登录界面时，我们就可以输入用户名和密码来登录系统了 Linux 的账号验证程序是login，login会接收mingetty传来的用户名作为用户名参数。然后login会对用户名进行分析：如果用户名不是 root，且存在/etc/nologin文件，login将输出nologin文件的内容，然后退出。这通常用来系统维护时防止非root用户登录。 在分析完用户名后，login将搜索/etc/passwd以及/etc/shadow来验证密码以及设置账户的其它信息 对于bash来说，系统首先寻找/etc/profile脚本文件，并执行它；然后如果用户的主目录中存在.bash_profile文件，就执行它 登录时自动运行程序 123用户登录时，bash首先自动执行系统管理员建立的全局登录script ：/etc/profile。然后bash在用户起始目录下按顺序查找三个特殊文件中的一个：/.bash_profile、/.bash_login、 /.profile，但只执行最先找到的一个。因此，只需根据实际需要在上述文件中加入命令就可以实现用户登录时自动运行某些程序（类似于DOS下的Autoexec.bat） 退出登录时自动运行程序 12退出登录时，bash自动执行个人的退出登录脚本/.bash_logout。例如，在/.bash_logout中加入命令&quot;tar －cvzf c.source.tgz ＊.c&quot;，则在每次退出登录时自动执行 &quot;tar&quot; 命令备份 ＊.c 文件。 rc.d目录 执行==ls -l /etc/rc.d==命令，会有刚提到的目录，说明如下： init.d 这个不是文件，是一个目录，这个目录下面存放着各各服务的控制脚本，这下面的文件和你安装了些什么软件包有关系。 etc/rc.d/rcX.d下的文件和这个init.d下面的文件是通过软连接相连的 rc rc.loca 可以将启动命令写到这个文件中，让开机启动服务完毕之后，==最后==启动这个服务 rc.sysini 这个文件是在boot的时候就被执行的脚本，它的任务是初始化系统的网络，设定hostname，欢迎信息表示，时钟设置，挂载文件系统等。 rcX.d 在察看这个文件的时候注意3点： ls -l 察看它们的详细信息，看看他们的link指向 ls -l 察看它们的文件名的头字母，形式应该是这样的[S或K &lt;数字&gt; &lt;名称&gt;]的形势。==S代表启动==，==K代表停止==。 即：开机的时候，以S开头的脚本文件别执行，已被开机运行；以K开头的文件不被执行，这个文件所控制的服务也不被执行，这个文件控制的服务也不被开机运行 打开link指向的文件，文件头有类似“# chkconfig: 2345 10 90”一行，这一行就指定了其启动和的优先级 控制服务的一些工具 chkconfig setup 是系统综合的配置工具，命令行下也可以用 system-config-services 如果你安装了gnome这样的窗口桌面系统，你也可以使用这个工具来体验下鼠标点击带来的方便。 Linux设置服务自启动的三种方式 ln -s ln -s 在/etc/rc.d/rc*.d目录中建立/etc/init.d/服务的软链接(*代表0～6七个运行级别之一） etc/rc[06].d其实是/etc/rc.d/rc[06].d的软连接，主要是为了保持和Unix的兼容性才做此策 例如：etc/rc[06].d其实是/etc/rc.d/rc[06].d的软连接，主要是为了保持和Unix的兼容性才做此策 文件位于/etc/rc.d/init.d下,名为apached，如果要服务自启动，则： #chmod +x /etc/rc.d/init.d/apached //设置文件的属性为可执行 #ln -s /etc/rc.d/init.d/apached /etc/rc3.d/S90apache //建立软连接,快捷方式 #ln -s /etc/rc.d/init.d/apached /etc/rc0.d/K20apache chkonfig 命令行运行级别设置 如果需要自启动某些服务，只需使用chkconfig 服务名 on即可，若想关闭，将on改为off 在默认情况下，chkconfig会自启动2345这四个级别，如果想自定义可以加上–level选项 ntsysv 伪图形运行级别设置 启动ntsysv有两种方式，一是直接在命令行中输入ntsysv，二是使用setup命令，然后选择系统服务 常见的守护进程 在每个运行级中将运行哪些守护进程，用户可以通过chkconfig或setup中的&quot;System Services&quot;来自行设定. 常见的守护进程: 123456789101112131415amd：自动安装NFS守护进程apmd:高级电源管理守护进程arpwatch：记录日志并构建一个在LAN接口上看到的以太网地址和IP地址对数据库autofs：自动安装管理进程automount，与NFS相关，依赖于NIScrond：Linux下的计划任务的守护进程named：DNS服务器netfs：安装NFS、Samba和NetWare网络文件系统network：激活已配置网络接口的脚本程序nfs：打开NFS服务portmap：RPC portmap管理器，它管理基于RPC服务的连接sendmail：邮件服务器sendmailsmb：Samba文件共享/打印服务syslog：一个让系统引导时起动syslog和klogd系统日志守候进程的脚本xfs：X Window字型服务器，为本地和远程X服务器提供字型集Xinetd：支持多种网络服务的核心守护进程，可以管理wuftp、sshd、telnet等服务]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle]]></title>
    <url>%2F2018%2F12%2F12%2F%E6%95%B0%E6%8D%AE%E5%BA%93-2018-12-12-oracle%2F</url>
    <content type="text"><![CDATA[官网：https://www.oracle.com/index.html 版本中字母的含义：c（cloud）、g（grid）、i（internet） 下载：https://www.oracle.com/downloads/，需要登录oracle官网，下载的两个文件解压在一个文件夹中 安装： 安装Oracle11g出现INS-13001环境不满足最低要求 https://blog.csdn.net/q_sea__/article/details/79012808 Environment variable: “PATH” 安装时确保不要关机或断电；安装过程中复制文件过程比较耗费时间 完整的Oracle数据库通常由两部分组成：Oracle数据库和数据库实例。 数据库是一系列物理文件的集合（数据文件，控制文件，联机日志，参数文件等）； Oracle数据库实例则是一组Oracle后台进程/线程以及在服务器分配的共享内存区。 在启动Oracle数据库服务器时，实际上是在服务器的内存中创建一个Oracle实例（即在服务器内存中分配共享内存并创建相关的后台内存），然后由这个Oracle数据库实例来访问和控制磁盘中的数据文件。Oracle有一个很大的内存快，称为全局区（SGA）。 数据库的创建与监听器的配置54C 创建数据库:Database Conguration Assistant,可以创建、配置、删除、管理数据库 全局数据库名称为数据库名称，其至少要有一个Oracle实例引用，该实例由SID唯一标识,如：orcl 配置Enterprise Manager会占用较大内存，先不配置;注意选择字符集;修改scott和hr的密码 sys用户为数据库的所有者，system用户为数据库的操作员 监听器的配置：Net Conguration Assistant，配置完成后在系统服务中查看添加了OracleOraDb11g_home1TNSListener,此服务启动之后就允许外部连接数据库了 OracleServiceORCL是关于数据库实例的服务，此服务启动之后，数据库才可用 oracle常用数据库工具 Oracle Universal Installer：OUI（Oracle全局安装器），用来安装卸载oracle数据库管理系统 Database Conguration Assistant：(DBCA)创建、配置、删除、管理数据库 Net Conguration Assistant：(NCA)监听器、命名方法、本地网络服务名、目录使用配置 SQL Plus：基于命令行的oracle官方操作工具 SQL Devloper：基于Java的图形化的oracle官方操作工具,需人工关联sqldeveloper.exe文件和配置JDK PL/SQL Devloper：第三方工具 TOAD：第三方工具 Oracle中的用户、权限与角色 用户管理：需切换到system用户操作 创建用户：create user 用户名 identified by 密码 [account lock|unlock] [password expire];（password expire表示密码立即过期，第一次登录后需修改密码）用户创建后还需授权才能操作数据库 修改用户：alter user 用户名 identified by 密码 [account lock|unlock] [password expire]; 删除用户：drop user 用户名 [cascade];(cascade用来表示删除用户下的所有数据对象) 权限管理：权限为系统中设置的安全规则或安全策略，分为系统权限（用户能否在数据库上完成某个动作）和对象权限（用户能否在某个数据库对象上完成某种操作） 系统权限授予：grant 权限 to user|role [with admin option];(表示可以级联授予) 系统权限回收：revoke 权限 from user|role; 对象权限授予：grant 权限[(col,…)] on 数据库对象 to user|role [with admin option]; 对象权限回收：revoke 权限[(col,…)] on 数据库对象 from user|role; 对象权限的回收是级联的，系统权限回收是非级联的 角色管理：角色是权限的集合，用来简化权限管理 创建／删除角色：create/drop role 角色; 角色上系统权限授予：grant 权限 to role [with admin option];(表示可以级联授予) 角色上系统权限回收：revoke 权限 from 角色; 角色上对象权限授予：grant 权限[(col,…)] on 数据库对象 to role [with admin option]; 角色上对象权限回收：revoke 权限[(col,…)] on 数据库对象 from role; 用户角色授予：grant 角色 to 用户; 用户角色回收：revoke 角色 from 用户; Oracle表：由行和列组成的数据库中基本的存储单元，访问其他用户的表需要加用户名作为前缀 约束：表级别约束和列级别约束，由主键、外键、非空、唯一、检查5种约束 启用表的只读状态便于备份和导出表：alter table 表名 read only;启用表的读写状态：alter table 表名 read write; Oracle事务:有一组DML组成的逻辑工作单元，有原子性、一致性、独立性和持久性 序列sequence：数值生成器，通常用于生成主键值， dual是Oracle提供的最小的工作表，只有一行一列，具有某些特殊功用，只有一条记录:‘X’,习惯上,我们称之为’伪表’,他的存在是为了操作上的方便,因为select都是要有特定对象的. select count(*) from dual; 索引和同义词的使用 索引：通过关联ROWID和关键值来提升查询速度 同义词：数据库对象的别名，public同义词对所有用户有用，创建需一定权限 创建：create [public] synonym 名称 for object; 删除：drop [public] synonym 名称 for object; PL/SQL：是一种程序语言，叫做过程化SQL语言（Procedural Language/SQL）。PL/SQL是Oracle数据库对SQL语句的扩展。在普通SQL语句的使用上增加了编程语言的特点 官网：https://www.oracle.com/technetwork/database/features/plsql/index.html PL/SQL developer官网：https://www.allroundautomations.com/ PLSQL Developer 12 注册码 product code： 4vkjwhfeh3ufnqnmpr9brvcuyujrx3n3le serial Number：226959 password: xs374ca 配置pl/sql的Database的两种方式： 确保OracleOraDb11g_home1TNSListener和OracleServiceXXXX服务已启动 1.登录时直接在Database选项输入数据库信息:在登录时输入数据库信息 ip:端口/数据库名,如：127.0.0.1:1521/ORCL 2.配置product\11.2.0\dbhome_1\NETWORK\ADMIN\tnsnames.ora文件，添加一下内容到文档最后，登录时输入如ORCL即可登录 ORCL = (DESCRIPTION = (ADDRESS_LIST = (ADDRESS = (PROTOCOL = TCP)(HOST = 127.0.0.1)(PORT = 1521)) ) (CONNECT_DATA = (SERVER = DEDICATED) (SERVICE_NAME = ORCL) ) ) https://www.jikexueyuan.com/course/oracledb/ https://www.oracle.com/technetwork/topics/winsoft-085727.html https://www.cnblogs.com/xiashiwendao/p/7634240.html 严格来讲SQL会分为三种类型: 1、数据操纵语言（DML）：用来操纵数据库中数据的命令。包括：select、insert、update、delete。 2、数据定义语言（DDL）：用来建立数据库、数据库对象和定义列的命令。包括：create、alter、drop。 3、数据控制语言（DCL）：用来控制数据库组件 用select * from tab;来查询用户下的表 查看表结构用:DESC 表名称 https://www.cnblogs.com/adforce/p/3312252.html 全局数据库名：就是一个数据库的标识，在安装时就要想好，以后一般不修改，修改起来也麻烦，因为数据库一旦安装，数据库名就写进了控制文件，数据库表，很多地方都会用到这个数据库名。 启动数据库：也叫全局数据库，是数据库系统的入口，它会内置一些高级权限的用户如SYS，SYSTEM等。我们用这些高级权限账号登陆就可以在数据库实例中创建表空间，用户，表了。 查询当前数据库名：select name from v$database; 我们访问Oracle都是访问一个实例，但这个实例如果关联了数据库文件，就是可以访问的，如果没有，就会得到实例不可用的错误。 实例名指的是用于响应某个数据库操作的数据库管理系统的名称。她同时也叫SID。实例名是由参数instance_name决定的 查询当前数据库实例名：select instance_name from v$instance; 从oracle9i版本开始，引入了一个新的参数，即数据库服务名。数据库的逻辑表示，它是数据库呈现给客户机的方式。参数名是SERVICE_NAME。如果数据库有域名，则数据库服务名就是全局数据库名；否则，数据库服务名与数据库名相同。 网络服务名(NET SERVICES NAME) 它是“连接描述符”简称，连接描述符是网络连接目标特殊格式的描述，它包括网络协议、主机名称或地址、和目标服务 在Oracle7和Oracle8版本,目标服务由Oracle系统标识符(SID)来标识，而Oracle8i、Oracle9i则通过数据库服务名来来标识。保存tnsnames.ora文件中在格式如下： myDB = (DESCRIPTION = (ADDRESS_LIST = (ADDRESS = (PROTOCOL = TCP)(HOST = 10.10.10.1)(PORT = 1521)) ) (CONNECT_DATA = (SERVICE_NAME = testDB.ChinaMobile.com) ) ) 若要向ORACLE代理商购买ORACLE，是以用户数来算钱的。那么，这个“用户”跟我们在ORACLE中通过 CREATE USER USERNAME IDENTIFIED BY PASSWORD创建的用户是不同概念，“用户数”指的是并发访问用户数， （我理解是同时间访问同一个内存地址的进程数）。要是我买了8个用户的，可以建几十、上百个用户也没问题，只要峰值达不到并发数就可以了。 打个比方，你的名字叫小明，但是你有很多外号。你父母叫你小明，但是朋友都叫你的外号。 这里你的父母就是oracle实例，小明就是sid，service name就是你的外号。 sid用于实例区分各个数据库，service name用于外部链接。 一个Oracle Server由一个Oracle实例和一个Oracle数据库组成。 即：Oracle Server = Oracle Instance + Oracle Database Oracle实例包括了内存结构(SGA)和一系列后台进程(Background Process),两者合起来称为一个Oracle实例，即：Oracle Instance = SGA + Background Process 数据库逻辑组织结构 表空间、段、区、块 一个数据库由一个或多个表空间组成，一个表空间只能属于一个数据库 一个表空间由一个或多个多个数据文件组成，一个数据文件只能属于一个表空间 一个数据文件由一个或多个操作系统块组成，每一个操作系统块只能数以一个数据文件 一个表空间可以包含一个或多个段，一个段只能属于一个表空间 一个段由一个或多个区组成，每一个区只能属于一个段 一个区由一个或多个Oracle 块组成，每一个Oracle块只能属于一个区 一个区只能属于一个数据文件，数据文件的空间可以分配到一个或多个区 一个Oracle 块由一个或多个操作系统块组成，一个操作系统块是一个Oracle块的一部分 https://blog.csdn.net/prince_lintb/article/details/78772999 pl/sql plus： &quot;／&quot;表示执行 scott库：https://www.2cto.com/database/201805/742911.html https://www.cnblogs.com/adforce/p/3312252.html http://www.cnblogs.com/kscnchina/p/4570865.html 声明时，变量以v_开头，常量以c_开头 https://blog.csdn.net/michaelehome/article/details/79464214 select userenv(‘language’) from dual; NLS_LANG=“AMERICAN_AMERICA.AL32UTF8” 字符集：https://www.cnblogs.com/kaishirenshi/p/9018343.html 本地动态sql SQL环境 begin … end pl/sql环境 一组SQL语句操作要成为事务，数据库管理系统必须保证这组操作的原子性（Atomicity）、一致性（consistency）、隔离性（Isolation）和持久性（Durability），这就是ACID特性。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDB]]></title>
    <url>%2F2018%2F12%2F10%2F%E6%95%B0%E6%8D%AE%E5%BA%93-2018-12-10-MongoDB%2F</url>
    <content type="text"><![CDATA[https://www.jikexueyuan.com/course/mongoDB/ NoSQL数据库：NoSQL(NoSQL = Not Only SQL )，意即&quot;不仅仅是SQL&quot;，指的是非关系型的数据库 mongodb官网：https://www.mongodb.com/ https://docs.mongodb.com/manual/ MongoDB是一个基于分布式文件存储的数据库。由C++语言编写。旨在为WEB应用提供可扩展的高性能数据存储解决方案。 MongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。 http://www.runoob.com/mongodb/mongodb-tutorial.html NoSQL保证数据的最终一致性，数据由更新延迟 CAP理论 适用场景：数据缓存；json格式数据存储；高伸缩性场景； MongoDB更多适合大数据量、高并发、弱事务的互联网应用，其内置的水平扩展机制提供了从几百万到十亿级别的数据处理能力，可很好的满足Web2.0和移动互联网应用的s数据存储要求。 MongoDB由C++编写，支持32位（2G限制）和64位应用，是一个基于分布式文件存储的开源数据库系统。 MongoDB3.0特性： 加入WiredTiger存储引擎: 开源的存储引擎；为现代硬件设计：多核CPU，充分利用内存／芯片级缓存；RAM/SSD/HDD；为大数据设计：高性能，低延迟，高并发稳定性 MMAPv1:内存映射存储引擎，为默认引擎 ，提供了Collection锁；无缝迁移MMAP 可插拔引擎API 基于Web的可视化管理工具：Ops Manager MongoDB数据模型 文档：本质上是一种类JSON的BSON格式的数据，可以理解为在JSON基础上添加了一些新的数据类型，包括Date，正则表达式等。 BSON官网：http://bsonspec.org/ BSON是由一组组键值对组成，具有轻量性、可靠性和高效性3个特征。可遍历性是MongoDB将BSON作为数据存储的重要原因 使用文档时需要注意以下事项： MongoDB中写操作的原子性限制在文档级别； 单个文档占用的存储空间不能超过16MB； MongoDB会尽量保持文档被插入时键值对的顺序； 关于文档命名需要注意的事项： _id是系统保留的关键字，他是默认的主键，该值在集合中必须唯一，且不可更改； 键不能包含空字符或\0，这个字符用于表示键的结尾； 不能以$开头且不能包含点号. 键是区分大小写的且不能重复 集合：把一组相关的文档放到一起组成了集合，MongoDB的集合是模式自由的，一个集合里面的文档可以是各式各样的 MogoDB提供了一些特殊的集合：capped collection、system.indexes、system.namespaces等 集合命名需注意： 集合名不能是空字符串； 集合名不能包含空字符串或\0，该字符表示集合名的结尾 集合名不能以&quot;system.&quot;开头，此前缀是系统本身保留的 集合名不能包含$字符，但是可以包含点号. 数据库：多个文档组成集合，多个集合组成数据库。一个MongoDB实例可承载多个数据库，每个数据库有独立的权限，在磁盘上，不同的数据库也可放置到不通目录 数据库命名规则： 不能是空字符串；不能以$开头；不能包含空字符串和点号.;数据库名称区分大小写；建议数据库名全部使用小写；数据库名最长64字节；不要与系统保留数据库名相同 命名空间：把数据库名添加到集合名前面，中间用点号连接，得到集合的完全限定，就是命名空间 因为点号可以出现在集合名字中，如：jike.blog.posts 和 jike.blog.authors，可以将posts和authors看作是blog集合的子集合，blog集合甚至可以不存在 使用子集合的方式，可以是我们更好的组织数据，使数据结构更加清晰明了 MongoDB数据类型 基本数据类型 null：表示空值或者不存在的字段 布尔：true／false 数据类型：32-int,64-int,64-double,注意：JavaScript只支持64位浮点数 字符串类型：使用UTF-8对字符串进行编码 二进制数据：可以保存由任意字节组成的字符串，如：图片、视频等 正则表达式类型：主要用于查询，使用正则表达式作为限定条件 Date类型：是一个64位整数，它代表距Unix epoch：1970-1-1的毫秒数，MongoDB在存储时间是现转换为UTC时间，北京时间=UTC+8小时，MongoDB Shell会根据本地时间 设置显示日期时间 Timestap：32bit Unix epoch + 32bit自增序数，只供MongoDB数据库服务内部使用，用于记录操作的详细时间 ObjectId：由24个16精制字符组成，每个字节存储两位16精制数字，总共需12字节存储空间=4字节时间戳+3字节机器标识+2字节pid+3字节计数器，ObjectId(),getTimestamp(),valueOf() 数组：使用方括号来表示的一组值，数组中可以包含不通数据类型的元素，针对数组，MongoDB提供了许多操作符，如：pop,pop,pop,push,pull,pull,pull,slice,$addToSet等；MongoDB可自动为数组元素建立MultiKey索引 内嵌文档：文档可以作为键的值，这样的文档成为内嵌文档。内嵌文档可以使数据不用保存成扁平结果的键值对，从而使数据组织形式更加自然。 内嵌文档模式VS引用文档模式 子文档比较小或变化不频繁，则使用内嵌文档模式，否则使用引用文档模式 MongoDB自动将_id字段设置为主键 MongoDB Shell：是MongoDB自带的JavaScript Shell，随MongoDB一起发布 =JavaScript V8解释器+MongoDB客户端 help查看帮助 执行脚本 直接执行：mongo [–quiet] script.js 交互执行：load(“script.js”) 执行命令行程序：run(“ls”) .mongorc.js文件，默认会加载 编辑复合变量EDITOR：在.bashrc中添加后source生效 12#EDITOREDITOR=/usr/bin/vim 即可使用editor编辑文档 http://www.runoob.com/mongodb/mongodb-intro.html Mongodb中的Map/reduce主要是用来对数据进行批量处理和聚合操作。 GridFS是MongoDB中的一个内置功能，可以用于存放大量小文件。 MongoDB允许在服务端执行脚本，可以用Javascript编写某个函数，直接在服务端执行，也可以把函数的定义存储在服务端，下次直接调用即可。 MongoDB数据库安装： 下载安装文件解压缩并添加bin目录到环境变量 创建一个data目录，然后在data目录里创建db目录、logs目录 启动服务端 启动客户端：mongo windows下可以将MongoDB做成系统服务 mac 临时添加环境变量：export PATH=/usr/local/mongodb/bin:PATH编辑 /.bashprofile,添加：exportPATH=PATH 编辑~/.bash_profile,添加：export PATH=PATH编辑 /.bashp​rofile,添加：exportPATH=PATH:/usr/local/mongodb4/bin/:$PATH 即可永久添加环境变量 连接MongoDB数据库：./mongo + 服务器IP:端口号/数据库名 关闭MongoDB服务在 ./mongo 进入控制台后，输入 use admin,然后输入 db.shutdownServer() Mongodb可以通过命令行方式和配置文件的方式来启动： 这两种方式都是在前台启动Mongodb进程，如果Session窗口关闭，Mongodb进程也随之停止。 不过Mongodb同时还提供了一种后台Daemon方式启动，只需要加上一个&quot;–fork&quot;参数即可，用到了&quot;–fork&quot;参数就必须启用&quot;–logpath&quot;参数 通过命令行： ./bin/mongod --dbpath=/data/db --fork --logpath=/data/logs/mongodb.log 配置文件方式：./bin/mongod -f mongodb.conf 或 ./bin/mongod --config mongodb.conf //-f 后面写要使用的配置文件 ./bin/mongod --shutdown -f mongod.conf 1234port=27017dbpath=/usr/local/mongodb/data/logpath=/usr/local/mongodb/log/mongodb.log fork = true 命令行操作： use mytetDB //数据库如果不存在则创建 save时如果给定了_ObjectId则更新创建整条记录；如果要更新部分字段则使用update方法使用$set db.dropDatabase() db//显示当前数据库 show dbs show collections 有一些数据库名是保留的，可以直接访问这些有特殊作用的数据库。 admin： 从权限的角度来看，这是&quot;root&quot;数据库。要是将一个用户添加到这个数据库，这个用户自动继承所有数据库的权限。一些特定的服务器端命令也只能从这个数据库运行，比如列出所有的数据库或者关闭服务器。 local: 这个数据永远不会被复制，可以用来存储限于本地单台服务器的任意集合 config: 当Mongo用于分片设置时，config数据库在内部使用，用于保存分片的相关信息。 MongoDB GridFS文件系统 分布式文件系统：将固定存储于单台机器上的文件系统，扩展到多台机器上，每个节点负责存储部分数据，众多的存储节点组成一个文件系统网络，各个节点通过网络进行通信和数据传输 当存储文档大于16M时，可以考虑使用GridFS GridFS：是MongoDB制定的如何在数据库中存储大文件的规范，MongoDB并没有实现GridFS，而是交由客户端驱动程序实现 GridFS使用两个集合（collection）存储文件。一个集合是chunks, 用于存储文件内容的二进制数据；一个集合是files，用于存储文件的元数据。 使用fs.files存储文件的元数据，包含字段如下： 使用fs.chunks存储以255K进行分割的文件块，包含字段如下： GridFS适用于如下场景： 存储用户产生的文件且文件数量比较大；需要文件的自动备份和分布式存储；需要访问文件的部分内容；存储16MB以上的文件 mongofiles是MongoDB安装包中提供的一个工具，专门用来存取文件，包括查询所有文件、查看文件、上传一个文件、获取一个文件、按照_id来获取文件、按文件名删除文件、按_id删除文件。 mongofiles --help其实有四个主要命令，分别为： put —存储命令 get —获取命令 list —列表命令 delete —删除命令 MongoDB聚合管道：聚合操作主要用户批量数据处理，往往将记录按条件分组，然后在每组上分别进行一系列操作，如：求和、求最大小值等 聚合操作能够对记录进行复杂处理，主要为数理统计和数据挖掘。 MongoDB提供了3种聚合操作方式： 聚合管道（Aggregation Pipeline）:MongoDB Shell使用db.collection.aggregate([{…}])来构建和使用聚合管道 $project:用于修改文档的结构，可以重命名、增加或删除文档字段 match:用于过滤文档，在match:用于过滤文档，在match:用于过滤文档，在match中不能使用$where,尽量出现在管道的前面，方便借助索引加快查询 $group:将集合中的文档进行分组，此分组在内存中进行，最大100M，可通过allowDiskUse启用磁盘交换处理 $sort:将集合中的文档进行排序，此分组在内存中进行，最大100M，可通过allowDiskUse启用磁盘交换处理 $skip:跳过指定数量的文档 $unwind:将文档按照数组字段拆分成多条文档，每条文档包含数组的一个元素 $geoNear:按照由近到远顺序输出接近某一地理位置的文档 out:将聚合结果存储到集合中，参数为集合名称。。。聚合管道表达式：阶段操作符可以看作是&quot;键&quot;，所对应的&quot;值&quot;称为管道表达式，管道表达式可以看作是管道操作符的操作数，管道表达式是一个文档结构，由字段名、字段值和表达式操作符组成。聚合管道使用优化：1将out:将聚合结果存储到集合中，参数为集合名称 。。。 聚合管道表达式：阶段操作符可以看作是&quot;键&quot;，所对应的&quot;值&quot;称为管道表达式，管道表达式可以看作是管道操作符的操作数，管道表达式是一个文档结构，由字段名、字段值和表达式操作符组成。 聚合管道使用优化： 1将out:将聚合结果存储到集合中，参数为集合名称。。。聚合管道表达式：阶段操作符可以看作是&quot;键&quot;，所对应的&quot;值&quot;称为管道表达式，管道表达式可以看作是管道操作符的操作数，管道表达式是一个文档结构，由字段名、字段值和表达式操作符组成。聚合管道使用优化：1将match、$sort放到管道开始阶段，有利于利用索引提高文档处理效率 2提交过滤可减少流经后续阶段的文档数量 聚合管道的限制： 1返回文档结果不能超过16M，可通过返回一个游标或存储到集合中跳过此限制 单目的聚合操作 count distinct group MapReduce编程模型 mongoimport可以导入集合 MongoDB数据更新 文档插入和删除：insert、update、delete Bulk函数：Bulk可将多个数据更新操作放到一个待执行的列表中批量来执行，顺序执行的Bulk（按添加顺序执行，一个有问题则退出）和并执行的Bulk（随机方式并行） 1初始化Bulk： 并行：db.集合名.initializeUnorderedBulkOp() 顺序：db.集合名.initializeOrderedBulkOp() 2 bulk.inset({…}) 3 bulk.execute() MMAPv1的内存分配策略：如果一个更新操作超过了文档在磁盘上预分配的空间，MongoDB会重新在磁盘上为其分配一块更大的连续空间。使用&quot;2的N次方&quot;的方式分配内存，如：32，64，128，256…2M，4M… 优点：1有利用内存的重用，降低系统碎片的数量；2减少数据移动频率，提高系统数据写效率 文档修改 WriteResult = db.集合名.update(query,obj,upsert,multi) query:查询条件，相当于where obj：更改的内容，相当于SQL中的set语句 upsert：当query的文档不存在时是否插入一条新文档 multi：当query返回多个文档时是否一次更新满足条件的所有文档，默认只更新一条 内嵌文档的修改： 修改整个内嵌文档：{$set:{field1:新内嵌文档}} 修改内嵌文档的某个字段：{$某个修改操作符:{field1.field2:value}} 数组元素：MongoDB提供了大量的特定操作符，使得数组既可以作为栈、队列等有序对象使用，也可当作集合等无序对象来使用 MongoDB的写安全机制 写过程：使用update、save等操作数据集合中数据时，只是修改了数据再内存中的映像，数据更新并没有同步地保存到磁盘上，而且更新内存中数据之前，更新操作会被记录到journal日志文件中， 每隔100ms将内存journal中的日志写到磁盘journal日志文件中 ，每隔60s将内存中修改的数据写会到磁盘上 写入安全级别：写入安全Write Concern是一种客户端设置的，用于控制写入安全级别的机制，通过写入安全机制可提高数据的可靠性。 分为四个级别，分别是： 非确认式写入Unacknowledged：写操作不会返回结果，所以无法知道是否写入成功；但速度快、效率高、无阻塞 确认式写入Acknowledged：写操作必须得到MongoDB服务器的写入确认，如果失败，会返回异常 日志写入Journaled：写操作要等到操作记录存储到Journal日志文件后才返回结果 复制集确认写入Replica Acknowledged：写操作不仅要得到主节点的写入确认，还要得到从节点的写入确认，可以设置写入节点的个数（包含主节点） journal日志相当于oracle中的redo日志文件，用户故障恢复和持久。Journal默认100ms刷新一次，所以最多丢失100ms数据 文件位于journal目录中，只能以追加方式添加数据，文件名以&quot;j._&quot;开头，超过1G会自动创建新的；数据库正常关闭时，数据库服务会自动清空journal目录下所有文件 设置写安全操作级别，其实就是在写操作的性能和可靠性间取一个权衡；使用的写操作级别越高，时间越长，可靠性越高 使用writeConcern函数作为更新函数的一个参数来设置写安全级别,如：db.集合名称.insert({name:“joe”},{writeConcern:{j:true}}),writeConcern函数参数如下： w选项，可选择0，1，2等整数值及&quot;majority&quot;，0-非确认式写入 1-确认式写入（未启用复制集）／主节点确认式写入（启用了复制集），&gt;1只能用于复制集，2-数据至少写到1个从节点后返回，majority 只能用于复制集，表示更新操作用到大多数从节点 j选项，设置为true来使用journaled日志安全级别 wtimeout选项，用于设置超时单位为毫秒 以上选项可组合使用 数据MongoDB数据查询 Cursor = db.集合名称.find(query,fields,limit,skip) query:查询条件，相当于where fields:用于字段映射，语法格式：{field:0}（0表示返回结果不包含此字段）或{field:1}（1表示返回结果不包含此字段），默认包含_id字段,相当于select中后面需要的字段 limit：限制查询结果集的数量，指定查询返回结果的数量上限，也可通过limit()实现 skip:跳过一定数据量的结果，设置第一条返回文档的偏移量，也可通过skip()实现 find查询只能正对一个集合；返回的集合默认是无序的 db.集合名称.findOne()只返回第一条数据 查询操作符 比较查询操作符 逻辑查询操作符 元素查询操作符 $where查询操作符：可以将JavaScript表达式的字符串或JavaScript函数作为查询语句的一部分，在js表达式和函数中，可使用this或obj来引用当前操作的文档，当js表达式或函数返回true时，才会返回当前文档 内嵌文档与数组查询 内嵌文档查询 1查询整个内嵌文档：当内嵌文档的键值对数量和键值对顺序都相同时，才会匹配 2查询文档的某个字段：需要使用.号操作符，如:db.user.find({“address.city”:“BeiJing”}) 数组查询 1查询整个数组：当数组元素内容和数组元素顺序都相同时，才会匹配 2查询数组中的元素（普通元素）： A与位置无关，查询数组中含有某个值的文档，如：db.user.find({score:80}) B与位置有关，按照指定的数组索引查询数组元素的值，如：db.user.find({‘scores.2’:80}) 3查询数组中的数组元素是文档时，查询数组元素有两种情况 A与位置无关，查询数组中满足条件的子文档元素，如：db.user.find(‘scores.成绩’：95) B与位置有关，按照指定的数组索引查询数组子文档，如： db.user.find(‘scores.2.成绩’：95) MongoDB查询结果返回过程：find函数查询结果是以多条文档的形式分批来返回查询结果的，返回的文档会缓存到内存中，Cursor在一批数据回来之后遍历，下一批没来时会自动发起下一批请求，然后继续遍历 MongoDB游标：用来遍历结果集中的数据。 游标的生命周期：创建、使用、销毁 游标可能会返回那些由于体积变大而被移动到集合末尾的文档而重复返回，可通过对查询快照的方式解决此问题，语法为：db.collection.find().snapshot(). 使用快照之后，查询就会在_id索引上来遍历执行，这样就可以保证每个文档只被返回一次，从而保证获取结果的一致性。 模糊查询：查询条件可以使用正则表达式实现模糊查询，支持正则表达式操作符和正则表达式对象两种。 正则表达式操作符：$regex findAndModify函数使用执行分为find和update两步，但可以保证操作的原子性 MongoDB是为分布式存储而设计，_id主键默认使用ObjectId类型的值，比自增方式更适合分布式环境，所以MongoDB默认不支持字段自增长功能 MongoDB索引：数据库索引是对数据表中一列或多列的值进行排序的一种数据结构，使用索引可快速访问数据表中的特定信息。MogonDB索引不仅提高文档查询速度，还有利于排序时节省内存资源。 MongoDB所有的索引信息被保存在system.indexes集合中，且默认总为_id创建单字段升序具有唯一属性的索引，可通过db.system.indexes.find()查看所有索引 MongoDB可在单个字段上建立索引，字段可以是普通字段、整个文档以及子文档的某个字段 对于复合索引，MongoDB支持前缀匹配 为确保查询只使用复合索引，可以使用映射来指定不要返回_id字段（除非它是复合索引的一部分） 多键索引：是对数组类型建立的索引，实际上是对数组的每个元素建立索引，而不是数组本身建立索引；当数组元素是文档时，可为文档的某个字段建立多键索引 哈希索引：只支持等值查询，不支持范围查询，主要用于分片的集合上，可以作为片键来使用，能将数据比较均匀的分散存储在各个分片上，如：db.集合名.createIndex({name:“hashed”}) MongoDB索引的属性 唯一索引:可以确保集合的每一个文档的索引字段都有唯一的值，不会出现重复值，如：db.集合名.createIndex({name:1},{unique:true})，在非空集合创建唯一索引可能会因为已有重复值而失败，可添加dropBups:true删除重复文档 稀疏索引：只会为索引字段存在的文档建立索引，即使索引字段的值为null，但不会为索引字段不存在的文档建立索引 TTL(Time To Live)索引：为文档设置一个超时时间，当达到预设置的时间后，该文档会被数据库自动删除，但删除可能有延迟。这种类型的索引对缓存问题非常有用。只能建立在单独非_id字段 创建了TTL索引后，MongoDB会有一个后台线程来管理文档；在复制集上建立的TTL索引，TTL后台线程只会运行在主节点上 MongoDB索引的管理 索引的默认命名规则：keyname1_dir1_keyname2_dir2…，其中keynameX是索引字段的名称，dirX是索引方向，1升序-1降序，也可自定义命名 创建索引：db.集合名.createIndex(keys,options),返回值为一个文档类型。索引一旦创建就不能修改，创建后可通过db.集合名.getIndexes()查看集合所拥有的索引，创建索引有两种方式： 1foreground:阻塞所有对数据库的读写请求，直到索引创建完成，为默认方式 2background：创建索引时，如果有新的数据库请求，创建过程会暂停 删除索引：db.集合.dropIndex(index) 查询优化器：用来优化查询过程，通过比较返回100条文档速度得到最佳查询计划 explain函数：能够提供大量与查询有关的信息，可以很好的评估索引性能，帮助优化索引的使用策略。db.集合.find().explain(mode),支持3种模式： 1queryPlanner：查询计划，默认 2executionStatus：查询性能统计 3allPlansExecution：所有计划统计信息（最优与被拒绝的计划） explain返回结果使用由多个阶段（Stage）组成的树形结构来表示查询计划，查询计划自下而上执行，树的叶节点用来访问文档或索引，内部节点处理下层节点返回文档或索引，根节点输出查询结果 hint函数：强制MongoDB使用特定索引 MongoDB特殊索引 地理空间索引：对地理位置数据建立索引，MongoDB支持两种2dsphere球面索引和平面2d索引 2dSphere球面索引 2d平面索引 全文索引：又称为倒排索引，用于在大量文本中对每一个词组建立索引，指出该词在整段文本中出现的位置和次数，此技术主要用于搜索引擎和站内搜索等。 一个集合只能有一个全文索引 java对mongodb的使用 集群搭建：mongodb分布式集群搭建手记 学习：http://www.cnblogs.com/huangxincheng/archive/2012/02/18/2356595.html 分析没有默认的，因为你还没给root设置密码，第一个 user 是在 admin 组 ，所以他可以给 root 设置密码 , so sudo passwd root Language Support http://blog.csdn.net/sinat_35418761/article/details/53241481 http://www.2cto.com/database/201504/395442.html http://www.myexception.cn/operating-system/1685604.html https://my.oschina.net/chinacaptain/blog/465723 http://api.mongodb.com/java/current/ MongoDB是什么 MongoDB是一个基于分布式文件存储的数据库。由C++语言编写。旨在为WEB应用提供可扩展的高性能数据存储解决方案。 他的特点:高性能、易部署、易使用，存储数据非常方便。 Bson：Binary Serialized Document Format，是一种类json的一种二进制形式的存储格式，简称Binary JSON，它和JSON一样，支持内嵌的文档对象和数组对象，但是BSON有JSON没有的一些数据类型，如Date和BinData类型]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis]]></title>
    <url>%2F2018%2F12%2F10%2FJava-2018-12-10-MyBatis%2F</url>
    <content type="text"><![CDATA[Java持久化框架 瞬态+持久态 iBatis-MyBatis apache-google-github SQL语句与代码分离；面向配置编程；良好支持复杂数据映射；动态SQL https://github.com/mybatis/mybatis-3 http://www.mybatis.org/mybatis-3/zh/index.html 日志配置 https://www.cnblogs.com/zhaozihan/p/6371133.html MyBatisg工作流程 读取配置文件 生成SqlSessionFactory,表示和数据库的连接，一般是程序级的生命周期 简历SqlSession 调用MyBatist提供的API 查询Map配置 返回结果 关闭SqlSession 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=&quot;org/mybatis/example/BlogMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; map文件引用 1.相对路径 2.绝对路径 3.包路径 MyBatis配置文件：基本配置文件+映射配置文件 typeAliases标记定义别名，需要environments标记之前 map文件方式+注解方式（接口方式） mappers里面3种写法：resource／class／package Select配置属性说明 两者只能有一个成立 resultType resultMap解决复杂查询时的映射问题，如属性为对象 parameterType封装hashmap，key既是key也是sql形参 parameterType封装对象如User，对象参数自动匹配属性，如果对象属性和列名不一样用别名 返回多上记录时MyBatis自动封装成List 事务处理： MyBatis事务处理由两种方式处理：JDBC+MANAGED 每张表单独的一个配置文件，方便管理 MyBatis自动id返回， 123one.setUserName(&quot;123&quot;);session.insert(&quot;insertOne&quot;,one);System.out.println(one.id); //可以正常获取id 高级查询 关联查询 联合查询：association 构造查询：POJO添加构造函数，同时确保要有默认构造函数，防止构造函数重新后找不到默认构造函数 子查询：所有联合查询，都可以通过子查询替换，但是他让查询成了N+1次的查询 子查询和联合查询的区别： 联合查询一次查询占用资源大，子查询N+1次查询占用资源可大可小，MyBatis中子查询可能速度比联合查询速度高如果开启了懒加载的话 懒加载的使用：配置要在配置别名之前 集合查询：Collection标记，适用于查询的对象还有一个集合引用的事后 鉴别器：discriminator标记 javaType属性： Column属性： Case子标记： MyBatis动态SQL：动态生成SQL https://www.aliyun.com/jiaocheng/811373.html https://www.jikexueyuan.com/course/oracledb/1-0-0-0/]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin]]></title>
    <url>%2F2018%2F11%2F26%2FJava-2018-11-26-Kotlin%2F</url>
    <content type="text"><![CDATA[http://kotlinlang.org/ https://try.kotlinlang.org/#/Examples/Hello, world!/Simplest version/Simplest version.kt Kotlin作者Andrey Kotlin是一种在 Java 虚拟机上运行的静态类型编程语言,被称之为 Android 世界的Swift,由 JetBrains 设计开发并开源 Kotlin是一种运行在Java虚拟机、Android、浏览器上的静态语言 Kotlin可以编译成Java字节码，也可以编译成 JavaScript，方便在没有 JVM 的设备上运行。 Android官方语言；100%兼容Java；Kotlin-js前端开发；Kotlin-jvm服务端开发；Kotlin-native本地执行程序；Kotlin是一门全栈语言 千里之行，始于Hello World Kotlin不存在拆箱装箱问题;Kotlin不可隐式转换类型 var tmp:[类型]=[变量值] Boolean类型 Number数据类型：Byte，Short，Int，Long，Float，Double Char数据类型：Char String数据类型：String 字符串a==b 比较内容；a===b比较应用 字符串模版$args1 args1+args2,引号中{args1+args2},引号中args1+args2,引号中引用变量 ，多行 var a:String … a1 a2 … Kotlin中 Any 等于 Java中 Object，是顶级类 空类型：任意类型都有可空和不可空两种状态，？表示可为空，!!表示强制认定nullable不可为空 fun main(args:Array){ var name:String = getName() ?: return println(name) var tmp:String? = &quot;Hello Kotlin&quot; println(tmp) println(tmp!!.length) } fun getName():String?{ return null } 智能类型转换 Java方式的：var sub:Subclass = parent as Subclass //类似于Java方式，转换异常则会抛异常 安全类型转换：var sub:Subclass? = parent as? Subclass //如果转换失败，则返回null，不抛异常 if(parent is Subclass) import com.test as test 区间Range:一个数学上的概念，表示范围；是ClosedRange的子类，IntRange最常用；i in 0…1024 判断i是否在区间内 var range:IntRange = 0…1024 //[0,1024] var range:IntRange = 0 until 1024 //[0,1024) == [0,1023] className::java.class.name className::java.class.simpleName 数组: val array:Array&lt;&gt; = arrayOf(…) 为了避免不必要的拆箱和装箱，基本类型的数组是定制的 val arrayOfInt:IntArray = intArrayOf(1,2,4) val arrayOfChar:CharArray = charArrayOf(‘H’,‘e’,‘y’) val arrayOfString: Array = arrayOf(“Hello”,“Kotlin”) val arrayOfOther:Array = arrayOf(Other(1),Other(2)) 常量：val，常量因为赋值了，编译器可以推导出来类型，所以类型可以不用写，变量：var External Tools Tools-&gt;Kotlin-&gt;Show Kotlin Bytecode 函数：Kotlin中没有申明返回值的默认返回值是Unit kotlinc安装，使用和javac一样 变量函数 var int2Long = fun(x:Int):Long{ return x.toLong() } int2Long(123) fun sum(arg1:Int,arg2:Int) = arg1+arg2 Lambda表达式调用使用()或者invoke(),如：sum(1,2) 或 sum.invoke(1,2) Lambda表达式–匿名函数 var = {arg1:Int,arg2:Int -&gt; arg1+arg2} arrayOfString.forEach { println(it) } //如果字面函数只有一个参数,可以省略该参数声明,并用“it”代替 arrayOfString.forEach(::println) Lambda表达式中的return https://www.jianshu.com/p/92cd94cba709?utm_source=oschina-app public inline fun Array.forEach(action: (T) -&gt; Unit): Unit { for (element in this) action(element) } indexes.forEach { if (it &gt; 5) { return@forEach } println(it) } indexes.forEach label@ { if (it &gt; 5) { return @label } println(it) } 函数参数调用时最后一个Lambda可以移出去 函数参数只有一个Lambda，调用时小括号可以省略 Lambda有一个参数，可默认为it 入参、返回值与形参一致的函数可以用函数引用的方式作为实参传入 类成员方法和成员变量 class B class A{ var b=0; lateinit var c:String val d:B by lazy{ B() } } 属性初始化 尽量在构造方法中完成 无法在构造方法中完成的，尝试降级为局部变量 var用lateinit延迟初始化，val用lazy 可空类型慎用null直接初始化 中缀表达式：只有一个参数，且用infix修饰的函数 class Book {infix fun on(placeString:String){…}} Book() on “My Desk” //使用方式 分支表达式： val mode=if(args.isNotEmpty() &amp;&amp; args[0] ==1){ 0 }else{ 1 } 异常捕捉 try …catch …finally中的执行完之后，再返回结果，可通过var获取返回值 具名参数：sum(arg1=2,arg0=3) //参数就可以不按照顺序传递了 变长参数：如main方法中的args fun test(vararg args:String){} 默认参数：给出参数默认值 导出可执行程序 kotlin应用场景： kotlin-android]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java8 特性]]></title>
    <url>%2F2018%2F11%2F26%2FJava-Java8-%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[[toc] SAM接口 Java8中增加了一个新的包：java.util.function，它里面包含了常用的函数式接口 123456Predicate&lt;T&gt;——接收T对象并返回booleanConsumer&lt;T&gt;——接收T对象，不返回值Function&lt;T, R&gt;——接收T对象，返回R对象Supplier&lt;T&gt;——提供T对象（例如工厂），不接收值UnaryOperator&lt;T&gt;——接收T对象，返回T对象BinaryOperator&lt;T&gt;——接收两个T对象，返回T对象 lambda表达式 参考：http://note.youdao.com/noteshare?id=3bc7675e64b86f5e9b75534c0e436694 方法引用和构造器引用 方法引用 12345objectName::instanceMethodClassName::staticMethodClassName::instanceMethod 前两种方式类似，等同于把lambda表达式的参数直接当成instanceMethod|staticMethod的参数来调用 最后一种方式，等同于把lambda表达式的第一个参数当成instanceMethod的目标对象，其他剩余参数当成该方法的参数 构造器引用 构造器引用语法如下：ClassName::new，把lambda表达式的参数当成ClassName构造器的参数 。例如BigDecimal::new等同于x-&gt;new BigDecimal(x) Stream语法 stream就是JAVA8提供给我们的对于元素集合统一、快速、并行操作的一种方式。 它能充分运用多核的优势，以及配合lambda表达式、链式结构对集合等进行许多有用的操作 Stream是元素的集合，这点让Stream看起来用些类似Iterator,可以把Stream当成一个装饰后的Iterator； 可以支持顺序和并行的对原Stream进行汇聚的操作； 12List&lt;Integer&gt; nums = Lists.newArrayList(1,null,3,4,null,6);nums.stream().filter(num -&gt; num != null).count();]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot]]></title>
    <url>%2F2018%2F11%2F26%2FJava-2018-11-26-SpringBoot%2F</url>
    <content type="text"><![CDATA[http://spring.io/ https://www.imooc.com/video/16358 英文文档：https://docs.spring.io/spring-boot/docs/current/reference/ Spring Framework是一种JavaEE的框架 Spring Boot是一种快速构建的Spring应用 Spring Cloud是构建SpringBoot的分布式应用 SpringBoot2.0 编程语言：Java 8+，Kotlin，底层框架：SpringFramework 5.0.X,支持Web Flux Web Flux 支持函数编程，Java 8 Lambda 响应式编程,Reactive Streams 异步编程，Servlet3.1和Asyc NIO InteliJ中配置Java和Maven 构建项目： 图形化方式 1 http://start.spring.io/ ，输入选择Reactive Web 2 导入项目 命令行方式（Maven） mvn archetype:generate -DinteractiveMode=false -DgroupId=com.test -DartifactId=first-app-by-maven -Dversion=1.0.0-SNAPSHOT 添加 org.springframework.boot spring-boot-starter-parent 1.5.9.RELEASE org.springframework.boot spring-boot-starter-web 取消Junit的版本，需要4.1.2以上，取掉之后spring-boot-starter-parent继承版本 父Module的packaging设置为pom 打包方式 Jar包方式 War包方式 指定Main-class方式 org.springframework.boot spring-boot-maven-plugin 1.5.4.RELEASE ${start-class} ZIP repackage https://docs.spring.io/spring-boot/docs/current/reference/html/build-tool-plugins-maven-plugin.html jar包形式 mvn -Dmaven.test.skip -U clean package java -jar [jar名称.jar] war包形式，需要有webapp-&gt;WEB-INF-&gt;web.xml java -jar [war名称.war] 运行模式 IDEA方式 Jar／War方式 Maven插件方式： mvn srping-boot:run//需要在Main方法module，使用前，需要在父Module mvn -Dmaven.test.skip -U clean install https://blog.csdn.net/taiyangdao/article/details/75303181 ConcurrentHashMap http://www.importnew.com/28263.html https://www.cnblogs.com/heyonggang/p/9112731.html AtomicInteger https://www.cnblogs.com/sharkli/p/5623524.html 好的习惯，实体都实现toString()方法 Flux &amp; Mono Flux：0到N个对象的集合 Mono：0到1个对象的集合 Reactive中的Flux和Mono是异步处理的，都是Publisher https://www.imooc.com/learn/1058 组件自动装配：规约大于配置，专注核心业务 外部化部署：一次构建、按需调配，到处运行 嵌入式容器：内置容器、无需部署、独立运行 SpringBoot Starter:简化依赖、按需装配、自我包含 Production-Ready：一站式运维、生态无缝整合 Java 能长盛不衰，主要是命好。每当人们觉得 Java 不行了的时候，总会有英雄横刀救美。 最初 Java 开发出来不知道有什么用的时候，发现可以用 Applet 在网页上做动画。后来企业级软件开发时代 JavaEE 大行其道，开源社区 Spring 桃李满天下。 等到了移动时代，人们觉得 Java 要完蛋了，Google 拍马救市，收购并开放了 Android 平台，当家语言就是 Java，于是 Java 再次焕发勃勃生机。 目前大数据领域，Java 同样是当仁不让的好手。 现在 Spring Framework 那套东西使用了十几年，正当大家被长达几千行的 ApplicationContext 配置文件折磨的死去活来的时候，Spring Boot 诞生了。什么是 Spring Boot？用来简化 Spring 应用程序开发的。 换句话说就是，当你觉得 Java 不好用的时候，我做了个轻量级的 S，让你好好用 Java。等你觉的 S 也不够轻了，我做了个 SB，让你觉得 S 还是挺轻的。 https://www.imooc.com/video/16783 SrpingBoot为微服务框架，与Spring4一起诞生 https://docs.spring.io/spring-boot/docs/2.1.2.RELEASE/reference/htmlsingle/]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NuGet]]></title>
    <url>%2F2018%2F11%2F02%2FC-%E5%BC%80%E5%8F%91-2018-11-02-NuGet%2F</url>
    <content type="text"><![CDATA[https://www.cnblogs.com/nizhenghua/p/6422078.html]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NW.js入门]]></title>
    <url>%2F2018%2F10%2F26%2Fnode-NW-js%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[[toc] 简介 NW.js （原名 node-webkit）是一个基于 Chromium 和 node.js 的应用运行时，通过它可以用 HTML 和 JavaScript 编写原生应用程序。它还允许您从 DOM 调用 Node.js 的模块 ，实现了一个用所有 Web 技术来写原生应用程序的新的开发模式。 官网：https://nwjs.io/ 中文文档：https://www.gitbook.com/book/wizardforcel/nwjs-doc/details 功能特性 用现代 HTML5,CSS3,JS 和 WebGL 来编写应用程序 完全支持 Node.js APIs 和所有其 第三方模块 良好的性能:Node 和 WebKit 运行在相同的线程:函数调用是更简洁;对象在同一堆可以互相引用 容易打包和分发应用程序 支持 Linux、Mac OS X 和 Windows 窗口外观常用属性 在package.json文件中设置 123456789101112title : 字符串，设置默认 title。width/height : 主窗口的大小。toolbar : bool 值。是否显示导航栏。icon : 窗口的 icon。position :字符串。窗口打开时的位置，可以设置为“null”、“center”或者“mouse”。min_width/min_height : 窗口的最小值。max_width/max_height : 窗口显示的最大值。resizable : bool 值。是否允许调整窗口大小。always-on-top : bool 值。窗口置顶。fullscreen : bool 值。是否全屏显示。show_in_taskbar : 是否在任务栏显示图标。frame : bool 值。如果设置为 false，程序将无边框显示。 webstorm项目创建及调试 下载三个不同 OS 平台的 NW.js 创建项目并运行 创建空项目 创建package.json,编辑起内容，最简为: 12345&#123; &quot;name&quot;: &quot;helloworld&quot;, &quot;version&quot;: &quot;0.0.1&quot;, &quot;main&quot;: &quot;index.html&quot; &#125; 在webstorm 中添加一个nw.js：run – edit configurations – + nw.js 123NW.js app : 可以是当前项目目录，但要包含package.json文件. 或者是一个.nw的文件NW.js interpreter 指定可执行的 nw(官网下的包中的) (mac下是nwjs),如：/MyDeveloper/nwjs-v0.22.1-osx-x64/nwjs.appworking direction ： 项目目录 运行查看效果 调试 https://www.jetbrains.com/help/webstorm/2017.1/run-debug-configuration-node-webkit.html 打包到各个平台 https://github.com/nwjs/nw.js/wiki/how-to-package-and-distribute-your-apps mac下打包 拷贝下载的nwjs-sdk-v0.22.1-osx-x64.zip中的nwjs.app文件到项目的根目录的同级目录 修改nwjs.app目录名称为你想要的名称，如：MyNW.app 在项目根目录执行如下命令：zip -r …/MyNW.app/Contents/Resources/app.nw *,将当前目录下所有文件打包到MyNW.app中 open MyNW.app可以打开项目 制作成dmg文件 在应用程序-&gt;实用工具下打开磁盘工具 新建一个磁盘映像，放在桌面上(可随意)，名称设置为temp.dmg(可随意)，存储为mytemp 拷贝4中的文件到mytemp中 执行：ln -s /Applications /Volumes/temp.dmg/Applications 成功 问题：4中制作的文件太大 代码加密保护 有些情况下，代码还是不能直接暴露给用户的；我们可以使用V8 Snapshot 的方式来达到代码加密保护的目的 具体的方式是: 使用 /nwjs.exe 来运行 nwjc source.js core.bin命令 在index.html里使用require(‘nw.gui’).Window.get().evalNWBin(null, ‘./app/v0.0.1/core.bin’);(注意这里的路径，是相对于nw.exe的位置)将代码引入到项目中； 加密的代码里不要使用 let、const这些关键字，可能因为这个始终编译不通过 自动更新 项目代码需要更新 前面介绍项目接口就提到 /app/v0.0.1/ 就是放置V0.0.1的所有代码的位置； 那么如果要更新到V0.0.2，那我们新建一个文件夹 /app/V0.0.2,然后把V0.0.2的代码都放到这个文件下，然后把/package.json替换成新版本的package.json；这样重启客户端之后，然会读取v0.0.2的代码了。具体的更新代码就不写了，可以把新版本的代码打包成zip包，然后客户端下载好，解压就行。 nw.js本身需要更新 通常情况下，不会遇到需要更新nw.js 本身的情况，因为当选定一个版本的NW.js后，就认定它了，除非遇到了什么无法解决的BUG 系列教程 https://blog.csdn.net/zeping891103/column/info/19257]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>nw</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ant Design of React+dva入门]]></title>
    <url>%2F2018%2F10%2F26%2F%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-Ant-Design-of-React-dva%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[[toc] 简介 是 Ant Design 的 React 实现，开发和服务于企业级后台产品 安装使用Antd npm install antd --save 浏览器引入 在浏览器中使用 script 和 link 标签直接引入文件，并使用全局变量 antd 在 npm 发布包内的 antd/dist 目录下提供了 antd.js antd.css 以及 antd.min.js antd.min.css 也可以通过 CDNJS https://cdnjs.com/libraries/antd 或 UNPKG https://unpkg.com/antd@3.0.2/dist/ 进行下载 强烈不推荐使用已构建文件，这样无法按需加载，而且难以获得底层依赖模块的 bug 快速修复支持 安装使用dva dva 是一个基于 React 和 Redux 的轻量应用框架，概念来自 elm，支持 side effects、热替换、动态加载、react-native、SSR 等，已在生产环境广泛应用。 12345npm install dva-cli -gdva -vdva new dva-quickstartcd dva-quickstartnpm start 在浏览器里打开 http://localhost:8000 ，你会看到 dva 的欢迎界面 dva项目中使用Antd npm install antd babel-plugin-import --save 编辑 .roadhogrc，使 babel-plugin-import 插件生效 按需加载Antd 使用 babel-plugin-import 123456// .babelrc or babel-loader option&#123; &quot;plugins&quot;: [ [&quot;import&quot;, &#123; &quot;libraryName&quot;: &quot;antd&quot;, &quot;libraryDirectory&quot;: &quot;es&quot;, &quot;style&quot;: &quot;css&quot; &#125;] // `style: true` 会加载 less 文件 ]&#125; 然后只需从 antd 引入模块即可，无需单独引入样式。等同于下面手动引入的方式。 // babel-plugin-import 会帮助你加载 JS 和 CSS import { DatePicker } from ‘antd’; 在 create-react-app 中使用 create-react-app 是业界最优秀的 React 应用开发工具之一 使用create-react-app只是创建出了react应用的基本架构，类似于dva-cli创建的架构，antd还是需要自己添加 dva的出现背景 https://github.com/sorrycc/blog/issues/1]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>dva</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ECMAScript规范]]></title>
    <url>%2F2018%2F10%2F26%2F%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-2018-10-26-ECMAScript%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[ECMAScript 6（简称ES6）是JavaScript语言的下一代标准，于2015年6月正式发布，也称ECMAScript 2015。 12参考资料《ECMAScript 6 入门》： http://es6.ruanyifeng.com/ ECMA是标准，js是实现 [toc] 历史 1996 ES1.0 js稳定，Netscapte将js提交给ECMA组织，ES正式出现 1998 ES2.0 ES2.0正式发布 1999 ES3.0 ES3被浏览器广泛支持 2007 ES4.0 ES4过于激进，被废除了 2008 ES3.1 4.0退化为严重缩水版3.1，代号Harmony（和谐） 2009 ES5.0 ES5正式发布了，公布了JS.next，即后来的ES6.0 2011 ES5.1 ES5.1成为了ISO国际标准 2013.3 ES6.0 制定草案 2013.12 ES6.0 ES6.0草案发布 2015.6 ES6.0 ES6.0预计发布正式版，同时JS.next指向ES7.0 兼容性 目前ES5、ES6支持还可以，凑合；ES5、ES6逐渐沦为后台语言 在浏览器中使用需要用到编译工具，babel／traceur（由google出的编译器，把ES6语法编译成ES5） 使用的三种方式 网页内直接使用 12345&lt;script src=&quot;traceur.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;bootstrap.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;module&quot;&gt; //此出写ES6代码&lt;/script&gt; 直接在线编译（主要用于测试） http://babeljs.io/repl/ https://google.github.io/traceur-compiler/demo/repl.html 直接在node中使用 直接用，需添加‘use strict’ 1234//test.js&apos;use strict&apos;let a=2;console.log(a); node test.js node --harmony_desctructuring test.js 新增功能 定义变量 let let定义的变量只能在代码块中使用，具备块级作用域；var具备函数级作用域； 块级作用域其实就是匿名函数立即调用 变量不能重复定义 可用于封闭空间;封闭空间可解决i问题 以前： (function(i){ var a=12; })(i); 现在： { let a=12; } 定义常量 const 定义后则不能修改 字符串连接 ==反单引号==：==``==,内容模版,==${变量名}填充模版== 解构赋值 var [a,b,c]=[12,5,101];解析结构，给a、b、c都赋值； json格式（通过名称匹配，与顺序无关）也支持 ==模式匹配==：var [a,[b,c],d] =[12,[3,2],101],左侧的样子需要和右侧一样 可==以给默认值==。var {time=12,date} ={data=123} 复制数组 数组赋值为引用赋值，复制以前用for循环🔥 Array.from()函数，现在使用==超引用’…’==, var arr2 = […arr1]; 在函数中通过 …args 接收多个参数 循环 以前是for或for in，现在：for of，支持数组、json、map 1234//i表示数组或者json的值，for in中i是下标，for of中表示key+value，实质是jsonObj.entrys(),类似的还有jsonObj.keys()、jsonObj.values()for(var i of arr)&#123; console.log(i);&#125; map操作 get()\set()\delete() 箭头函数 =&gt; 注意事项 this问题 //this指向了window对象 arguments不能使用，箭头函数没有自己的 arguments 123456function foo() &#123; var f = (...args) =&gt; args[0]; return f(2); &#125;foo(1); // 2 更多：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions 对象语法简洁化 12345678910111213141516171819//以前var person=&#123; name:&apos;abc&apos;, age:100, showName:function()&#123; alert(this.name); //this有问题 &#125;&#125;//ES6var name=&apos;abc&apos;;var age =100;var person=&#123; name, age, showName()&#123; alert(this.name); &#125;&#125; 面向对象 12345678910//以前面向对象function Person(name,age)&#123; //类和构造函数一体 this.name = name; this.age = age;&#125;Person.prototype.showName=function()&#123; return this.name;&#125;var p1 = new Person(&apos;abc&apos;,100);alert(p1.name); 1234567891011121314//ES6面向对象class Person&#123; constructor(name=&apos;defalut&apos;,age=0)&#123; //此处可以设置默认值，这是函数的功能，即：函数参数可以给默认值 this.name = name; this.age = age; &#125; showName()&#123; return this.name; &#125;&#125;var p1 = new Person(&apos;abc&apos;,100);alert(p1.name); alert(p1.showName()); 继承 123456789101112//以前 子类.prototype = new 父类();function Worker(name,age)&#123; Person.apply(this,arguments);&#125;Worker.prototype=new Person();//ES6class Woker extends Person&#123; constructor()&#123; super(); //调用父级构造 &#125;&#125; ES5: this.bind(); 模块化 当前使用模块化必须引入traceur和bootstrap，type必须写成module 123456//定义export default &#123;a,b&#125;//引用import modA from &apos;./a.js&apos;;//使用var sum = modA.a + modA.b Promise 本身为一个对象，用来传递异步操作的数据 整体是链式操作 12pending(等待、处理中) ---&gt; Resolve（完成） ---&gt; Reject (拒绝) 使用 123456var p1 = new Promise(function(resolve,reject)&#123; if(异步处理成功了) resolve(成功数据) else reject(失败原因)&#125;); 包含方法如下： 1234567所有方法都支持链式编程* then(成功(resolve数据),失败（reject数据）) //此方法可以防止异步编程括号深度太多的的问题* catch（function（e）&#123;&#125;）； // 用来捕获错误* all[p1,p2,p3....] //用于将多个promise对象组合／包装成一个全新的promise对象,数组中的Promise又一个错误则按错误流程走，所有都成功则按成功流程走* Promise.race([p1,p2....]).then(function(value)&#123;&#125;); //返回最先执行的Promise的结果* Promise.reject() //生成错误的Promise* Promise.resolve() //生成成功的Promise Generator+yield Generator:生成器，是一个函数，可以遍历 Generator函数名字前有* Generator函数内部使用yield语句 12345678910111213141516171819202122232425//普通函数function show()&#123; &#125;//generator函数function* show()&#123; yield “Hello”； yield &quot;World&quot;;&#125;//generator函数*show()&#123; yield “Hello”； yield &quot;World&quot;;&#125;var res=show();console.log(res.next()); //&#123;value:&quot;Hello&quot;,done:false&#125;console.log(res.next()); //&#123;value:&quot;World&quot;,done:false&#125;console.log(res.next()); //&#123;value:&quot;undefined&quot;,done:true&#125;~~~ * Generator函数调用后的对象有next方法* next方法每次返回一个value和done结果，value位yield后面的值，done代表是否遍历结束* yield语句本身没有返回值或每次返回undefined* next可以带参数，所带参数给了上一个yield* for ...of循环支持Generator函数 for (let v of show()){ document.write(v); } 1234#### 展开运算符 扩展语法允许一个表达式在期望多个参数（用于函数调用）或多个元素（用于数组文本）或多个变量（用于解构赋值）的位置扩展1. 用于函数调用 myFunction(…iterableObj); 12. 用于数组字面量 […iterableObj, 4, 5, 6] ECMA-262文档下载：https://chetaofeng.github.io/pub-images/Ecma-262.pdf]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Antd PRO入门]]></title>
    <url>%2F2018%2F10%2F26%2F%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-Antd-PRO%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[[toc] 网址 AntD官网：https://ant.design/index-cn 脚手架市场：http://scaffold.ant.design/#/ AntD Pro脚手架：（官方脚手架） 中文：https://pro.ant.design/index-cn e文：https://pro.ant.design/docs/getting-started github：https://github.com/ant-design/ant-design-pro/blob/master/README.zh-CN.md 简介 开箱即用的中台前端/设计解决方案 安装使用 12345$ npm install ant-design-pro-cli -g$ mkdir my-project &amp;&amp; cd my-project$ pro new # 安装脚手架$ npm install$ npm start 布局 BasicLayout：基础页面布局，包含了头部导航，侧边栏和通知栏 BlankLayout：空白的布局 PageHeaderLayout：带有标准 PageHeader 的布局 UserLayout：抽离出用于登陆注册页面的通用布局]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Antd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angular入门]]></title>
    <url>%2F2018%2F10%2F26%2F%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-Angular%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[123https://angular.io/https://www.angular.cn/http://www.angularjs.cn/ 121. Angular和JavaScript不互通（函数、变量、事件都不互通）2. Angular的开发模式和传统开发模式完全不通：只需盯住数据，数据是核心 简介及入门 Angular2是面向未来的科技，要求浏览器支持ES6+ Angular 应用是由组件组成的。 组件由 HTML 模板和组件类组成，组件类控制视图 每个组件都以@Component装饰器函数开始，它接受一个元数据对象参数。该元素对象描述了 HTML 模板和组件类是如何一起工作的 selector属性为 Angular 指定了在index.html中的自定义标签里显示该组件 123456789import &#123; Component &#125; from &apos;@angular/core&apos;;@Component(&#123; selector: &apos;my-app&apos;, template: `&lt;h1&gt;Hello &#123;&#123;name&#125;&#125;&lt;/h1&gt;`&#125;)export class AppComponent &#123; name = &apos;Angular&apos;; &#125;注️：template后面不是单引号 网页版使用示例 1234567891011121314&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;网页版使用示例&lt;/title&gt; &lt;script src=&quot;angular.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div ng-app=&quot;&quot; ng-init=&quot;str=123&quot;&gt; &lt;input type=&quot;text&quot; ng-model=&quot;str&quot;/&gt; &lt;div ng-bing=&quot;str&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 说明： ng-app:表示此区域内由angular控制 Angular CLI http://www.itnose.net/detail/6694827.html Angular CLI是一个命令行界面工具，它可以创建项目、添加文件以及执行一大堆开发任务，比如测试、打包和发布 因为angular-cli是用typescript写的，所以要先装这两个:npm install -g typescript typings 全局安装 :npm install -g @angular/cli 创建新项目:ng new my-app 启动开发服务器:cd my-app;ng serve --open 问题1：/usr/local/lib/node_modules/angular-cli/node_modules/_@ngtools_json-schema@1.0.9@@ngtools/json-schema/src/schema-class-factory.js:34 1解决：node版本太低 问题2:Installing packages for tooling via npm. 1太耗时，强制停止后，通过cnpm下载依赖 命令 使用说明 组件Component ng generate component my-new-component 指令Directive ng generate directive my-new-directive 服务Service ng generate pipe my-new-service 管道Pipe ng generate pipe my-new-pipe 类Class ng generate class my-new-class 接口Interface ng generate interface my-new-interface 枚举对象Enum ng generate enum my-new-enum 模块Module ng generate module my-module 架构 Angular 应用使用方法：用 Angular 扩展语法编写 HTML 模板， 用组件类管理这些模板，用服务添加应用逻辑， 用模块打包发布组件与服务 通过引导根模块来启动该应用。 Angular 在浏览器中接管、展现应用的内容，并根据我们提供的操作指令响应用户的交互 模块 (module) 模块简介 Angular 应用是模块化的，并且 Angular 有自己的模块系统，它被称为 Angular 模块或 NgModules 每个 Angular 应用至少有一个模块（根模块），习惯上命名为AppModule。 Angular 模块都是一个带有@NgModule装饰器的类。 NgModule是一个装饰器函数，它接收一个用来描述模块属性的元数据对象。其中最重要的属性是： declarations - 声明本模块中拥有的视图类。Angular 有三种视图类：组件、指令和管道。 exports - declarations 的子集，可用于其它模块的组件模板。 imports - 本模块声明的组件模板需要的类所在的其它模块。 providers - 服务的创建者，并加入到全局服务列表中，可用于应用任何部分。 bootstrap - 指定应用的主视图（称为根组件），它是所有其它视图的宿主。只有根模块才能设置bootstrap属性。 1234567891011// src/app/app.module.tsimport &#123; NgModule &#125; from &apos;@angular/core&apos;;import &#123; BrowserModule &#125; from &apos;@angular/platform-browser&apos;;@NgModule(&#123; imports: [ BrowserModule ], providers: [ Logger ], declarations: [ AppComponent ], exports: [ AppComponent ], bootstrap: [ AppComponent ]&#125;)export class AppModule &#123; &#125; Angular 模块库 Angular 提供了一组 JavaScript 模块。可以把它们看做库模块。每个 Angular 库的名字都带有@angular前缀 1import &#123; Component &#125; from &apos;@angular/core&apos;; 组件 (component) 组件负责控制屏幕上的一小块区域，我们称之为视图; 组件通过一些由属性和方法组成的 API 与视图交互 123456789101112export class HeroListComponent implements OnInit &#123; heroes: Hero[]; selectedHero: Hero; constructor(private service: HeroService) &#123; &#125; ngOnInit() &#123; this.heroes = this.service.getHeroes(); &#125; selectHero(hero: Hero) &#123; this.selectedHero = hero; &#125;&#125; 模板 (template) 通过组件的自带的模板来定义组件视图。模板以 HTML 形式存在，告诉 Angular 如何渲染组件 元数据 (metadata) 元数据告诉 Angular 如何处理一个类;要告诉 Angular HeroListComponent是个组件，只要把元数据附加到这个类 12345678@Component(&#123; selector: &apos;hero-list&apos;, templateUrl: &apos;./hero-list.component.html&apos;, providers: [ HeroService ]&#125;)export class HeroListComponent implements OnInit &#123;/* . . . */&#125; 数据绑定 (data binding) 数据绑定的语法有四种形式： 1234&lt;li&gt;&#123;&#123;hero.name&#125;&#125;&lt;/li&gt;&lt;hero-detail [hero]=&quot;selectedHero&quot;&gt;&lt;/hero-detail&gt;&lt;li (click)=&quot;selectHero(hero)&quot;&gt;&lt;/li&gt;&lt;input [(ngModel)]=&quot;hero.name&quot;&gt; 每种形式都有一个方向 —— 绑定到 DOM 、绑定自 DOM 以及双向绑定。 指令 (directive) Angular 模板是动态的。当 Angular 渲染它们时，它会根据指令提供的操作对 DOM 进行转换 服务 (service) 组件是最大的服务消费者 12345678910111213141516171819202122//src/app/logger.service.tsexport class Logger &#123; log(msg: any) &#123; console.log(msg); &#125; error(msg: any) &#123; console.error(msg); &#125; warn(msg: any) &#123; console.warn(msg); &#125;&#125;//src/app/hero.service.tsexport class HeroService &#123; private heroes: Hero[] = []; constructor( private backend: BackendService, private logger: Logger) &#123; &#125; getHeroes() &#123; this.backend.getAll(Hero).then( (heroes: Hero[]) =&gt; &#123; this.logger.log(`Fetched $&#123;heroes.length&#125; heroes.`); this.heroes.push(...heroes); // fill cache &#125;); return this.heroes; &#125;&#125; 依赖注入 (dependency injection) Angular 使用依赖注入来提供新组件以及组件所需的服务 当 Angular 创建组件时，会首先为组件所需的服务请求一个注入器 (injector)。 注入器维护了一个服务实例的容器，存放着以前创建的实例。 如果所请求的服务实例不在容器中，注入器就会创建一个服务实例，并且添加到容器中，然后把这个服务返回给 Angular。 当所有请求的服务都被解析完并返回时，Angular 会以这些服务为参数去调用组件的构造函数。 这就是依赖注入 函数：参数由调用方决定 依赖注入：参数由定于方决定 模版 1234567* &#123;&#123;msg&#125;&#125; * $scope Controller* filter &#123;&#123;123|currency&#125;&#125; &#123;&#123;12321213|date:&quot;yyyy-MM-dd&quot;&#125;&#125;* ng-clack]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS预处理技术]]></title>
    <url>%2F2018%2F10%2F26%2F%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-CSS%E9%A2%84%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[CSS预处理器技术已经非常的成熟，而且也涌现出了越来越多的 CSS 的预处理器框架。最普遍的分别是 Sass、Less CSS、Stylus，本文以Less重点讲解。 CSS预处理器 CSS 预处理器是一种语言用来为 CSS 增加一些编程的的特性，无需考虑浏览器的兼容性问题，例如你可以在 CSS 中使用变量、简单的程序逻辑、函数等等在编程语言中的一些基本技巧，可以让你的 CSS 更见简洁，适应性更强，代码更直观等诸多好处 1.Less 可以运行在 Node、浏览器和 Rhino 平台上。网上有很多第三方工具帮助你编译 Less 源码 2.Less 可以通过 npm 在命令行上运行；在浏览器上作为脚本文件下载；或者集成在广大的第三方工具内 3.在服务器端最容易的安装方式就是通过 npm （node.js 的包管理器），方法如下：npm install -g less 4.安装 Less 后，就可以在命令行上调用 Less 编译器了，如：lessc styles.less或lessc styles.less &gt; styles.css 若要输出压缩过的 CSS，只需添加 -x 选项。如果希望获得更好的压缩效果，还可以通过 --clean-css 选项启用 Clean CSS 进行压缩 5.在代码中调用 Less如下： var less = require(‘less’); less.render(’.class { width: (1 + 1) }’, function (e, css) { console.log(css); }); 6.还可以手动调用分析器（paser）和编译器: var parser = new(less.Parser); parser.parse(’.class { width: (1 + 1) }’, function (err, tree) { if (err) { return console.error(err) } console.log(tree.toCSS()); }); 7.可以给编译器传递多个参数 var parser = new(less.Parser)({ paths: [’.’, ‘./lib’], // Specify search paths for @import directives filename: ‘style.less’ // Specify a filename, for better error messages }); parser.parse(’.class { width: (1 + 1) }’, function (e, tree) { tree.toCSS({ // Minify CSS output compress: true }); }); 8.Less 还和流行的 Grunt 构建工具进行了集成，可以参考 grunt-contrib-less 插件 9.在客户端使用 Less.js 是最容易的方式，并且在开发阶段很方便，但是，在生产环境中，性能和可靠性非常重要，我们建议最好使用 node.js 或其它第三方工具进行预编译 http://www.bootcss.com/p/lesscss/ LESS 原理及使用方式 本质上，LESS 包含一套自定义的语法及一个解析器，用户根据这些语法定义自己的样式规则，这些规则最终会通过解析器，编译生成对应的 CSS 文件。LESS 并没有裁剪 CSS 原有的特性，更不是用来取代 CSS 的，而是在现有 CSS 语法的基础上，为 CSS 加入程序式语言的特性 LESS 可以直接在客户端使用，也可以在服务器端使用。在实际项目开发中，我们更推荐使用第三种方式，将 LESS 文件编译生成静态 CSS 文件，并在 HTML 文档中应用 客户端： ==LESS 源文件一定要在 less.js 引入之前引入，这样才能保证 LESS 源文件正确编译解析 服务器端：目前常用的方式是利用 node 的包管理器 (npm) 安装 LESS，安装成功后就可以在 node 环境中对 LESS 源文件进行编译 以通过这个关键字引入我们需要的 .less 或 .css 文件。 如： @import “variables.less”; .less 文件也可以省略后缀名，像这样： @import “variables”; 引入 CSS 同 LESS 文件一样，只是 .css 后缀名不能省略 变量 1.LESS 允许开发者自定义变量，变量可以在全局样式中使用，变量使得样式修改起来更加简单 2.ESS 中的变量和其他编程语言一样，可以实现值的复用，同样它也有生命周期，也就是作用域，查找变量的顺序是先在局部定义中找，如果找不到，则查找上级定义，直至全局 @width : 20px; #homeDiv { @width : 30px; #centerDiv{ width : @width;// 此处应该取最近定义的变量 width 的值 30px } } Mixins（混入） 1.混入是指在一个 CLASS 中引入另外一个已经定义的 CLASS，就像在当前 CLASS 中增加一个属性一样 // 定义一个样式选择器 .roundedCorners(@radius:5px) { -moz-border-radius: @radius; -webkit-border-radius: @radius; border-radius: @radius; } // 在另外的样式选择器中使用 #header { .roundedCorners; } #footer { .roundedCorners(10px); } 2.Mixins中@arguments是一个很特别的参数，当 Mixins 引用这个参数时，该参数表示所有的变量，很多情况下，这个参数可以省去你很多代码 .boxShadow(@x:0,@y:0,@blur:1px,@color:#000){ -moz-box-shadow: @arguments; -webkit-box-shadow: @arguments; box-shadow: @arguments; } #header { .boxShadow(2px,2px,3px,#f36); } 3.LESS也采用了命名空间的方法来避免重名问题 #mynamespace { .home {…} .user {…} } 如果我们要复用 user 这个选择器的时候，就可以了通过：#mynamespace &gt; .user 的方式 4.嵌套的规则 在我们书写标准 CSS 的时候，遇到多层的元素嵌套这种情况时，我们要么采用从外到内的选择器嵌套定义，要么采用给特定元素加 CLASS 或 ID 的方式。在 LESS 中我们可以这样写： HTML 片段 top left right 对应LESS 文件 #home{ color : blue; width : 600px; height : 500px; border:outset; #top{ border:outset; width : 90%; } #center{ border:outset; height : 300px; width : 90%; #left{ border:outset; float : left; width : 40%; } #right{ border:outset; float : left; width : 40%; } } } 运算及函数 简单的讲，就是对数值型的 value（数字、颜色、变量等）进行加减乘除四则运算。同时 LESS 还有一个专门针对 color 的操作提供一组函数。 下面是 LESS 提供的针对颜色操作的函数列表： lighten(@color, 10%); // return a color which is 10% lighter than @color darken(@color, 10%); // return a color which is 10% darker than @color saturate(@color, 10%); // return a color 10% more saturated than @color desaturate(@color, 10%);// return a color 10% less saturated than @color fadein(@color, 10%); // return a color 10% less transparent than @color fadeout(@color, 10%); // return a color 10% more transparent than @color spin(@color, 10); // return a color with a 10 degree larger in hue than @color spin(@color, -10); // return a color with a 10 degree smaller hue than @color 变量使用示例： @init: #111111; @transition: @init*2; .switchColor { color: @transition; } Comments（注释） 适当的注释是保证代码可读性的必要手段，LESS 对注释也提供了支持，主要有两种方式：单行注释和多行注释 LESS 中单行注释 (// 单行注释 ) 是不能显示在编译后的 CSS 中，所以如果注释是针对样式说明的请使用多行注释]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ejs模版引擎基本使用]]></title>
    <url>%2F2018%2F10%2F26%2F%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-ejs%E6%A8%A1%E7%89%88%E5%BC%95%E6%93%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[http://www.360doc.com/content/16/0115/10/597197_528136785.shtml express中使用ejs 1234var express = require(&apos;express&apos;);//需要安装 expressvar app = express();app.set(&quot;view engine&quot;,&quot;ejs&quot;);//模版引擎设置为 ejs 文件组织 在express中使用ejs，文件组织遵循express。 views-------放置动态模版 public------放置静态网页 layouts-----放置布局文件 EJS成员函数： Render(str,data,[option]):直接渲染字符串并生成html 123str：需要解析的字符串模板data：数据option：配置选项 Compile(str,[option]):编译字符串得到模板函数 12str：需要解析的字符串模板option：配置选项 基本语法 &lt;% code %&gt;:无缓冲的条件语句元素 &lt;%= code %&gt;:转义HTML，该code并且会打印出来 &lt;%- code %&gt;:非转义的buffering，该code并且会打印出来 &lt;% include file %&gt;:内嵌别的文件 &lt;% layout(file) -%&gt;:指定布局文件 &lt;% script(file) -%&gt;:包含js脚本文件 &lt;% stylesheet(file) -%&gt;:包含css文件 &lt;% block(code, code) -%&gt;:指定块内容 &lt;%# %&gt;:注释标签 基本对象 scripts:包含的脚本 stylesheets:包含的css blocks:包含的块]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TypeScript入门]]></title>
    <url>%2F2018%2F10%2F26%2F%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-TypeScript%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[[toc] 12https://www.tslang.cn/http://www.typescriptlang.org/ 简介 微软出品，2012 编译型语言 强类型语言 真面向对象 AMD方式 cnpm install -g typescript 扩展名：.ts／.tsx/.d.ts 编译： tsc 1.ts //1.js number\string\boolean\symbol\void\null\undefined\enum\any any:变体变量 var a:any; a=12; a=“abc”; var a:any; 等同于 var a;//类型推测（隐式类型声明） 冲突检测：编译器会自动排除掉无用的选项 联合类型： var a:number|string; a=12; a=‘abc’; a=false;//报错 数组也有类型 外部声明declare，window等都内部声明过了 declare var 名字； function sum(a:number,b:number):number{ return a+b; } function ajax(url:string,success:(res:string,code:number)=&gt;void,error:(code:number)=&gt;void){ } 对象类型：ObjectType var a:{x:number,y:number} 可选声明：var a:{x:number,y:number,z?:number},调用或赋值的时候，z可有可无 接口：约定、限制 interface Point{ x:number, y:number, z?:number } 泛型： class Calc{ a:T; b:T; } var obj=new Calc(); obj.a=12; obj.b=‘123’;//报错 tsconfig.json]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pug模版引擎基本使用]]></title>
    <url>%2F2018%2F10%2F26%2F%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-pug%E6%A8%A1%E7%89%88%E5%BC%95%E6%93%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[[toc] 安装 npm install -g pug npm install -g pug-cli pug index.pug webstorm添加pug文件自动编译 WebStorm下，File-&gt;settings，在左上角搜索watcher，选择Tools-&gt;fileWatcher 添加一个watcher，选择类型为Jade（pug支持安装了，但是不知道怎样使用，发现全部用Jade也能使用） 在Program下，选择pug的安装路径，如我的为：/usr/local/bin/pug,在Arguments的默认值前面添加-P可以让编译后的文件格式化显示 编写pug文件，编写后，会自动生成相应的编译后文件 在 Express 中调用 jade 模板引擎 123456app.set(&apos;view engine&apos;, &apos;jade&apos;); // 设置模板引擎app.set(&apos;views&apos;, __dirname); // 设置模板相对路径(相对当前目录)app.get(&apos;/&apos;, function(req, res) &#123; res.render(&apos;test&apos;); // 调用当前路径下的 test.jade 模板&#125;) 基本语法及支持 类名和ID名 a.class名称,如：a.button,翻译为： a#id名称，如：a#button，翻译为： 属性 属性可以使用()包裹起来,属性值之间用逗号隔开，如：a(href=“google.com”,title=“google”) 文本内容 在html标签后空格直接书写 多行文本内容 123p. asdfasdfa asdfasd 或者 1234p | dfas &lt;strong&gt;hey&lt;/strong&gt; strong hey man | dfas 注释 单行注释 普通方式：// just some paragraphs，翻译为： 非缓冲注释，不会被编译到HTML：//- will not output within markup 多行注释 123// As much text as you want can go here. 变量 jade 的变量调用有 3 种方式: #{表达式} //此方式可以自由的嵌入各个地方 =表达式 //返回的是表达式的值,会编码字符串 !=表达式 //返回的是表达式的值,不会编码字符串 注意：符号 - 开头在 jade 中属于服务端执行的代码 1234- console.log(&apos;hello&apos;); // 这段代码在服务端执行- var s = &apos;hello world&apos; // 在服务端空间中定义变量p #&#123;s&#125; //&lt;p&gt;hello world&lt;/p&gt;p= s //&lt;p&gt;hello world&lt;/p&gt; 使用： 直接在 jade 模板中定义变量 在 express 中调用 res.render 方法的时候将变量一起传递进模板的空间中,调用模板的时候，在 jade 模板中也可以如上方那样直接调用 s 这个变量 123res.render(test, &#123; s: &apos;hello world&apos;&#125;); 流程代码 if判断 方式1: 1234567- var user = &#123; description: &apos;我喜欢猫&apos; &#125;- if (user.description) h2 描述 p.description= user.description- else h1 描述 p.description 用户无描述 方式2: 12345678- var user = &#123; description: &apos;我喜欢猫&apos; &#125;#user if user.description h2 描述 p.description= user.description else h1 描述 p.description 用户无描述 方式1、方式2执行结果： 1234&lt;div id=&quot;user&quot;&gt; &lt;h2&gt;描述&lt;/h2&gt; &lt;p class=&quot;description&quot;&gt;我喜欢猫&lt;/p&gt;&lt;/div 方式3: 使用 Unless 类似于 if 后的表达式加上了 ! 取反;这个 unless 是 jade 提供的关键字，不是运行的 js 代码 123- var user = &#123; name: &apos;Alan&apos;, isVip: false &#125;unless user.isVip p 亲爱的 #&#123;user.name&#125; 您并不是 VIP 循环 for 循环 12345- var array = [1,2,3]ul - for (var i = 0; i &lt; array.length; ++i) &#123; li hello #&#123;array[i]&#125; - &#125; each:in后的循环目标支持数组、json 123ul each val, index in [&apos;西瓜&apos;, &apos;苹果&apos;, &apos;梨子&apos;] li= index + &apos;: &apos; + val Case选择 case 不支持case 穿透，如果 case 穿透的话会报错 12345- var friends = 1case friends when 0: p you have no friends when 1: p you have a friend default: p you have #&#123;friends&#125; friends 或 12345678- var friends = 10case friends when 0 p you have no friends when 1 p you have a friend default p you have #&#123;friends&#125; friends 模板中调用Markdown语言 12345:markdown # Markdown 标题 //翻译后：&lt;h1&gt;Markdown 标题&lt;/h1&gt; 可重用的 jade 块 (Mixins) 123456789101112mixin article(title) .article .article-wrapper h1= title //- block 为 jade 关键字代表外部传入的块 if block block else p 该文章没有内容 +article(&apos;Hello world&apos;)+article(&apos;Hello Jade&apos;) 结果： 1234567891011&lt;div class=&quot;article&quot;&gt; &lt;div class=&quot;article-wrapper&quot;&gt; &lt;h1&gt;Hello world&lt;/h1&gt; &lt;p&gt;该文章没有内容&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;article&quot;&gt; &lt;div class=&quot;article-wrapper&quot;&gt; &lt;h1&gt;Hello Jade&lt;/h1&gt; &lt;/div&gt;&lt;/div&gt; Mixins 同时也可以从外部获取属性: 1234567mixin link(href, name) a(class!=attributes.class, href=href)= name +link(&apos;/foo&apos;, &apos;foo&apos;)(class=&quot;btn&quot;)//编译后&lt;a href=&quot;/foo&quot; class=&quot;btn&quot;&gt;foo&lt;/a&gt; 模板包含 (Includes) 可以使用 Includes 在模板中包含其他模板的内容 模板继承 (Extends) layout.jade 123456789doctype htmlhtml head title 我的网站 meta(http-equiv=&quot;Content-Type&quot;,content=&quot;text/html; charset=utf-8&quot;) link(type=&quot;text/css&quot;,rel=&quot;stylesheet&quot;,href=&quot;/css/style.css&quot;) script(src=&quot;/js/lib/jquery-1.8.0.min.js&quot;,type=&quot;text/javascript&quot;) body block content article.jade 12345//- extends 拓展调用 layout.jadeextends ../layoutblock content h1 文章列表 p 习近平忆贾大山 李克强:将启动新核电项目 res.render(‘article’) 的结果： 123456789101112&lt;html&gt; &lt;head&gt; &lt;title&gt;我的网站&lt;/title&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;&lt;/head&gt; &lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;/css/style.css&quot;&gt;&lt;/head&gt; &lt;script src=&quot;/js/lib/jquery-1.8.0.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;文章列表&lt;/h1&gt; &lt;p&gt;习近平忆贾大山 李克强:将启动新核电项目&lt;/p&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js测试分类]]></title>
    <url>%2F2018%2F10%2F26%2F%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-js%E6%B5%8B%E8%AF%95%E5%88%86%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[http://www.cnblogs.com/wangshenhe/archive/2013/02/16/2913431.html 在实际的项目中，我们可能随时面对各种不同的需求，它的各个方面的要素决定了我们所采用的开发模式。 比如，它的复杂度如何？所有的需求是否足够清晰？开发人员对相关的业务是否足够了解？项目的工期是否合理？种种问题，不一而足。这也决定了我们可能面对不同的需求可能需要采用不同的开发模式。下面大概说几种： TDD TDD指的是Test Drive Development，很明显的意思是测试驱动开发，也就是说我们可以从测试的角度来检验整个项目。大概的流程是先针对每个功能点抽象出接口代码，然后编写单元测试代码，接下来实现接口，运行单元测试代码，循环此过程，直到整个单元测试都通过。这一点和敏捷开发有类似之处。 TDD的好处自然不用多说，它能让你减少程序逻辑方面的错误，尽可能的减少项目中的bug，开始接触编程的时候我们大都有过这样的体验，可能你觉得完成得很完美，自我感觉良好，但是实际测试或者应用的时候才发现里面可能存在一堆bug，或者存在设计问题，或者更严重的逻辑问题，而TDD正好可以帮助我们尽量减少类似事件的发生。而且现在大行其道的一些模式对TDD的支持都非常不错，比如MVC和MVP等。 但是并不是所有的项目都适合TDD这种模式的，我觉得必须具备以下几个条件： 首先，项目的需求必须足够清晰，而且程序员对整个需求有足够的了解，如果这个条件不满足，那么执行的过程中难免失控。当然，要达到这个目标也是需要做一定功课的，这要求我们前期的需求分析以及HLD和LLD都要做得足够的细致和完善。 其次，取决于项目的复杂度和依赖性，对于一个业务模型及其复杂、内部模块之间的相互依赖性非常强的项目，采用TDD反而会得不尝失，这会导致程序员在拆分接口和写测试代码的时候工作量非常大。另外，由于模块之间的依赖性太强，我们在写测试代码的时候可能不采取一些桥接模式来实现，这样势必加大了程序员的工作量。 BDD BDD指的是Behavior Drive Development，也就是行为驱动开发。这里的B并非指的是Business，实际上BDD可以看作是对TDD的一种补充，当然你也可以把它看作TDD的一个分支。因为在TDD中，我们并不能完全保证根据设计所编写的测试就是用户所期望的功能。BDD将这一部分简单和自然化，用自然语言来描述，让开发、测试、BA以及客户都能在这个基础上达成一致。因为测试优先的概念并不是每个人都能接受的，可能有人觉得系统太复杂而难以测试，有人认为不存在的东西无法测试。所以，我们在这里试图转换一种观念，那便是考虑它的行为，也就是说它应该如何运行，然后抽象出能达成共识的规范。如果你用过JBehave之类的BDD框架，你将会更好的理解其中具体的流程。这里我推荐一篇具体阐述的文章。亲身体验行为驱动开发。 另外，关于TDD和BDD之间的关系，还可以参考这篇文章: 虚拟座谈会：代码测试比率、测试驱动开发及行为驱动开发 DDD DDD指的是Domain Drive Design，也就是领域驱动开发。这是一种非常好的思想，在我们刚开始学习程序，甚至刚开始学习三层架构的时候，我们曾经面临过很多疑惑，比如如何来实现我们的数据层？后来我们开始学习MVC，MVP等架构，如何设计Model层又成了我们的新问题。我们见过太多这种情况，Model变成了单纯的数据容器，也就是我们经常说的贫血模式。DDD实际上也是建立在这个基础之上，因为它关注的是Service层的设计，着重于业务的实现，因此不可避免的以贫血模式为基础而存在。但是它最大的特别是将分析和设计结合起来，不再使他们处于分裂的状态，这对于我们正确完整的实现客户的需求，以及建立一个具有业务伸缩性的模型，是有很大帮助的。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>Express</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[readline模块的使用]]></title>
    <url>%2F2018%2F10%2F26%2F%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-readline%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[[toc] API: http://nodejs.cn/api/readline 简介 Readline是Node.js里实现标准输入输出的封装好的模块，通过这个模块我们可以以逐行的方式读取数据流。使用require(“readline”)可以引用模块 创建Readline实例 readline.createInterface(options) 123456789101112创建一个readline的接口实例. 接受一个Object类型参数，可传递以下几个值:input - 要监听的可读流 (必需)output - 要写入 readline 的可写流 (必须).completer - 用于 Tab 自动补全的可选函数。(不常用)terminal - 如果希望 input 和 output 流像 TTY 一样对待，那么传递参数 true ，并且经由 ANSI/VT100 转码。 默认情况下检查 isTTY 是否在 output 流上实例化。(不常用)var readline = require(‘readline’); var rl = readline.createInterface(&#123; input: process.stdin, output: process.stdout &#125;); 接口 rl.close()：关闭接口实例 (Interface instance), 放弃控制输入输出流。”close” 事件会被触发 rl.pause()：暂停 readline 的输入流 (input stream), 如果有需要稍后还可以恢复 rl.prompt([preserveCursor])：为用户输入准备好readline，将现有的setPrompt选项放到新的一行，让用户有一个新的地方开始输入。将preserveCursor设为true来防止光标位置被重新设定成0 rl.question(query, callback)：预先提示指定的query，然后用户应答后触发指定的callback。 显示指定的query给用户后，当用户的应答被输入后，就触发了指定的callback rl.resume()：恢复 readline 的输入流 (input stream) rl.setPrompt(prompt)：设置提示符，例如当你在命令行运行 node 时，你会看到(prompt) 示例 1234567891011121314var readline = require(&apos;readline&apos;);var rl = readline.createInterface(process.stdin,process.stdout);// question方法rl.question(&apos;what is you name? &apos;,function(answer)&#123; console.log(&apos;my name is &apos; + answer); //不加close，则不会结束 rl.close();&#125;);// close事件监听rl.on(&apos;close&apos;,function()&#123; console.log(&apos;欢迎下次再来&apos;); process.exit(0);&#125;);]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异步编程及Async模块的使用]]></title>
    <url>%2F2018%2F10%2F26%2F%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E5%8F%8AAsync%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[[toc] 1汇智网-异步编程：http://cw.hubwiz.com/card/c/543e1a4f032c7816c0d5dfa1/1/3/6/ 简介 github网址：https://github.com/caolan/async 异步编程是指由于异步I/O等因素，无法同步获得执行结果时，在回调函数中进行下一步操作的代码编写风格,常见的如setTimeout函数、ajax请求等等 使用Asycn模块需要安装，它不是node自带的 12安装：npm install async 引用：var async = require(&apos;async&apos;); 异常捕获：异步I/O的实现主要有两个阶段，①提交请求；②处理结果； 这两个阶段彼此不关联，而异常并不一定发生在请求提交（即调用函数）时，平常的try/catch并不能有效的捕捉到程序的异常 函数式编程 高阶函数 高阶函数与普通函数不同的地方是高阶函数可以把函数作为参数，或者是将函数作为返回值 函数作为参数；函数作为返回值； 123456//高阶函数test的返回值是一个匿名函数function test(v)&#123; return function()&#123; return v; &#125;&#125; 偏函数 一个创建函数的工厂函数；通过指定部分参数，定制新的函数 假设有一个参数或变量已经预置的函数A，我们通过调用A来产生一个新的函数B，函数B就是我们说的偏函数 12345678//isType函数中预置了判断类型的方法，只指定部分参数来产生的新的定制的函数isString和isFunction就是偏函数var isType = function(type)&#123; return function(obj)&#123; return toString.call(obj)==&apos;[object &apos;+type+&apos;]&apos;; &#125;&#125;;var isString = isType(&apos;String&apos;);var isFunction = isType(&apos;Function&apos;); 编写偏函数 12345678var say =function(name)&#123; return function(text)&#123; console.log(name+&apos; say &apos;+text); &#125;&#125;;var tomSay = say(&apos;tom&apos;);tomSay (&apos;hello&apos;); 方法说明 series 它是控制异步函数按照串行顺序执行，只有前一个执行完毕，才能执行下一个异步调用 123456789101112async.series([function(cb)&#123; setTimeout(function()&#123; cb(null,1); &#125;,1000)&#125;,function(cb)&#123; setTimeout(cb,1000,null,2); &#125;],function(err,result)&#123; //result是每个回调函数传进来的data参数，result=[1,2] if (err) console.error(err); else console.log(result);&#125;) parallel parallel的用法和series类似。只是数组中的函数是并行执行，parallel的总时间取决于运行时间最长的函数。而最终的回调函数里result的值是按照数组中函数的顺序排列的 waterfall 和series函数有很多相似之处，都是按照顺序执行。 不同之处是waterfall每个函数产生的值，都将传给下一个函数，而series则没有这个功能 12345678910111213141516171819async.waterfall([function(cb)&#123; setTimeout(function()&#123; cb(null,1); &#125;,1000)&#125;,function(data,cb)&#123; setTimeout(cb,1000,null,data+&quot;+&quot;+&quot;2&quot;);&#125;],function(err,result)&#123; //result = &quot;1+2&quot; if (err) console.error(err); else console.log(result);&#125;)~~~ ## parallelLimit(tasks, limit, [callback])parallelLimit函数和parallel类似，但是它多了一个参数limit。 limit参数限制任务只能同时并发一定数量，而不是无限制并发## whilst(test, fn, callback)相当于while，但其中的异步调用将在完成后才会进行下一次循环;test参数是一个返回布尔值结果的函数，通过返回值来决定循环是否继续，作用等同于while循环停止的条件 var count = 0; async.whilst( function () { return count &lt; 5; }, function (callback) { count++; setTimeout(callback, 1000); }, function (err) { } ); 123456## doWhilst(fn, test, callback)相当于do…while,较whilst而言，doWhilst交换了fn,test的参数位置，先执行一次循环，再做test判断## until(test, fn, callback)until与whilst正好相反，当test条件函数返回值为false时继续循环，与true时跳出。其它特性一致 var count = 5; async.until( function () { return count &lt; 0; }, function (callback) { count–; setTimeout(callback, 1000); }, function (err) { } ); 1234567891011## doUntil(fn, test, callback)doUntil与doWhilst正好相反，当test为false时循环，与true时跳出。其它特性一致## forever(fn, errback)forever函数比较特殊，它的功能是无论条件如何，函数都一直循环执行，只有出现程序执行的过程中出现错误时循环才会停止，callback才会被调用## compose(fn1, fn2...)使用compose可以创建一个异步函数的集合函数，将传入的多个异步函数包含在其中，当我们执行这个集合函数时，会依次执行每一个异步函数，每个函数会消费上一次函数的返回值==注意==：从内层到外层的执行的顺序；从右往左执行 var async = require(‘async’); function fn1(n, callback) { setTimeout(function () { callback(null, n + 1); }, 1000); } function fn2(n, callback) { setTimeout(function () { callback(null, n * 3); }, 1000); } var demo = async.compose(fn2, fn1); demo(4, function (err, result) { console.log(result); //结果15 }); demo = async.compose(fn1, fn2); demo(4, function (err, result) { console.log(result); //结果13 }); 1234## auto(tasks, [callback])* 用来处理有依赖关系的多个任务的执行* async.auto的强大是在于，你定义好相互之间的dependencies，他来帮你决定用parallel还是waterfull async.auto({ getData: function(callback){ callback(null, ‘data’, ‘converted to array’); }, makeFolder: function(callback){ callback(null, ‘folder’); }, writeFile: [‘getData’, ‘makeFolder’, function(callback, results){ callback(null, ‘filename’); }], emailLink: [‘writeFile’, function(callback, results){ callback(null, {‘file’:results.writeFile, ‘email’:‘user@example.com’}); }] }, function(err, results) { console.log('err = ', err); console.log('results = ', results); }); 123456## queue(worker, concurrency)queue相当于一个加强版的parallel，主要是限制了worker数量，不再一次性全部执行。当worker数量不够用时，新加入的任务将会排队等候，直到有新的worker可用## apply(function, arguments..)apply是一个非常好用的函数，可以让我们给一个函数预绑定多个参数并生成一个可直接调用的新函数，简化代码 function(callback) { test(3, callback); }; 用apply改写： async.apply(test, 3); 12345## iterator(tasks)* 将一组函数包装成为一个iterator，可通过next()得到以下一个函数为起点的新的iterator。该函数通常由async在内部使用，但如果需要时，也可在我们的代码中使用它* 直接调用()，会执行当前函数，并返回一个由下个函数为起点的新的iterator。调用next()，不会执行当前函数，直接返回由下个函数为起点的新iterator* 对于同一个iterator，多次调用next()，不会影响自己。如果只剩下一个元素，调用next()会返回null var iter = async.iterator([ function() { console.log(‘111’) }, function() { console.log(‘222’) }, function() { console.log(‘333’) } ]); iter();]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NodeJS快速入门]]></title>
    <url>%2F2018%2F10%2F26%2Fnode-NodeJS%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[http://cw.hubwiz.com/card/c/5359f6f6ec7452081a7873d8/1/1/2/ [toc] Node中标准回调函数 12345function(err,data)&#123;&#125;第一个参数为err是错误信息第二个参数为data是返回的数据 进程管理 process是一个全局内置对象，可以在代码中的任何位置访问此对象，这个对象代表我们的node.js代码宿主的操作系统进程对象。 使用process对象可以截获进程的异常、退出等事件，也可以获取进程的当前目录、环境变量、内存占用等信息，还可以执行进程退出、工作目录切换等操作。 1234567891011121314151617181920212223242526272829* process.cwd(); //查看应用程序当前目录* process.chdir(&quot;目录&quot;); //改变应用程序目录* stdout是标准输出流,作用就是将内容打印到输出设备上 console.log = function(d)&#123; process.stdout.write(d+&apos;\n&apos;); &#125; * stderr是标准错误流,用来打印错误信息,可以通过它来捕获错误信息 //process.stderr.write(输入内容);* stdin是进程的输入流,我们可以通过注册事件的方式来获取输入的内容 process.stdin.on(&apos;readable&apos;, function() &#123; var chunk = process.stdin.read(); if (chunk !== null) &#123; process.stdout.write(&apos;data: &apos; + chunk); &#125; &#125;);* process.exit(code); //需要在程序内杀死进程，退出程序时使用，参数code为退出后返回的代码，如果省略则默认返回0；* process.on()； //此方法可监听进程事件 exit事件：//当进程要退出之前，会触发exit事件。通过监听exit事件，我们可就以在进程退出前进行一些清理工作： process.on(&quot;exit&quot;,function(code)&#123;//参数code表示退出码 console.log(&quot;I am tired...&quot;)//进行一些清理工作 &#125;); uncaughtException事件: //如果进程发生了未捕捉的异常，会触发uncaughtException事件。通过监听这个事件，可以 让进程优雅的退出 process.on(&quot;uncaughtException&quot;,function(err)&#123; console.log(err); &#125;); throw new Error(&quot;我故意的...&quot;); //故意抛出一个异常* 设置编码 process.stdin.setEncoding(编码); process.stdout.setEncoding(编码); process.stderr.setEncoding(编码); 子进程 ==node.js是基于单线程模型架构==，这样的设计可以带来高效的CPU利用率，但是无法却利用多个核心的CPU，为了解决这个问题，node.js提供了==child_process模块，通过多进程来实现对多核CPU的利用== child_process模块提供了四个创建子进程的函数，分别是spawn，exec，execFile和fork。 spawn函数用给定的命令发布一个子进程，只能运行指定的程序，参数需要在列表中给出 123456var child_process = require(&apos;child_process&apos;);var child = child_process.spawn( command );child.stdout.on(&apos;data&apos;, function(data) &#123; console.log(data);&#125;);通过执行命令得到返回结果 exec也是一个创建子进程的函数，与spawn函数不同它可以直接接受一个回调函数作为参数 1234var child_process = require(&apos;child_process&apos;);child_process.exec( command , function(err, stdout , stderr ) &#123; console.log( stdout );&#125;); execFile函数与exec函数类似，但execFile函数更显得精简，因为它可以直接执行所指定的文件 1234var child_process = require(&apos;child_process&apos;);child_process.execFile( file , function(err, stdout , stderr ) &#123; console.log( stdout );&#125;); ==fork函数可直接运行Node.js模块==，所以我们可以直接通过指定模块路径而直接进行操作.==该方法是spawn()的特殊情景，用于派生Node进程== 12var child_process = require(&apos;child_process&apos;);child_process.fork( modulePath ); 文件I/O node.js中提供一个名为fs的模块来支持I/O操作，fs模块的文件I/O是对标准POSIX函数的简单封装。 fs模块不但提供异步的文件操作，还提供相应的同步操作方法，需要指出的是，nodejs采用异步I/O正是为了避免I/O时的等待时间，提高CPU的利用率，所以在选择使用异步或同步方法的时候需要权衡取舍。 fs.writeFile(filename, data, callback) 异步的将数据写入一个文件 如果文件已经存在则会被替换;数据参数可以是string或者是Buffer,编码格式参数可选，默认为&quot;utf8&quot; 12345var fs= require(&quot;fs&quot;); fs.writeFile(&apos;test.txt&apos;, &apos;Hello Node&apos;, function (err) &#123; if (err) throw err; console.log(&apos;Saved successfully&apos;); //文件被保存&#125;); fs.appendFile(文件名,数据,编码,回调函数(err)); 将新的内容追加到已有的文件中，如果文件不存在，则会创建一个新的文件;编码格式默认为&quot;utf8&quot; 12345var fs= require(&quot;fs&quot;); fs.appendFile(&apos;test.txt&apos;, &apos;data to append&apos;, function (err) &#123; if (err) throw err; console.log(&apos;The &quot;data to append&quot; was appended to file!&apos;); &#125;); fs.exists(文件，回调函数(exists)); //exists的回调函数只有一个参数，类型为布尔型，通过它来表示文件是否存在 fs.rename(旧文件，新文件，回调函数(err)); ==//修改文件名称== fs.rename(oldPath,newPath,function (err); ==//移动文件== fs.readFile(文件,[编码],回调函数); //读取文件内容 fs.unlink(文件,回调函数(err)); ==//删除文件== fs.mkdir(路径，权限，回调函数(err)); //创建目录； 1权限：默认为0777，表示文件所有者、文件所有者所在的组的用户、所有用户，都有权限进行读、写、执行的操作 fs.rmdir(路径，回调函数(err)); //删除目录 fs.readdir(目录,回调函数(err,files));//读取目录下所有的文件 url处理 node.js为互联网而生，和url打交道是无法避免的了，url模块提供一些基础的url处理。 url.parse(‘http://www.baidu.com’); //解析url，返回一个json格式的数组 url.parse(‘http://www.baidu.com?page=1’,true);//当==第二个==参数为true时，会将查询条件也解析成json格式的对象。 url.parse(‘http://www.baidu.com/news’,false,true);当==第三个==参数为true，解析时会将url的&quot;//“和第一个”/&quot;之间的部分解析为主机名 url.format({ protocol: ‘http:’, hostname:‘www.baidu.com’, port:‘80’, pathname :’/news’, query:{page:1} } ); ==作用与parse相反，它的参数是一个JSON对象，返回一个组装好的url地址== url.resolve(‘http://example.com/two’, ‘/one’)；//组装路径，第一个路径是开始的路径或者说当前路径，第二个则是想要去往的路径。==结果：==‘http://example.com/one’ path优化 本模块包含一套用于处理和转换文件路径的工具集,用于处理目录的对象，提高用户开发效率 path.normalize(’/path///normalize/hi/…’);//将不符合规范的路径经过格式化转换为标准路径,解析路径中的.与…外，还能去掉多余的斜杠 path.join(’///you’, ‘/are’, ‘//beautiful’);//结果：’/you/are/beautiful’。join函数将传入的多个路径拼接为标准路径并将其格式化，返回规范后的路径，避免手工拼接路径字符串的繁琐 path.dirname(’/foo/strong/cool/nice’); //用来返回路径中的目录名 basename函数可返回路径中的最后一部分，并且可以对其进行条件排除. path.basename(‘路径字符串’); path.basename(‘路径字符串’, ‘[ext]’)&lt;排除[ext]后缀字符串&gt;; path.extname(‘index.html’); //返回路径中文件的扩展名 字符串转换 Query String模块用于==实现URL参数字符串与参数对象之间的互相转换==，提供了&quot;stringify&quot;、&quot;parse&quot;等一些实用函数来针对字符串进行处理，通过序列化和反序列化，来更好的应对实际开发中的条件需求，对于逻辑的处理也提供了很好的帮助 序列化 querystring.stringify({foo:‘bar’,cool:[‘xux’, ‘yys’]}); //结果：foo=bar&amp;cool=xux&amp;cool=yys。 1作用就是序列化对象，也就是说将对象类型转换成一个字符串类型（默认的分割符（&quot;&amp;&quot;）和分配符（&quot;=&quot;）） querystring.stringify(“对象”，“分隔符”，“分配符”) 12querystring.stringify(&#123;foo:&apos;bar&apos;,cool:[&apos;xux&apos;, &apos;yys&apos;]&#125;,&apos;*&apos;,&apos;$&apos;);结果：&apos;foo$bar*cool$xux*cool$yys&apos; 反序列化 querystring.parse(‘foo=bar&amp;cool=xux&amp;cool=yys’); 12运行结果：&#123; foo: &apos;bar&apos;, cool: [&apos;xux&apos;, &apos;yys&apos;]&#125;parse函数的作用就是反序列化字符串（默认是由&quot;=&quot;、&quot;&amp;&quot;拼接而成），转换得到一个对象类型 querystring.parse(‘foo@barcool@xuxcool@xuxcool@xuxcool@yys’,’@’,’$’); 1运行结果：&#123; foo: &apos;&apos;, bar: &apos;cool&apos;, xux: &apos;cool&apos;, yys: &apos;&apos; &#125; 实用工具 util模块。util模块呢，是一个Node.js核心模块，提供常用函数的集合，用于弥补核心JavaScript的一些功能过于精简的不足。并且还提供了一系列常用工具，用来对数据的输出和验证 util.inspect(object,[showHidden],[depth],[colors])； //将任意对象转换为字符串的函数，通常用于调试和错误输出 format函数 1231. 如果占位符没有相对应的参数，占位符将不会被替换2. 如果有多个参数占位符，额外的参数将会调用util.inspect()转换为字符串。这些字符串被连接在一起，并且以空格分隔3. 如果第一个参数是一个非格式化字符串，则会把所有的参数转成字符串并以空格隔开拼接在一块，而且返回该字符串 util.isArray(object); //判断对象是否为数组类型，是则返回ture,否则为fals util.isDate(object); //判断对象是否为日期类型，是则返回ture,否则返回false util.isRegExp(object); //判断对象是否为正则类型，是则返回ture,否则返回false]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node API学习]]></title>
    <url>%2F2018%2F10%2F26%2Fnode-Node-API%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。 Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。 Node.js 的包管理器 npm，是全球最大的开源库生态系统。 123456中文网址：http://nodejs.cn/英文网址：https://nodejs.org/en/其他相关网址：https://www.npmjs.com/https://github.com/ http://nodejs.cn/api/ [toc] node命令用法 1node [options] [v8 options] [script.js | -e &quot;script&quot;] [arguments] assert (断言) assert 模块提供了一组简单的断言测试集合，可被用于测试不变量。 该模块在代码中可通过 require(‘assert’) 使用。 assert 不是一个测试框架，也无意成为通用的断言库。 Buffer 在 ECMAScript 2015 (ES6) 引入 TypedArray 之前，JavaScript 语言没有读取或操作二进制数据流的机制。 Buffer 类被引入作为 Node.js API 的一部分，使其可以在 TCP 流和文件系统操作等场景中处理二进制数据流。 现在 TypedArray 已经被添加进 ES6 中，Buffer 类以一种更优与更适合 Node.js 用例的方式实现了 Uint8Array API。 Buffer 类的实例类似于整数数组，除了其是大小固定的、且在 V8 堆外分配物理内存。 ==Buffer 的大小在其创建时就已确定，且不能调整大小==。 Buffer 类在 Node.js 中是一个全局变量，因此无需 require(‘buffer’).Buffer。 C/C++ 插件 Node.js 插件是用 C 或 C++ 编写的动态链接共享对象，可以使用 require() 函数加载到 Node.js 中，且像普通的 Node.js 模块一样被使用。 它们主要用于为运行于 Node.js 的 JavaScript 和 C/C++ 库之间提供接口。 V8：Node.js 当前用于提供 JavaScript 实现的 C++ 库。 V8 提供了用于创建对象、调用函数等机制。 V8 的 API 文档主要在 v8.h 头文件中（Node.js 源代码中的 deps/v8/include/v8.h）==(V8在线文档) https://v8docs.nodesource.com/== libuv：实现了 Node.js 的事件循环、工作线程、与平台所有的的异步操作的 C 库。 它也是一个跨平台的抽象库，使所有主流操作系统中可以像 POSIX 一样访问常用的系统任务，比如与文件系统、socket、定时器和系统事件的交互。 libuv 还提供了一个类似 POSIX 多线程的线程抽象，可被用于强化更复杂的需要超越标准事件循环的异步插件。 鼓励插件开发者多思考如何通过在 libuv 的非阻塞系统操作、工作线程、或自定义的 libuv 线程中降低工作负载来避免在 I/O 或其他时间密集型任务中阻塞事件循环。 内置的 Node.js 库。Node.js 自身开放了一些插件可以使用的 C/C++ API。 其中最重要的是 node::ObjectWrap 类。 Node.js 包含一些其他的静态链接库，如 OpenSSL。 这些库位于 Node.js 源代码中的 deps/ 目录。 只有 V8 和 OpenSSL 符号是被 Node.js 有目的地再导出，并且通过插件被用于不同的场景 child_process (子进程) child_process 模块提供了衍生子进程的能力 Cluster CLI(命令行选项) Node.js 自带了各种命令行选项。 这些选项对外暴露了内置调试、多种执行脚本的方式、以及其他有用的运行时选项。 要在终端中查看本文档作为操作手册，运行 man node console (控制台) console 模块提供了一个简单的调试控制台，它与 Web 浏览器提供的 JavaScript 控制台的机制类似。 123console.time(label) //启动一个定时器，用以计算一个操作的持续时间。 定时器由一个唯一的 label 标识。 当调用 console.timeEnd() 时，可以使用相同的 label 来停止定时器，并以毫秒为单位将持续时间输出到 stdout。 定时器持续时间精确到亚毫秒。console.timeEnd(label) //停止之前通过调用 console.time() 启动的定时器，并打印结果到 stdoutconsole.trace(message[, ...args]) //打印字符串 &apos;Trace :&apos; 到 stderr ，并通过 util.format() 格式化消息与堆栈跟踪在代码中的当前位置。 Crypto (加密) debugger (调试器) Node.js 包含一个进程外的调试工具，可以通过基于 TCP 的协议和内置调试客户端访问。 要使用它，可以带上 debug 参数启动 Node.js，并带上需要调试的脚本的路径；然后会显示一个提示，表明成功启动调试器 DNS (域名服务器) Error 错误 Node.js 中运行的应用程序一般会遇到以下四类错误： 标准的 JavaScript 错误： : 当调用 eval() 失败时抛出。 : 当 JavaScript 语法错误时抛出。 : 当一个值不在预期范围内时抛出。 : 当使用未定义的变量时抛出。 : 当传入错误类型的参数时抛出。 : 当一个全局的 URI 处理函数被误用时抛出。 由底层操作系的触发的系统错误，例如试图打开一个不存在的文件、试图向一个已关闭的 socket 发送数据等 由应用程序代码触发的用户自定义的错误。 断言错误是错误的一个特殊的类，每当 Node.js 检测到一个不应该发生的异常逻辑时会触发。 这类错误通常由 assert 模块触发。 JavaScript 的 throw 机制的任何使用都会引起异常，异常必须使用 try / catch 处理，否则 Node.js 进程会立即退出。 ==开发者必须查阅各个方法的文档以明确在错误发生时这些方法是如何冒泡的。== events (事件) 大多数 Node.js 核心 API 都是采用惯用的异步事件驱动架构，其中某些类型的对象（称为触发器）会周期性地触发命名事件来调用函数对象（监听器）。 ==所有能触发事件的对象都是 EventEmitter 类的实例==。 这些对象开放了一个 eventEmitter.on() 函数，允许将一个或多个函数附加到会被对象触发的命名事件上。==当 EventEmitter 对象触发一个事件时，所有附加在特定事件上的函数都被同步地调用。== 当新的监听器被添加时，所有的 EventEmitter 会触发 ‘newListener’ 事件；当移除已存在的监听器时，则触发 ‘removeListener’。 每个事件默认可以注册最多 10 个监听器。可以通过一定方法设置。 12345678//此方法可用来自定义事件const EventEmitter = require('events');class MyEmitter extends EventEmitter &#123;&#125;const myEmitter = new MyEmitter();myEmitter.on('event', () =&gt; &#123; console.log('发生了一个事件！');&#125;);myEmitter.emit('event'); 异步与同步 EventListener 会按照监听器注册的顺序同步地调用所有监听器。 所以需要确保事件的正确排序且避免竞争条件或逻辑错误。监听器函数可以使用 setImmediate() 或 process.nextTick() 方法切换到异步操作模式. eventEmitter.on() //监听器会在==每次==触发命名事件时被调用 eventEmitter.once() //注册一个对于特定事件被调用==最多一次==的监听器 错误事件 当 EventEmitter 实例中发生错误时，会触发一个 ‘error’ 事件.为了防止 Node.js 进程崩溃，可以在 process 对象的 uncaughtException 事件上注册监听器 fs (文件系统) 文件 I/O 是由简单封装的标准 POSIX 函数提供的。 通过 require(‘fs’) 使用该模块。 ==所有的方法都有异步和同步的形式== 异步形式始终以完成==回调作为它最后一个参数==。 传给完成回调的参数取决于具体方法，但==第一个参数总是留给异常==。 如果操作成功完成，则第一个参数会是 null 或 undefined。 当使用同步形式时，任何异常都会被立即抛出。 可以使用 try/catch 来处理异常，或让它们往上冒泡。 同步和异步的比较 1234567891011//同步的方式const fs = require(&apos;fs&apos;); fs.unlinkSync(&apos;/tmp/hello&apos;);console.log(&apos;successfully deleted /tmp/hello&apos;);//异步方式const fs = require(&apos;fs&apos;); fs.unlink(&apos;/tmp/hello&apos;, (err) =&gt; &#123; if (err) throw err; console.log(&apos;successfully deleted /tmp/hello&apos;);&#125;); 异步方法不保证执行顺序 异步方法之间如果有执行顺序，则正确的方法是把回调链起来 强烈推荐开发者使用这些函数的异步版本。 同步版本会阻塞整个进程，直到它们完成 全局变量 12345* __dirname //当前模块的目录名。 等同于 __filename 的 path.dirname()* __filename //当前模块的文件名。 这是当前模块文件的解析后的绝对路径* exports //module.exports 的一个简短的引用* module //当前模块的引用。 具体地说，module.exports 用于定义一个模块导出什么，且通过 require() 引入* require.resolve() //使用内部的 require() 机制来查找模块的位置，但不会加载模块，只返回解析后的文件名 http Node.js 中的 HTTP 接口被设计为支持以往较难使用的协议的许多特性。 比如，大块编码的消息。 该接口从不缓存整个请求或响应，所以用户能够流化数据。 https HTTPS 是 HTTP 基于 TLS/SSL 的版本。在 Node.js 中，它被实现为一个独立的模块。 module (模块) Node.js 有一个简单的模块加载系统。 在 Node.js 中，文件和模块是一一对应的（每个文件被视为一个独立的模块）]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Express入门]]></title>
    <url>%2F2018%2F10%2F26%2F%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-Express%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[1中文网站：http://www.expressjs.com.cn/ 安装 方法1:命令行模式 123451. 确定已安装nodejs2. mkdir 项目名称；cd 项目名称3. npm init //为应用创建一个 package.json 文件,然后根据提示操作或者一路回车4. npm install express --save //安装 Express 并将其保存到依赖列表中5. 新建index.js文件进行编写 方法2:webstorm 121. npm install express -g //全局安装express2. webstorm中选择Node.js Expresss App,然后创建 方法3:Express 应用生成器 12341. 安装生成器：npm install express-generator -g2. 查看express 命令的用法：express -h3. 创建项目：express 项目名称4. 安装依赖：npm install 运行：node index.js 访问： http://localhost:3000/ 静态文件 通过 Express 内置的 express.static 可以方便地托管静态文件，例如图片、CSS、JavaScript 文件等 将静态资源文件所在的目录作为参数传递给 express.static 中间件就可以提供静态资源文件的访问了，如：app.use(express.static(‘public’))，这样public下面的文件就可以直接访问了，如：http://localhost:3000/images/kitten.jpg 通过为静态资源目录指定一个挂载路径的方式来实现访问的文件都存放在一个“虚拟（virtual）”目录（即目录根本不存在），如： 12* app.use(&apos;/static&apos;, express.static(&apos;public&apos;));* 访问：http://localhost:3000/static/images/kitten.jpg 常见问题 如何处理 404 1Express 执行了所有中间件、路由之后还是没有获取到任何输出。你所需要做的就是在其所有他中间件的后面添加一个处理 404 的中间件 如何设置一个错误处理器 1错误处理器中间件的定义和其他中间件一样，唯一的区别是 4 个而不是 3 个参数，即 (err, req, res, next) 如何渲染纯 HTML 文件 1无需通过 res.render() 渲染 HTML。你可以通过 res.sendFile() 直接对外输出 HTML 文件。如果你需要对外提供的资源文件很多，可以使用 express.static() 中间件 路由 学习网址：http://www.expressjs.com.cn/guide/routing.html 路由（Routing）是由一个 URI（或者叫路径）和一个特定的 HTTP 方法（GET、POST 等）组成的，涉及到应用如何响应客户端对某个网站节点的访问 每一个路由都可以有一个或者多个处理器函数，当匹配到路由时，这个/些函数将被执行 路由的定义由如下结构组成： 123456app.METHOD(PATH, HANDLER)其中，app 是一个 express 实例；METHOD 是某个 HTTP 请求方式中的一个；PATH 是服务器端的路径；HANDLER 是当路由匹配到时需要执行的函数 app.all() 是一个特殊的路由方法，没有任何 HTTP 方法与其对应，它的作用是对于一个路径上的所有请求加载中间件 12345//来自 “/secret” 的请求，不管使用 GET、POST、PUT等方法请求，句柄都会得到执行app.all(&apos;/secret&apos;, function (req, res, next) &#123; console.log(&apos;Accessing the secret section ...&apos;); next(); // pass control to the next handler&#125;); 路由路径：路由路径和请求方法一起定义了请求的端点，它可以是字符串、字符串模式或者正则表达式 路由句柄：可以为请求处理提供多个回调函数，其行为类似 中间件；路由句柄有多种形式，可以是一个函数、一个函数数组，或者是两者混合 12345678910111213app.get(&apos;/example/b&apos;, function (req, res, next) &#123; console.log(&apos;response will be sent by the next function ...&apos;); next();&#125;, function (req, res) &#123; res.send(&apos;Hello from B!&apos;);&#125;);//混合方式app.get(&apos;/example/d&apos;, [cb0, cb1], function (req, res, next) &#123; console.log(&apos;response will be sent by the next function ...&apos;); next();&#125;, function (req, res) &#123; res.send(&apos;Hello from D!&apos;);&#125;); 响应方法：下表中响应对象（res）的方法向客户端返回响应，终结请求响应的循环。如果在路由句柄中一个方法也不调用，来自客户端的请求会一直挂起 方法 描述 res.download() 提示下载文件。 res.end() 终结响应处理流程。 res.json() 发送一个 JSON 格式的响应。 res.jsonp() 发送一个支持 JSONP 的 JSON 格式的响应。 res.redirect() 重定向请求。 res.render() 渲染视图模板。 res.send() 发送各种类型的响应。 res.sendFile 以八位字节流的形式发送文件。 res.sendStatus() 设置响应状态代码，并将其以字符串形式作为响应体的一部分发送。 app.route()：可使用 app.route() 创建路由路径的链式路由句柄 12345678910app.route(&apos;/book&apos;) .get(function(req, res) &#123; res.send(&apos;Get a random book&apos;); &#125;) .post(function(req, res) &#123; res.send(&apos;Add a book&apos;); &#125;) .put(function(req, res) &#123; res.send(&apos;Update the book&apos;); &#125;); express.Router:可使用 express.Router 类创建模块化、可挂载的路由句柄。推荐。定于格式如下： 123456789101112131415161718192021//brid.jsvar express = require(&apos;express&apos;);var router = express.Router();// 该路由使用的中间件 可选router.use(function timeLog(req, res, next) &#123; console.log(&apos;Time: &apos;, Date.now()); next();&#125;); // 定义 about 页面的路由router.get(&apos;/about&apos;, function(req, res) &#123; res.send(&apos;About birds&apos;);&#125;);module.exports = router;//加载使用var birds = require(&apos;./birds&apos;);...app.use(&apos;/birds&apos;, birds); 中间件 Express 是一个自身功能极简，完全是由路由和中间件构成一个的 web 开发框架：从本质上来说，一个 Express 应用就是在调用各种中间件 中间件（Middleware） 是一个函数，它可以访问请求对象（request object (req)）, 响应对象（response object (res)）, 和 web 应用中处于请求-响应循环流程中的中间件，一般被命名为 next 的变量；如果当前中间件没有终结请求-响应循环，则必须调用 next() 方法将控制权交给下一个中间件，否则请求就会挂起 中间件的功能：执行任何代码；修改请求和响应对象；终结请求-响应循环；调用堆栈中的下一个中间件 Express 应用中间件种类： 应用级中间件 路由级中间件 错误处理中间件 内置中间件 第三方中间件 应用级中间件 应用级中间件绑定到 app 对象 使用 app.use() 和 app.METHOD()， 其中， METHOD 是需要处理的 HTTP 请求的方法，例如 GET, PUT, POST 等等，全部小写 中间件系统的路由句柄可以为路径定义多个路由 各路由之间通过next()逐次调用 调用过程中如果某个路由句柄已经终止了请求-响应循环，则后面的路由及其句柄不会执行，也不会报错 如果需要在中间件栈中跳过剩余中间件，调用 next(‘route’) 方法将控制权交给下一个路由； next(‘route’) 只对使用 app.VERB() 或 router.VERB() 加载的中间件有效 123456789101112131415// 一个中间件栈，处理指向 /user/:id 的 GET 请求app.get(&apos;/user/:id&apos;, function (req, res, next) &#123; // 如果 user id 为 0, 跳到下一个路由 if (req.params.id == 0) next(&apos;route&apos;); // 否则将控制权交给栈中下一个中间件 else next(); //&#125;, function (req, res, next) &#123; // 渲染常规页面 res.render(&apos;regular&apos;);&#125;);// 处理 /user/:id， 渲染一个特殊页面app.get(&apos;/user/:id&apos;, function (req, res, next) &#123; res.render(&apos;special&apos;);&#125;); 路由级中间件 路由级中间件和应用级中间件一样，只是它绑定的对象为 express.Router(),使用：var router = express.Router(); 路由级使用 router.use() 或 router.VERB() 加载 需要将路由挂载至应用，通过 app.use挂载 错误处理中间件 错误处理中间件有 4 个参数，定义错误处理中间件时必须使用这 4 个参数。即使不需要 next 对象，也必须在签名中声明它，否则中间件会被识别为一个常规中间件，不能处理错误 内置中间件 从 4.x 版本开始，, Express 已经不再依赖 Connect 了。除了 express.static, Express 以前内置的中间件现在已经全部单独作为模块安装使用了 express.static(root, [options]) 参数 root 指提供静态资源的根目录 可选的 options 参数拥有如下属性 属性 描述 类型 缺省值 dotfiles 是否对外输出文件名以点（.）开头的文件。可选值为 “allow”、“deny” 和 “ignore” String “ignore” etag 是否启用 etag 生成 Boolean true extensions 设置文件扩展名备份选项 Array [] index 发送目录索引文件，设置为 false 禁用目录索引 Mixed “index.html” lastModified 设置 Last-Modified 头为文件在操作系统上的最后修改日期。可能值为 true 或 false Boolean true maxAge 以毫秒或者其字符串格式设置 Cache-Control 头的 max-age 属性 Number 0 redirect 当路径为目录时，重定向至 “/” Boolean true setHeaders 设置 HTTP 头以提供文件的函数 Function 第三方中间件 通过使用第三方中间件从而为 Express 应用增加更多功能 安装所需功能的 node 模块，并在应用中加载，可以在应用级加载，也可以在路由级加载 在 Express 中使用模板引擎 需要在应用中进行如下设置才能让 Express 渲染模板文件： views, 放模板文件的目录，比如： app.set(‘views’, ‘./views’) view engine, 模板引擎，比如： app.set(‘view engine’, ‘jade’) 安装相应的模板引擎 npm 软件包:npm install jade --save 错误处理 在其他 app.use() 和路由调用后，最后定义错误处理中间件 next() 和 next(err) 类似于 Promise.resolve() 和 Promise.reject()。它们让您可以向 Express 发信号，告诉它当前句柄执行结束并且处于什么状态。next(err) 会跳过后续句柄，除了那些用来处理错误的句柄 调试 Express debug 有点像改装过的 console.log，不同的是，您不需要在生产代码中注释掉 debug。它会默认关闭，而且使用一个名为 DEBUG 的环境变量还可以打开 在启动应用时，设置 DEBUG 环境变量为 express:*，可以查看 Express 中用到的所有内部日志。webstorm中默认已设置 设置 DEBUG 的值为 express:router，只查看路由部分的日志；设置 DEBUG 的值为 express:application，只查看应用部分的日志 集成数据库 为 Express 应用添加连接数据库的能力，只需要加载相应数据库的 Node.js 驱动即可 MySQL npm install mysql --save 123456789101112131415var mysql = require(&apos;mysql&apos;);var connection = mysql.createConnection(&#123; host : &apos;localhost&apos;, user : &apos;dbuser&apos;, password : &apos;s3kreee7&apos;&#125;);connection.connect();connection.query(&apos;SELECT 1 + 1 AS solution&apos;, function(err, rows, fields) &#123; if (err) throw err; console.log(&apos;The solution is: &apos;, rows[0].solution);&#125;);connection.end(); MongoDB npm install mongoskin 123456var db = require(&apos;mongoskin&apos;).db(&apos;localhost:27017/animals&apos;);db.collection(&apos;mamals&apos;).find().toArray(function(err, result) &#123; if (err) throw err; console.log(result);&#125;); SQLite npm install sqlite3 1234567891011121314151617181920var sqlite3 = require(&apos;sqlite3&apos;).verbose();var db = new sqlite3.Database(&apos;:memory:&apos;);db.serialize(function() &#123; db.run(&apos;CREATE TABLE lorem (info TEXT)&apos;); var stmt = db.prepare(&apos;INSERT INTO lorem VALUES (?)&apos;); for (var i = 0; i &lt; 10; i++) &#123; stmt.run(&apos;Ipsum &apos; + i); &#125; stmt.finalize(); db.each(&apos;SELECT rowid AS id, info FROM lorem&apos;, function(err, row) &#123; console.log(row.id + &apos;: &apos; + row.info); &#125;);&#125;);db.close(); 中文API http://www.expressjs.com.cn/4x/api.html]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>Express</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[grunt入门]]></title>
    <url>%2F2018%2F10%2F26%2F%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-grunt%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[[toc] Grunt中文网：http://www.gruntjs.net/ 简介 Grunt和 Grunt 插件是通过 npm 安装并管理的，npm是 Node.js 的包管理器。Grunt配合Node.js有相应的版本要求，如：Grunt 0.4.x 必须配合Node.js &gt;= 0.8.0版本使用 奇数版本号的 Node.js 被认为是不稳定的开发版 Grunt-CLI 简介 安装：npm install -g grunt-cli 注意： 安装grunt-cli并不等于安装了 Grunt！ Grunt CLI的任务很简单：调用与Gruntfile在同一目录中 Grunt。这样带来的好处是，允许你在同一个系统上同时安装多个版本的 Grunt。 运行原理： 每次运行grunt 时，他就利用node提供的require()系统查找本地安装的 Grunt。正是由于这一机制，你可以在项目的任意子目录中运行grunt 。 如果找到一份本地安装的 Grunt，CLI就将其加载，并传递Gruntfile中的配置信息，然后执行你所指定的任务。 一份新的 Grunt项目一般需要在你的项目中添加两份文件：package.json 和 Gruntfile package.json: package.json字段全解：http://blog.csdn.net/woxueliuyun/article/details/39294375 被npm用于存储项目的元数据便将此项目发布为npm模块。你可以在此文件中列出项目依赖的grunt和Grunt插件，放置于devDependencies配置段内 package.json应当放置于项目的根目录中，与Gruntfile在同一目录中，并且应该与项目的源代码一起被提交 在目录(package.json所在目录)中运行npm install将依据package.json文件中所列出的每个依赖来自动安装适当版本的依赖 为项目添加package.json文件的方式： 大部分 grunt-init 模版都会自动创建特定于项目的package.json文件 npm init命令会创建一个基本的package.json文件 复制下面的案例，并根据需要做扩充，参考https://npmjs.org/doc/json.html 12345678910&#123; &quot;name&quot;: &quot;my-project-name&quot;, &quot;version&quot;: &quot;0.1.0&quot;, &quot;devDependencies&quot;: &#123; &quot;grunt&quot;: &quot;~0.4.1&quot;, &quot;grunt-contrib-jshint&quot;: &quot;~0.6.0&quot;, &quot;grunt-contrib-nodeunit&quot;: &quot;~0.2.0&quot;, &quot;grunt-contrib-uglify&quot;: &quot;~0.2.2&quot; &#125;&#125; Gruntfile: 此文件被命名为 Gruntfile.js 或 Gruntfile.coffee，用来配置或定义任务（task）并加载Grunt插件的 Gruntfile.js 或 Gruntfile.coffee 文件是有效的 JavaScript 或 CoffeeScript 文件，应当放在你的项目根目录中，和package.json文件在同一目录层级 Gruntfile由以下几部分构成：“wrapper” 函数；项目与任务配置；加载grunt插件和任务；自定义任务 &quot;wrapper&quot;函数: 每一份 Gruntfile（和grunt插件）都遵循同样的格式，你所书写的Grunt代码必须放在此函数内： 123module.exports = function(grunt) &#123; // Do grunt-related things in here&#125;; 项目与任务配置:大部分的Grunt任务都依赖某些配置数据，这些数据被定义在一个object内，并传递给grunt.initConfig方法，如package.json文件 加载grunt插件和任务:像 concatenation、[minification]、grunt-contrib-uglify 和 linting这些常用的任务（task）都已经以grunt插件的形式被开发出来了。只要在 package.json 文件中被列为dependency（依赖）的包，并通过npm install安装之后，都可以在Gruntfile中以简单命令的形式使用： 12// 加载能够提供&quot;uglify&quot;任务的插件。grunt.loadNpmTasks(&apos;grunt-contrib-uglify&apos;); 注意： grunt --help 命令将列出所有可用的任务。 自定义任务:通过定义 default 任务，可以让Grunt默认执行一个或多个任务 Gruntfile.js文件示例： 12345678910111213141516171819module.exports = function(grunt) &#123; // Project configuration. grunt.initConfig(&#123; pkg: grunt.file.readJSON(&apos;package.json&apos;), //package.json文件中的项目元数据（metadata）被导入到 Grunt 配置中 uglify: &#123; options: &#123; banner: &apos;/*! &lt;%= pkg.name %&gt; &lt;%= grunt.template.today(&quot;yyyy-mm-dd&quot;) %&gt; */\n&apos; &#125;, build: &#123; src: &apos;src/&lt;%= pkg.name %&gt;.js&apos;, dest: &apos;build/&lt;%= pkg.name %&gt;.min.js&apos; &#125; &#125; &#125;); // 加载包含 &quot;uglify&quot; 任务的插件。 grunt.loadNpmTasks(&apos;grunt-contrib-uglify&apos;); // 默认被执行的任务列表。 grunt.registerTask(&apos;default&apos;, [&apos;uglify&apos;]);&#125;; Gurnt CLI参数： 123456789101112131415--help, -h ==Display help text--base, -b ==Specify an alternate base path. By default, all file paths are relative to the Gruntfile.==Alternative to grunt.file.setBase(...)--no-color ==Disable colored output.--gruntfile ==Specify an alternate Gruntfile.==By default,grunt looks in the current or parent directories for the nearest Gruntfile.(js/coffee) file.--debug, -d ==Enable debugging mode for tasks that support it.--stack ==Print a stack trace when exiting with a warning or fatal error.--force, -f ==A way to force your way past warnings.Want a suggestion? Don&apos;t use this option, fix your code.--tasks ==Additional directory paths to scan for task and &quot;extra&quot; files.Alternative to grunt.loadTasks(...)--npm ==Npm-installed grunt plugins to scan for task and &quot;extra&quot; files.Alternative to grunt.loadNpmTasks(...)--no-write ==Disable writing files (dry run).--verbose, -v ==Verbose mode. A lot more information output.--version, -V ==Print the grunt version. Combine with --verbose for more info.--completion ==Output shell auto-completion rules. See the grunt-cli documentation for more information. 安装Gurnt和Gurnt插件 安装命令 npm install grunt --save-dev npm install grunt ==[@VERSION]== --save-dev Gurnt插件 http://gruntjs.com/plugins Grunt官方插件列表，其中带星号的为官方维护的插件 创建插件： 通过 npm install -g grunt-init 命令安装 grunt-init 。 通过 git clone git://github.com/gruntjs/grunt-init-gruntplugin.git ~/.grunt-init/gruntplugin 命令安装grunt插件模版。 在一个空的目录中执行 grunt-init gruntplugin 。 执行 npm install 命令以准备开发环境。 为你的插件书写代码。 执行 npm publish 命令将你创建的 Grunt 插件提发布npm 注意： grunt-contrib&quot; 命名空间保留给 Grunt 团队维护的task使用，请给你自己的task起一个合适名字，并且避免使用被保留的命名空间 Grunt默认隐藏error stack traces，但可–stack启用方便调试自己的task;在bash中可通过alias grunt='grunt --stack’创建别名默认记录下stack trace 存储任务文件：建议使用几个常用npm模块（例如 temporary、tmp）来调用操作系统级别的临时目录功能 避免改变当前工作目录：process.cwd() 默认包含gruntfile文件的目录被设置为当前工作目录。用户可在自己的gruntfile中通过grunt.file.setBase()改变改变当前工作目录，但是插件不应该改变它 path.resolve(‘foo’) 可以被用来获取’foo’ 相对于 Gruntfile 所在目录的绝对路径 Grunt常用插件 grunt-contrib-uglify：压缩js代码 grunt-contrib-concat：合并js文件 grunt-contrib-qunit：单元测试 grunt-contrib-jshint：js代码检查 grunt-contrib-watch：监控文件修改并重新执行注册的任务 Task Grunt就只支持两种任务：基本的Task以及MultiTasks 区别是基本的Task的任务配置只有一个，而MultiTasks则有多个。大多数的grunt插件任务都是MultiTasks Task的创建 grunt注册任务的格式: 1grunt.registerTask(taskName, [description, ] taskList) grunt默认任务: 12//如果运行Grunt时没有指定任何任务，它将自动执行&apos;jshint&apos;、&apos;qunit&apos;、&apos;concat&apos; 和 &apos;uglify&apos; 任务grunt.registerTask(&apos;default&apos;, [&apos;jshint&apos;, &apos;qunit&apos;, &apos;concat&apos;, &apos;uglify&apos;]); grunt任务带参数的格式: 1grunt.registerTask(&apos;dist&apos;, [&apos;concat:distArg&apos;, &apos;uglify:distArg&apos;]); 当一个基本任务执行时，Grunt并不会检查配置和环境 – 它仅仅执行指定的任务函数，并传递任何使用冒号分割的参数作为函数的参数 如果你的任务并没有遵循 “多任务” 结构，那就使用自定义任务，在一个任务内部，执行其他的任务，使用grunt.task.run(‘bar’, ‘baz’); 任务还可以依赖于其他任务的成功执行。注意 grunt.task.requires 并不会真正的运行其他任务，它仅仅检查其它任务是否已经执行，并且没有失败 Task的配置 Grunt的task配置都是在 Gruntfile 中的grunt.initConfig方法中指定的。此配置主要是以任务名称命名的属性，也可以包含其他任意数据。一旦这些代表任意数据的属性与任务所需要的属性相冲突，就将被忽略。 在一个任务配置中: options属性可以用来指定覆盖内置属性的默认。 每一个目标（target）中还可以拥有一个专门针对此目标（target）的options属性 目标（target）级的options将会覆盖任务级的options 123456789101112131415grunt.initConfig(&#123; concat: &#123; =================Task options: &#123; // 这里是任务级的Options，覆盖默认值 &#125;, foo: &#123; =================Target，并非子任务 options: &#123; // &quot;foo&quot; target options may go here, overriding task-level options. &#125;, &#125;, bar: &#123; // No options specified; this target will use task-level options. &#125;, &#125;,&#125;); 文件 由于大多的任务都是执行文件操作，Grunt有一个强大的抽象层用于声明任务应该操作哪些文件。这里有好几种定义src-dest(源文件-目标文件)文件映射的方式，均提供了不同程度的描述和控制操作方式。任何一种多任务（multi-task）都能理解下面的格式，所以你只需要选择满足你需求的格式就行。 详见：http://www.gruntjs.net/configuring-tasks 项目实战 Nodejs和CLI安装好之后，参考：http://www.bluesdream.com/blog/windows-installs-the-grunt-and-instructions.html mkdir testProject -&gt; cd testProject 创建package.json文件 package.json官方文档:https://docs.npmjs.com/json A: npm init ==自动创建pachage.json文件 B: 手动创建package.json文件，添加项目/模块的描述信息 安装Grunt和Grunt插件： 手动添加，修改package.json文件，然后执行npm install { “name”: “my-project”, “version”: “0.1.0”, “devDependencies”: { “grunt”: “~0.4.1”, “grunt-contrib-cssmin”: “~0.7.0” //其中&quot;~0.7.0&quot;代表安装该插件的某个特定版本，如果只需安装最新版本，可以改成&quot;*&quot; } } 自动安装： 其中–save-dev，表示将它作为你的项目依赖添加到package.json文件中devDependencies内 12npm install grunt --save-dev //安装最新版的Gruntnpm install grunt-contrib-cssmin --save-dev //安装我们所需要的插件 创建Gruntfile.js文件： 1234567891011121314151617181920212223242526module.exports = function(grunt) &#123; // 配置任务参数 grunt.initConfig(&#123; pkg: grunt.file.readJSON(&apos;package.json&apos;), cssmin: &#123; combine: &#123; files: &#123; &apos;css/release/compress.css&apos;: [&apos;css/*.css&apos;] // 指定合并的CSS文件 [&apos;css/base.css&apos;, &apos;css/global.css&apos;] &#125; &#125;, minify: &#123; options: &#123; keepSpecialComments: 0, /* 删除所有注释 */ banner: &apos;/* minified css file */&apos; &#125;, files: &#123; &apos;css/release/master.min.css&apos;: [&apos;css/master.css&apos;] &#125; &#125; &#125; &#125;); // 插件加载（加载 &quot;cssmin&quot; 模块） grunt.loadNpmTasks(&apos;grunt-contrib-cssmin&apos;); // 自定义任务：通过定义 default 任务，可以让Grunt默认执行一个或多个任务。 grunt.registerTask(&apos;default&apos;, [&apos;cssmin&apos;]);&#125;; 执行： grunt //执行配置中所有的任务 grunt cssmin //执行特定的任务 测试： 在项目文件夹中创建个子文件夹，命名为：CSS 在里面创建base.css和master.css，2个CSS文件，你可以随便写点内容在里面。 在命令行中执行grunt，看到如下提示说明执行成功： 12345Running &quot;cssmin:combine&quot; (cssmin) taskFile css/release/compress.css created.Running &quot;cssmin:minify&quot; (cssmin) taskFile css/release/master.min.css created.Done, without errors. JSDoc&amp;Grunt grunt-jsdoc是一个Grunt的插件。这个插件集成了JsDoc Toolkit 3，并且你能够通过配置Grunt任务来生成API文档 补充：grunt-jsdoc-plugin是同一个开发者，但是区别是grunt-jsdoc是基于JsDoc Toolkit 3而grunt-jsdoc-plugin是基于JsDoc Toolkit 2的 安装: 已安装好JAVA且配置好了Java环境变量 npm install grunt-jsdoc --save-dev //安装jsdoc插件 grunt-jsdoc的grunt任务配置 12345678910grunt.initConfig(&#123; jsdoc : &#123; dist : &#123; src: [&apos;src/*.js&apos;, &apos;test/*.js&apos;], options: &#123; destination: &apos;doc&apos; &#125; &#125; &#125;&#125;); 参数说明： 1234567src: 要自动生成API文档的源文件路径数组jsdoc: jsdoc的bin文件夹目录options: jsdoc单独使用的配置项destination： 必填，指定文档输出路径configure： jsdoc配置文件路径template： 文档模板路径private： 是否在文档中输出private成员，默认为true 更多参数：参考官方文档：Command-line arguments to JSDoc: http://usejsdoc.org/about-commandline.html Grunt.js和Gulp.js工作方式的区别 Grunt主要是以文件为媒介来运行它的工作流的，比如在Grunt中执行完一项任务后，会把结果写入到一个临时文件中，然后可以在这个临时文件内容的基础上执行其它任务，执行完成后又把结果写入到临时文件中，然后又以这个为基础继续执行其它任务…就这样反复下去。 在Gulp中，使用的是Nodejs中的stream(流)，首先获取到需要的stream，然后可以通过stream的pipe()方法把流导入到你想要的地方，比如Gulp的插件中，经过插件处理后的流又可以继续导入到其他插件中，当然也可以把流写入到文件中。所以Gulp是以stream为媒介的，它不需要频繁的生成临时文件，这也是Gulp的速度比Grunt快的一个原因]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gulp入门]]></title>
    <url>%2F2018%2F10%2F26%2F%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-gulp%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[[toc] 简介 gulpjs是一个前端构建工具，与gruntjs相比，gulpjs无需写一大堆繁杂的配置参数，API也非常简单，学习起来很容易，而且gulpjs使用的是nodejs中stream来读取和操作数据，其速度更快 123456Gulp官网 http://gulpjs.com/Gulp中文网 http://www.gulpjs.com.cn/Gulp中文文档 https://github.com/lisposter/gulp-docs-zh-cnGulp插件网 http://gulpjs.com/plugins/Awesome Gulp https://github.com/alferov/awesome-gulpStuQ-Gulp实战和原理解析 http://i5ting.github.io/stuq-gulp/ 工作流程 gulp的使用流程一般是这样子的： 通过gulp.src()方法获取到我们想要处理的文件流，22. 把文件流通过pipe方法导入到gulp的插件中 把经过插件处理后的流再通过pipe方法导入到gulp.dest()中 gulp.dest()方法则把流中的内容写入到文件中 ==注意：== 给gulp.dest()传入的路径参数，只能用来指定要生成的文件的目录，而不能指定生成文件的文件名，它生成文件的文件名使用的是导入到它的文件流自身的文件名。==生成的文件名是由导入到它的文件流决定的== 安装 gulp基于node.js，要通过nodejs的npm安装gulp，所以先要安装nodejs环境 全局方式：npm install -g gulp gulp的项目中单独安装一次：npm install gulp 安装的时候把gulp写进项目package.json文件的依赖中：npm install --save-dev gulp 在全局安装gulp后，还需要在项目中本地安装一次，是为了版本的灵活性，仅供参考 开始使用gulp 建立gulpfile.js文件 此时我们的目录结构是这样子的： 12345├── gulpfile.js├── node_modules│ └── gulp└── package.json~ 最简gulpfile.js: 1234var gulp = require(&apos;gulp&apos;);gulp.task(&apos;default&apos;,function()&#123; console.log(&apos;hello world&apos;);&#125;); 运行gulp任务 切换到存放gulpfile.js文件的目录 执行gulp命令:会执行任务名为default的默认任务 gulp task1:执行task1任务 gulpfile.js文件 全局配置config：当gulpfile.js太大时就不好维护了，此时可以将需要在gulpfile中引用的参数，放到这里，包括一些路径，功能的开关等，如： 12345678910111213module.exports = &#123; name : &apos;.....&apos;, devPath : &apos;.....&apos;, //项目根路径，根路径下可以包含多个项目 prodPath : &apos;....&apos;, //生产路径根路径 sassPath : &apos;.....&apos;, //SASS包含文件路径 rmHtmlWhitespace : false,//html中是否去除空格 webpackEntry : &#123; index : &apos;index.js&apos;//js合并 &#125;, server : &#123; port : 8088 &#125;&#125;; 意下这里使用了module.exports，这是nodejs的语法。在gulpfile中将会用require引用config。 1var config = require(&apos;./config&apos;);//加载项目配置 使用举例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//引入gulp，项目文件中安装的gulp的引入方式var gulp =require(&apos;gulp&apos;);//引入组件var jshint = require(&quot;gulp-jshint&quot;);var gutil = require(&quot;gulp-util&quot;);var sass= require(&quot;gulp-sass&quot;);var concat = require(&quot;gulp-concat&quot;);var uglify = require(&quot;gulp-uglify&quot;);var rename = require(&quot;gulp-rename&quot;);var path = require(&quot;path&quot;);var del = require(&quot;del&quot;);//你也许会想要在编译文件之前删除一些文件gulp.task(&apos;clean&apos;, function(cb) &#123; return del([&apos;build/**/*&apos;], cb);&#125;);//检查脚本gulp.task(&apos;lint&apos;,function () &#123; gulp.src(&apos;./src/javascript/**/*.js&apos;) .pipe(jshint()) .pipe(jshint.reporter(&apos;default&apos;));&#125;);//编译sass//sass 任务会编译scss/目录下的scss文件，并把编译完成的css文件保存到/css目录中gulp.task(&apos;sass&apos;,function () &#123; gulp.src(&quot;./src/scss/**/*.scss&quot;) .pipe(sass(&#123;outputStyle: &apos;compact&apos;&#125;)) .pipe(gulp.dest(&quot;./build/css&quot;));&#125;);//合并，压缩文件//scipts 任务会合并js 目录下的所有js文件并输出到dist目录中，然后gulp会重命名。压缩合并的文件，也输出到dist/目录gulp.task(&apos;scripts&apos;,function () &#123; gulp.src(&apos;./src/javascript/**/*.js&apos;) .pipe(concat(&apos;all.js&apos;)) .pipe(gulp.dest(&apos;./dest&apos;)) .pipe(rename(&quot;all.min.js&quot;)) .pipe(uglify()) .pipe(gulp.dest(&quot;./build&quot;))&#125;);//这时，我们创建了一个基于其他任务的default任务。//使用.run()方法关联和运行我们上面定义的任务，使用.watch() 方法去坚挺制定目录的文件变化,当有文件变化时，会运行回调定义的其他任务。gulp.task(&apos;default&apos;,function()&#123; //将你的默认的任务代码放在这里 gulp.run(&apos;lint&apos;,&apos;sass&apos;,&apos;scripts&apos;); //监听文件变化 gulp.watch(&quot;&quot;,function () &#123; gulp.run(&apos;lint&apos;,&apos;sass&apos;,&apos;scripts&apos;); &#125;);&#125;); gulp的API介绍 更多API介绍： http://www.gulpjs.com.cn/docs/api/ gulp.src() gulp.src()方法正是用来获取流的，但要注意这个流里的内容不是原始的文件流，而是一个虚拟文件对象流(Vinyl files)，这个虚拟文件对象中存储着原始文件的路径、文件名、内容等信息 1234gulp.src(globs[, options])* globs参数是文件匹配模式(类似正则表达式)，用来匹配文件路径(包括文件名)，当然这里也可以直接指定某个具体的文件路径。当有多个匹配模式时，该参数可以为一个数组* options为可选参数 当我们没有在gulp.src()方法中配置base属性时，base的默认值为通配符开始出现之前那部分路径，例如： 1gulp.src(&apos;app/src/**/*.css&apos;) //此时base的值为 app/src Gulp内部使用了node-glob模块来实现其文件匹配功能。我们可以使用下面这些特殊的字符来匹配我们想要的文件： 123456789* 匹配文件路径中的0个或多个字符，但不会匹配路径分隔符，除非路径分隔符出现在末尾** 匹配路径中的0个或多个目录及其子目录,需要单独出现，即它左右不能有其他东西了。如果出现在末尾，也能匹配文件。? 匹配文件路径中的一个字符(不会匹配路径分隔符)[...] 匹配方括号中出现的字符中的任意一个，当方括号中第一个字符为^或!时，则表示不匹配方括号中出现的其他字符中的任意一个，类似js正则表达式中的用法!(pattern|pattern|pattern) 匹配任何与括号中给定的任一模式都不匹配的?(pattern|pattern|pattern) 匹配括号中给定的任一模式0次或1次，类似于js正则中的(pattern|pattern|pattern)?+(pattern|pattern|pattern) 匹配括号中给定的任一模式至少1次，类似于js正则中的(pattern|pattern|pattern)+*(pattern|pattern|pattern) 匹配括号中给定的任一模式0次或多次，类似于js正则中的(pattern|pattern|pattern)*@(pattern|pattern|pattern) 匹配括号中给定的任一模式1次，类似于js正则中的(pattern|pattern|pattern) ==注意：== 不能在数组中的第一个元素中使用排除模式 使用举例： 12345//使用数组的方式来匹配多种文件gulp.src([&apos;js/*.js&apos;,&apos;css/*.css&apos;,&apos;*.html&apos;])gulp.src([*.js,&apos;!b*.js&apos;]) //匹配所有js文件，但排除掉以b开头的js文件gulp.src([&apos;!b*.js&apos;,*.js]) //不会排除任何文件，因为排除模式不能出现在数组的第一个元素中 gulp.dest() gulp.dest()方法是用来写文件的，其语法为： 1234gulp.dest(path[,options])* path为写入文件的路径* options为一个可选的参数对象，通常我们不需要用到 生成的文件路径是我们传入的path参数后面再加上gulp.src()中有通配符开始出现的那部分路径 gulp.task() gulp.task方法用来定义任务，内部使用的是Orchestrator，其语法为： 1234gulp.task(name[, deps], fn)* name 为任务名* deps 是当前定义的任务需要依赖的其他任务，为一个数组。当前定义的任务会在所有依赖的任务执行完毕后才开始执行。如果没有依赖，则可省略这个参数* fn 为任务函数，我们把任务要执行的代码都写在里面。该参数也是可选的。 使用举例： 123gulp.task(&apos;mytask&apos;, [&apos;array&apos;, &apos;of&apos;, &apos;task&apos;, &apos;names&apos;], function() &#123; //定义一个有依赖的任务 // Do something&#125;); 如果任务相互之间没有依赖，任务会按你书写的顺序来执行 如果有依赖的话则会先执行依赖的任务 如果某个任务所依赖的任务是异步的，就要注意了，gulp并不会等待那个所依赖的异步任务完成，而是会接着执行后续的任务 gulp.watch() gulp.watch()用来监视文件的变化，当文件发生变化后，我们可以利用它来执行相应的任务，例如文件压缩等。其语法为 1234gulp.watch(glob[, opts], tasks)* glob 为要监视的文件匹配模式，规则和用法与gulp.src()方法中的glob相同。* opts 为一个可选的配置对象，通常不需要用到* tasks 为文件变化后要执行的任务，为一个数组 1234567gulp.task(&apos;uglify&apos;,function()&#123; //do something&#125;);gulp.task(&apos;reload&apos;,function()&#123; //do something&#125;);gulp.watch(&apos;js/**/*.js&apos;, [&apos;uglify&apos;,&apos;reload&apos;]); 一些常用的gulp插件 自动加载插件pulp-load-plugins 这个插件能自动帮你加载package.json文件里的gulp插件 gulp-load-plugins是通过package.json文件来加载插件 gulp-load-plugins并不会一开始就加载所有package.json里的gulp插件，而是在我们需要用到某个插件的时候，才去加载那个插件 定义及启用 123var gulp = require(&apos;gulp&apos;);//加载gulp-load-plugins插件，并马上运行它var plugins = require(&apos;gulp-load-plugins&apos;)(); 使用举例： 1plugins.rename //gulp-rename插件的使用 重命名插件gulp-rename 123456gulp.task(&apos;rename&apos;, function () &#123; gulp.src(&apos;js/jquery.js&apos;) .pipe(uglify()) //压缩 .pipe(rename(&apos;jquery.min.js&apos;)) //会将jquery.js重命名为jquery.min.js .pipe(gulp.dest(&apos;js&apos;)); &#125;); js文件压缩插件gulp-uglify 12345678var gulp = require(&apos;gulp&apos;), uglify = require(&quot;gulp-uglify&quot;); gulp.task(&apos;minify-js&apos;, function () &#123; gulp.src(&apos;js/*.js&apos;) // 要压缩的js文件 .pipe(uglify()) //使用uglify进行压缩,更多配置请参考： .pipe(gulp.dest(&apos;dist/js&apos;)); //压缩后的路径&#125;); css文件压缩插件gulp-minify-css 12345678var gulp = require(&apos;gulp&apos;), minifyCss = require(&quot;gulp-minify-css&quot;); gulp.task(&apos;minify-css&apos;, function () &#123; gulp.src(&apos;css/*.css&apos;) // 要压缩的css文件 .pipe(minifyCss()) //压缩css .pipe(gulp.dest(&apos;dist/css&apos;));&#125;); html文件压缩插件gulp-minify-html 12345678var gulp = require(&apos;gulp&apos;), minifyHtml = require(&quot;gulp-minify-html&quot;); gulp.task(&apos;minify-html&apos;, function () &#123; gulp.src(&apos;html/*.html&apos;) // 要压缩的html文件 .pipe(minifyHtml()) //压缩 .pipe(gulp.dest(&apos;dist/html&apos;));&#125;); js代码检查插件 12345678var gulp = require(&apos;gulp&apos;), jshint = require(&quot;gulp-jshint&quot;); gulp.task(&apos;jsLint&apos;, function () &#123; gulp.src(&apos;js/*.js&apos;) .pipe(jshint()) .pipe(jshint.reporter()); // 输出检查结果&#125;); 文件合并插件gulp-concat 1234567891011var gulp = require(&apos;gulp&apos;), concat = require(&quot;gulp-concat&quot;); gulp.task(&apos;concat&apos;, function () &#123; gulp.src(&apos;js/*.js&apos;) //要合并的文件 .pipe(concat(&apos;all.js&apos;)) // 合并匹配到的js文件并命名为 &quot;all.js&quot; .pipe(gulp.dest(&apos;dist/js&apos;));&#125;);~~~ ## 图片压缩插件 var gulp = require(‘gulp’); var imagemin = require(‘gulp-imagemin’); var pngquant = require(‘imagemin-pngquant’); //png图片压缩插件 gulp.task(‘default’, function () { return gulp.src(‘src/images/*’) .pipe(imagemin({ progressive: true, use: [pngquant()] //使用pngquant来压缩png图片 })) .pipe(gulp.dest(‘dist’)); });]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack入门]]></title>
    <url>%2F2018%2F10%2F26%2F%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-webpack%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[[toc] 123http://webpack.org/https://github.com/webpack-china/webpack.js.orghttp://www.css88.com/doc/webpack2/ 简介 Webpack 是当下最热门的前端资源模块化管理和打包工具。它可以将许多松散的模块按照依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分隔，等到实际需要的时候再异步加载。通过 loader 的转换，任何形式的资源都可以视作模块，比如 CommonJs 模块、 AMD 模块、 ES6 模块、CSS、图片、 JSON、Coffeescript、 LESS 等。 前身叫browserify，缺点为只能转换js 概念 入口(Entry) webpack 将创建所有应用程序的依赖关系图表(dependency graph)。图表的起点被称之为入口起点(entry point) 入口起点告诉 webpack 从哪里开始，并遵循着依赖关系图表知道要打包什么 可以将应用程序的入口起点认为是根上下文(contextual root)或 app 第一个启动文件 出口(Output) 将所有的资源(assets)归拢在一起后，我们还需要告诉 webpack 在哪里打包我们的应用程序。webpack 的 output 属性描述了如何处理归拢在一起的代码(bundled code) 即使可以存在多个入口起点，但只指定一个输出配置 更多配置：http://www.css88.com/doc/webpack2/concepts/output/ 加载器(Loader) webpack 的目标是，让 webpack 聚焦于项目中的所有资源(asset)，而浏览器不需要关注考虑这些（这并不意味着资源(asset)都必须打包在一起）。webpack 把每个文件(.css, .html, .scss, .jpg, etc.) 都作为模块处理。而且 webpack 只理解 JavaScript webpack loader 会将这些文件转换为模块，而转换后的文件会被添加到依赖图表中 在 webpack 配置中定义 loader 时，要定义在 module.rules 中，而不是 rules webparck默认加载的是js，如果要加载如css，需要额外loader npm install style-loader css-loader -D 在webpack中，多个loader加载通过！连接，后面的“-loader可以省略”，如：require(“style!css!./mystyle.css”) 插件(Plugins) 想要使用一个插件， 需要 require() 它， 它添加到 plugins 数组中 多数插件可以通过选项(option)自定义 由于需要在一个配置中，多次使用一个插件，来针对不同的目的，因此你需要使用 new 来创建插件的实例，并且通过实例来调用插件 webpack 插件是一个具有 apply 属性的 JavaScript 对象。 apply 属性会被 webpack compiler 调用，并且 compiler 对象可在整个 compilation 生命周期访问 webpack.config.js示例： 12345678910111213141516171819202122const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;); //installed via npmconst webpack = require(&apos;webpack&apos;); //to access built-in pluginsconst path = require(&apos;path&apos;);const config = &#123; entry: &apos;./path/to/my/entry/file.js&apos;, output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;my-first-webpack.bundle.js&apos; &#125;, module: &#123; rules: [ &#123;test: /\.(js|jsx)$/, use: &apos;babel-loader&apos;&#125; ] &#125;, plugins: [ new webpack.optimize.UglifyJsPlugin(), new HtmlWebpackPlugin(&#123;template: &apos;./src/index.html&apos;&#125;) ]&#125;;module.exports = config; webpack安装及起步 安装 cnpm install webpack-cli -g//webpack的cli环境 cnpm install webpack-dev-server //webpack的自带服务器 运行： 开发环境：webpack 生产环境：webpack -p //会压缩 监听模式：webpack -w //自动编译 开启sourcemaps：webpack -d //方便调试 起步 123mkdir webpack-demo &amp;&amp; cd webpack-demonpm init -ynpm install --save-dev webpack 创建并编辑app/index.js 123456789101112import _ from &apos;lodash&apos;;function component () &#123; var element = document.createElement(&apos;div&apos;); /* 需要引入 lodash，下一行才能正常工作 */ element.innerHTML = _.join([&apos;Hello&apos;,&apos;webpack&apos;], &apos; &apos;); return element;&#125;document.body.appendChild(component()); 1npm install --save lodash 12345678&lt;html&gt; &lt;head&gt; &lt;title&gt;webpack 2 demo&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=&quot;dist/bundle.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 12webpack查看浏览器index.html页面内容：Hello webpack #代码拆分 分离资源，实现缓存资源和并行加载资源: 一个典型的应用程序，会依赖于许多提供框架/功能需求的第三方库代码。不同于应用程序代码，这些第三方库代码不会频繁修改 如果我们将这些库(library)中的代码，保留到与应用程序代码相独立的 bundle 上，我们就可以利用浏览器缓存机制，把这些文件长时间的缓存到用户的机器上 CSS分割 要通过webpack打包CSS，像任何其他模块一样将CSS导入JavaScript代码，并使用css-loader（它输出CSS作为JS模块），并可选地应用ExtractTextWebpackPlugin（它提取打包的CSS并输出CSS文件 导入 CSS import ‘bootstrap/dist/css/bootstrap.css’; 使用 css-loader:webpack.config.js中配置 css-loader 12345678module.exports = &#123; module: &#123; rules: [&#123; test: /\.css$/, use: &apos;css-loader&apos; &#125;] &#125;&#125; 使用 ExtractTextWebpackPlugin npm install --save-dev extract-text-webpack-plugin webpack.config.js中添加插件配置 1234567891011121314module.exports = &#123; module: &#123; rules: [&#123; test: /\.css$/,- use: &apos;css-loader&apos;+ use: ExtractTextPlugin.extract(&#123;+ use: &apos;css-loader&apos;+ &#125;) &#125;] &#125;,+ plugins: [+ new ExtractTextPlugin(&apos;styles.css&apos;),+ ]&#125; Libraries分割 默认会将库文件打包，可通过为库，如moment 添加一个单独的入口点并将其命名为 vendor 来缓解这一情况 1234567891011121314var path = require(&apos;path&apos;);module.exports = function(env) &#123; return &#123; entry: &#123; main: &apos;./index.js&apos;, vendor: &apos;moment&apos; &#125;, output: &#123; filename: &apos;[chunkhash].[name].js&apos;, path: path.resolve(__dirname, &apos;dist&apos;) &#125; &#125;&#125; 运行webpakc生成了两个 bundle，都包含lodash，所以还需要插件 CommonsChunkPlugin：它从根本上允许我们从不同的 bundle 中提取所有的公共模块，并且将他们加入公共 bundle 中。如果公共 bundle 不存在，那么它将会创建一个出来 1234567891011121314151617181920var webpack = require(&apos;webpack&apos;);var path = require(&apos;path&apos;);module.exports = function(env) &#123; return &#123; entry: &#123; main: &apos;./index.js&apos;, vendor: &apos;moment&apos; &#125;, output: &#123; filename: &apos;[chunkhash].[name].js&apos;, path: path.resolve(__dirname, &apos;dist&apos;) &#125;, plugins: [ new webpack.optimize.CommonsChunkPlugin(&#123; name: &apos;vendor&apos; // 指定公共 bundle 的名字。 &#125;) ] &#125;&#125; 以上完成之后，每次运行的vendor文件的hash码会改变，需在plugins配置如下： 12345plugins: [ new webpack.optimize.CommonsChunkPlugin(&#123; names: [&apos;vendor&apos;, &apos;manifest&apos;] // 指定公共 bundle 的名字 &#125;)] 将运行时代码提取到一个单独的 manifest 文件中就解决了 生产环境构建 自动方式 运行webpack -p (也可以运行 webpack --optimize-minimize --define process.env.NODE_ENV=&quot;‘production’&quot;, 他们是等效的). 它会执行如下步骤: 使用UglifyJsPlugin进行 JS文件压缩 运行LoaderOptionsPlugin 设置Node环境变量 手动方式: 为多环境配置Webpack 编写一个基本配置文件,把所有公用的功能放在里面。再编写特定环境的文件,使用’webpack-merge’来合并他们 base.js 12345678910111213141516171819202122232425262728293031323334353637383940414243module.exports = function() &#123; return &#123; entry: &#123; &apos;vendor&apos;: &apos;./src/vendor.ts&apos;, &apos;main&apos;: &apos;./src/main.ts&apos; &#125;, output: &#123; path: path.join(__dirname, &apos;/../dist/assets&apos;), filename: &apos;[name].bundle.js&apos;, publicPath: publicPath, sourceMapFilename: &apos;[name].map&apos; &#125;, resolve: &#123; extensions: [&apos;&apos;, &apos;.js&apos;, &apos;.json&apos;], modules: [path.join(__dirname, &apos;src&apos;), &apos;node_modules&apos;] &#125;, module: &#123; loaders: [&#123; test: /\.css$/, loaders: [&apos;to-string-loader&apos;, &apos;css-loader&apos;] &#125;, &#123; test: /\.(jpg|png|gif)$/, loader: &apos;file-loader&apos; &#125;, &#123; test: /\.(woff|woff2|eot|ttf|svg)$/, loader: &apos;url-loader?limit=100000&apos; &#125;], &#125;, plugins: [ new ForkCheckerPlugin(), new webpack.optimize.CommonsChunkPlugin(&#123; name: [&apos;polyfills&apos;, &apos;vendor&apos;].reverse() &#125;), new HtmlWebpackPlugin(&#123; template: &apos;src/index.html&apos;, chunksSortMode: &apos;dependency&apos; &#125;) ], &#125;;&#125; 使用’webpack-merge’合并这个基础配置和针对环境的特定的配置 prod.js (updated) 123456789101112131415161718192021222324252627282930const webpackMerge = require(&apos;webpack-merge&apos;);const commonConfig = require(&apos;./base.js&apos;);module.exports = function(env) &#123; return webpackMerge(commonConfig(), &#123; plugins: [ new webpack.LoaderOptionsPlugin(&#123; minimize: true, debug: false &#125;), new webpack.DefinePlugin(&#123; &apos;process.env&apos;: &#123; &apos;NODE_ENV&apos;: JSON.stringify(&apos;prod&apos;) &#125; &#125;), new webpack.optimize.UglifyJsPlugin(&#123; beautify: false, mangle: &#123; screw_ie8: true, keep_fnames: true &#125;, compress: &#123; screw_ie8: true &#125;, comments: false &#125;) ] &#125;)&#125; 缓存 这一块没有理解，需重新看 为了能够长期缓存webpack生成的静态资源: 使用[chunkhash]向每个文件添加一个依赖于内容的缓存杀手(cache-buster) 将webpack mainfest提取到一个单独的文件中去 对于一组依赖关系相同的资源，确保包含引导代码的入口起点模块(entrychunk)不会随时间改变它的哈希值 当需要在HTML中加载资源时，使用编译器统计信息(compiler stats)来获取文件名 生成模块清单(chunk manifest)的JSON内容，并在页面资源加载之前内联进HTML中去 将开发和生产模式的配置分开，并在开发模式中使用[name].js的文件名， 在生产模式中使用[name].[chunkhash].js文件名 为了在HTML中引用正确的文件,因为有hash生存文件名的一部分，可以使用下面这个插件，从webpack编译统计中提取： 1234567891011121314// webpack.config.jsconst path = require(&quot;path&quot;);module.exports = &#123; plugins: [ function() &#123; this.plugin(&quot;done&quot;, function(stats) &#123; require(&quot;fs&quot;).writeFileSync( path.join(__dirname, &quot;build&quot;, &quot;stats.json&quot;), JSON.stringify(stats.toJson())); &#125;); &#125; ]&#125;; 或者使用插件：https://www.npmjs.com/package/webpack-manifest-plugin 开发 调整你的文本编辑器 一些文本编辑器有“safe write”（安全写入）功能，并且默认启用。因此，保存文件后并不总是会导致 webpack 重新编译 WebStorm - 在 Preferences &gt; Appearance &amp; Behavior &gt; System Settings 中取消选中 Use “safe write” Source Maps 更多配置：http://www.css88.com/doc/webpack2/configuration/devtool/ 1devtool:&apos;source-map&apos; 选择一个工具 webpack 可以在 watch mode(监视模式)下使用。在这种模式下，webpack 将监视您的文件，并在更改时重新编译 webpack-dev-server 提供了一个易于部署的开发服务器，具有快速的实时重载（live reloading）功能 如果你已经有一个开发服务器并且需要完全的灵活性，可以使用 webpack-dev-middleware 作为中间件 webpack-dev-server npm install webpack-dev-server --save-dev webpack-dev-server --open webpack-dev-middleware webpack-dev-middleware 适用于基于链接的中间件环境（connect-based middleware stacks）。如果你已经有一个 Node.js 服务器或者你想要完全控制服务器，这将很实用 npm install express webpack-dev-middleware --save-dev 使用 123456789101112131415var express = require(&quot;express&quot;);var webpackDevMiddleware = require(&quot;webpack-dev-middleware&quot;);var webpack = require(&quot;webpack&quot;);var webpackConfig = require(&quot;./webpack.config&quot;);var app = express();var compiler = webpack(webpackConfig);app.use(webpackDevMiddleware(compiler, &#123; publicPath: &quot;/&quot; // 大部分情况下和 `output.publicPath`相同&#125;));app.listen(3000, function () &#123; console.log(&quot;Listening on port 3000!&quot;);&#125;); 根据你在 output.publicPath 和 output.filename 中设置的内容，你的 bundle 现在应该在 http://localhost:3000/bundle.js 中可以看到了 3. 默认情况下会使用watch mode。也可以使用 lazy mode，这使得 webpack 只在对入口点进行请求时再进行重新编译 1234app.use(webpackDevMiddleware(compiler, &#123; lazy: true, filename: &quot;bundle.js&quot; // Same as `output.filename` in most cases.&#125;)); 命令说明 1234* webpack-dev-server //默认8080* webpack-dev-server --port 8088* webpack-dev-server --inline //改变代码之后，自动刷新浏览器* webpack-dev-server --hot //热重载（局部更改） 此功能设置在webpack.config.js配置文件中如下： 1234devServer:&#123; port:8088, inline:true&#125; 也可以配置在package.json文件中，如： 12345&quot;scripts&quot;:&#123; &quot;dev&quot;:&quot;webpack-dev-server --port 8088 --inline --hot&quot;&#125;$ run npm dev resolve配置 配置扩展名,即代码中引用的时候可以省略后缀 123resolve:&#123; &quot;extensions&quot;:[&apos;&apos;,&apos;.js&apos;,&apos;.css&apos;,&apos;.json&apos;]&#125; 配合babel的使用 以下为react配合webpack的各种依赖库： cnpm install babel-core -D cnpm install babel-preset-es2015 --save-dev cnpm install babel-loader -D 设置js的转换 通过weback.config.js设置 123456789101112moudule:&#123; loaders:[ &#123; test:/\.js$/, loader:&apos;babel&apos;, exclude:/node_moudules/ &#125; ]&#125;,babel:&#123; &quot;presets&quot;:[&apos;es2015&apos;]&#125; 通过.babelrc文件，文件内容为： 123&#123; &quot;presets&quot;:[&quot;es2015&quot;]&#125; 配合react使用 前提：配合babel的配置已经安装 cnpm install babel-preset-react -D //babel的react预设，babel可以给其他用，react是支持的一种 cnpm install react-hot-loader 设置预设.babelrc 123456&#123; &quot;presets&quot;:[ [&quot;es2015&quot;], [&quot;react&quot;] ]&#125; 预设webpack.config]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue入门]]></title>
    <url>%2F2018%2F10%2F26%2F%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-vue%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[123https://cn.vuejs.org/https://vuejs.org/https://cn.vuejs.org/v2/api/ 简介 Vue.js是当下很火的一个JavaScript MVVM库，它是以数据驱动和组件化的思想构建的。相比于Angular.js，Vue.js提供了更加简洁、更易于理解的。是个人维护项目 Vue.js是数据驱动的，你无需手动操作DOM 通过一些特殊的HTML语法，将DOM和数据绑定起来。一旦你创建了绑定，DOM将和数据保持同步，每当变更了数据，DOM也会相应地更新 使用Vue.js时，也可以结合其他库一起使用，比如jQuery 使用Vue的过程就是定义MVVM各个组成部分的过程的过程 定义View 123&lt;div id=&quot;app&quot;&gt; &#123;&#123; message &#125;&#125;&lt;/div&gt; 定义Model，如： 123var exampleData = &#123; message: &apos;Hello World!&apos;&#125; 创建一个Vue实例或&quot;ViewModel&quot;，它用于连接View和Model 1234new Vue(&#123; el: &apos;#app&apos;, data: exampleData&#125;) Vue实例 构造器 每个 Vue.js 应用都是通过构造函数 Vue 创建一个 Vue 的根实例 启动的： 123var vm = new Vue(&#123; // 选项&#125;) 实例化 Vue 时，需要传入一个选项对象，它可以包含数据、模板、挂载元素、方法、生命周期钩子等选项,具体API查看：https://cn.vuejs.org/v2/api/ 属性和方法 每个 Vue 实例都会代理其 data 对象里所有的属性 ==只有这些被代理的属性是响应的== 如果在实例创建之后添加新的属性到实例上，它不会触发视图更新 Vue 实例暴露了一些有用的实例属性与方法。这些属性与方法都有前缀 $，以便与代理的 data 属性区分 实例生命周期 每个 Vue 实例在被创建之前都要经过一系列的初始化过程 Vue.js的常用指令 Vue.js的指令是以v-开头的，它们作用于HTML元素，指令提供了一些特殊的特性，将指令绑定在元素上时，指令会为绑定的目标元素添加一些特殊的行为，我们可以将指令看作特殊的HTML特性（attribute） 用 key 管理可复用的元素:添加一个具有唯一值的 key 属性,来声明“这两个元素是完全独立的——不要复用它们” Vue.js提供了一些常用的内置指令，接下来我们将介绍以下几个内置指令： v-if指令 条件渲染指令，它根据表达式的真假来删除和插入元素 1&lt;h1 v-if=&quot;age &gt;= 25&quot;&gt;Age: &#123;&#123; age &#125;&#125;&lt;/h1&gt; v-show指令 控制显示／隐藏，true／false 和v-if指令不同的是，使用v-show指令的元素始终会被渲染到HTML，它只是简单地为元素设置CSS的style属性 1&lt;h1 v-show=&quot;age &gt;= 25&quot;&gt;Age: &#123;&#123; age &#125;&#125;&lt;/h1&gt; v-else指令 可以用v-else指令为v-if或v-show添加一个“else块” v-else元素必须立即跟在v-if或v-show元素的后面——否则它不能被识别 12&lt;h1 v-show=&quot;name.indexOf(&apos;keep&apos;) &gt;= 0&quot;&gt;Name: &#123;&#123; name &#125;&#125;&lt;/h1&gt;&lt;h1 v-else&gt;Sex: &#123;&#123; sex &#125;&#125;&lt;/h1&gt; v-for指令 12345678&lt;ul&gt; &lt;li v-for=&quot;value in json&quot;&gt; &#123;&#123;value&#125;&#125; &#123;&#123;$index&#125;&#125; &#123;&#123;$key&#125;&#125; &lt;/li&gt; &lt;li v-for=&quot;(k,v) in json&quot;&gt; &#123;&#123;k&#125;&#125; &#123;&#123;v&#125;&#125; &#123;&#123;$index&#125;&#125; &#123;&#123;$key&#125;&#125; &lt;/li&gt;&lt;/ul&gt; v-bind指令 如果属性中要绑定Vue数据，最好用绑定的方式 v-bind指令可以在其名称后面带一个参数，中间放一个冒号隔开，这个参数通常是HTML元素的特性（attribute） 1&lt;img v-bind:src=&quot;&#123;&#123;url&#125;&#125; alt=&quot;&quot;/&gt;&quot;//后台不会报错误，不绑定后台会报错，界面不影响 class 用法一：其值为数组形式，数组中的值为Vue的data中定义的属性，而vue中属性对应的值为真正的css样式 12345678910111213.astyle&#123; color:red&#125;.bstyle&#123; background-color:bule&#125;&lt;script&gt; new Vue()&#123; data:&#123; a:&quot;astyle&quot;, b:&quot;bstyle&quot; &#125; &#125;&lt;/script&gt;&lt;div id=&quot;box&quot;&gt; &lt;strong :class=&quot;[a,b]&quot;&gt;测试文字&lt;/strong&gt;&lt;/div&gt; 方式二：其值为json格式，json的key为真正的css样式名称，value为true/false／data中的属性 123&lt;div id=&quot;box&quot;&gt; &lt;strong :class=&quot;&#123;astyle:true,bstyle:a&#125;&quot;&gt;测试文字&lt;/strong&gt;&lt;/div&gt; 方式三：class的值直接是data的一个json数据 1234567891011new Vue()&#123; data:&#123; jsonData:&#123; astyle:true, bstyle:false &#125; &#125;&#125;&lt;div id=&quot;box&quot;&gt; &lt;strong :class=&quot;jsonData&quot;&gt;测试文字&lt;/strong&gt;&lt;/div&gt; style：复合样式采用的是驼峰命名法 方法一： 1&lt;strong :style=&quot;color:red&quot;&gt;文字&lt;/strong&gt; 方式二： 123456789new Vue()&#123; data:&#123; astyle:&#123;color:&apos;red&apos;&#125;, bstyle:&#123;backgroudColor:&apos;blue&apos;&#125; &#125;&#125;&lt;div id=&quot;box&quot;&gt; &lt;strong :style=&quot;[astyle,bstyle]]&quot;&gt;测试文字&lt;/strong&gt;&lt;/div&gt; 方式三：官方推荐 1234567891011new Vue()&#123; data:&#123; jsonData:&#123; color:&apos;red&apos;, backgroudColor:&apos;blue&apos; &#125; &#125;&#125;&lt;div id=&quot;box&quot;&gt; &lt;strong :style=&quot;jsonData&quot;&gt;测试文字&lt;/strong&gt;&lt;/div&gt; v-on指令 用于监听DOM事件 123456789&lt;script&gt;new Vue()&#123; methods:&#123; show:function()&#123;alert(124);&#125; &#125;&#125;&lt;/script&gt;&lt;input type=&quot;button&quot; value=&quot;弹框&quot; v-on:click=&quot;show()&quot; ==知识点==：v-bind指令可以缩写为一个冒号，v-on指令可以缩写为@符号 v-model 表单元素的双向绑定，它会根据控件类型自动选取正确的方法来更新元素 12&lt;input v-model=&quot;message.trim&quot; placeholder=&quot;edit me&quot;&gt;&lt;p&gt;Message is: &#123;&#123; message &#125;&#125;&lt;/p&gt; .number:将用户的输入值转为 Number 类型（如果原值的转换结果为 NaN 则返回原值）,如： .trim：自动过滤用户输入的首尾空格 .lazy：在默认情况下， v-model 在 input 事件中同步输入框的值与数据 ，但可以添加一个修饰符 lazy ，从而转变为在 change 事件中同步 事件 事件修饰符 123456789101112&lt;!-- 阻止单击事件冒泡 --&gt;&lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;&lt;!-- 提交事件不再重载页面 --&gt;&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;&lt;!-- 修饰符可以串联 --&gt;&lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;&lt;!-- 只有修饰符 --&gt;&lt;form v-on:submit.prevent&gt;&lt;/form&gt;&lt;!-- 添加事件侦听器时使用事件捕获模式 --&gt;&lt;div v-on:click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt;&lt;!-- 只当事件在该元素本身（而不是子元素）触发时触发回调 --&gt;&lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt; 事件冒泡阻止 传递事件$event，ev.cancleBubble=true; @click.stop 默认行为 如网页中添加了右键事件后，系统还有默认右键事件 传递事件$event，ev.preventDefault(); @contextmenu.prevent 键盘事件 传递事件$event，ev.keyCode，判断后进行操作 @keyup.键值，如：@keyup.13 @keyup.键盘键面值，如：@keyup.enter 按键修饰符 1&lt;input v-on:keyup.13=&quot;submit&quot;&gt; 全部的按键别名： 123456789.enter.tab.delete (捕获 “删除” 和 “退格” 键).esc.space.up.down.left.right 模版语法 msg类似为js变量,Mustache中可以进行JS编程，如申明变量，条件判断等 123* 数据绑定最常见的形式就是使用 “Mustache” 语法（双大括号）的文本插值：&#123;&#123;msg&#125;&#125; 数据更新模版变化* &#123;&#123;*msg&#125;&#125; 只绑定一次* &#123;&#123;&#123;msg&#125;&#125;&#125; HTML转义，html语法会翻译 计算属性 在模板中放入太多的逻辑会让模板过重且难以维护，应当考虑使用计算属性 可以像绑定普通属性一样在模板中绑定计算属性 计算属性是基于它们的依赖进行缓存的。计算属性只有在它的相关依赖发生改变时才会重新求值,==这也是计算属性和methods的区别，需依据具体情况使用== 123456789101112131415161718&lt;div id=&quot;example&quot;&gt; &lt;p&gt;Original message: &quot;&#123;&#123; message &#125;&#125;&quot;&lt;/p&gt; &lt;p&gt;Computed reversed message: &quot;&#123;&#123; reversedMessage &#125;&#125;&quot;&lt;/p&gt;&lt;/div&gt;var vm = new Vue(&#123; el: &apos;#example&apos;, data: &#123; message: &apos;Hello&apos; &#125;, computed: &#123; // a computed getter reversedMessage: function () &#123; // `this` points to the vm instance return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125; &#125;&#125;); 计算属性默认只有 getter ，不过在需要时你也可以提供一个 setter 12345678910111213141516computed: &#123; fullName: &#123; // getter get: function () &#123; return this.firstName + &apos; &apos; + this.lastName &#125;, // setter set: function (newValue) &#123; var names = newValue.split(&apos; &apos;) this.firstName = names[0] this.lastName = names[names.length - 1] &#125; &#125;&#125;在运行 vm.fullName = &apos;John Doe&apos; 时， setter 会被调用 过滤器 过滤模版数据 1&#123;&#123;msg|filterA 参数|filterB 参数|...&#125;&#125; 系统默认提供过滤器，如： 123456* &#123;&#123;&apos;welcome&apos;|uppercase&#125;&#125;* &#123;&#123;&apos;welcome&apos;|lowercase&#125;&#125;* &#123;&#123;&apos;welcome&apos;|capitalize&#125;&#125;* &#123;&#123;&apos;welcome&apos;|currency&#125;&#125;* &#123;&#123;&apos;welcome&apos;|currency &quot;$&quot;&#125;&#125; //传参* &#123;&#123; message | filterA(&apos;arg1&apos;, arg2) &#125;&#125; //穿参 交互 Vue本身不支持Ajax框架，需引入官方库vue-resource,支持get、post、jsonp get 1234567891011121314151617methods:&#123; getFun:function()&#123; this.$http.get(&quot;a.txt&quot;).then(function(res)&#123; console.log(res.data); &#125;,function(res)&#123; console.log(res.status); &#125;); &#125;, //传递参数 get2Fun:function()&#123; this.$http.get(&quot;a.php&quot;,&#123;a:1,b:2&#125;&#125;).then(function(res)&#123; console.log(res.data); &#125;,function(res)&#123; console.log(res.status); &#125;); &#125;&#125; post 123456789methods:&#123; postFun:function()&#123; this.$http.post(&quot;a.php&quot;,&#123;a:1,b:2&#125;,&#123;emulateJSON:true&#125;).then(function(res)&#123; console.log(res.data); &#125;,function(res)&#123; console.log(res.status); &#125;); &#125;&#125; jsonp 123456789101112131415methods:&#123; postFun:function()&#123; this.$http.jsonp( &quot;https://www.baidu....&quot;, &#123;a:1&#125;, &#123;jsonp:&apos;&apos;cb&apos;&apos;&#125;//callback 名字 ) .then(function(res)&#123; console.log(res.data); &#125;,function(res)&#123; console.log(res.status); &#125; ); &#125;&#125; 组件 使用组件 要注册一个全局组件，你可以使用 Vue.component(tagName, options)。 例如： 123Vue.component(&apos;my-component&apos;, &#123; // 选项&#125;) Vue.js建议自定义标签名：==小写，并且包含一个短杠== 要确保在初始化根实例 之前 注册了组件 局部注册 12345678910var Child = &#123; template: &apos;&lt;div&gt;A custom component!&lt;/div&gt;&apos;&#125;new Vue(&#123; // ... components: &#123; // &lt;my-component&gt; 将只在父模板可用 &apos;my-component&apos;: Child &#125;&#125;) 组件通信 在 Vue.js 中，父子组件的关系可以总结为 props down, events up 。父组件通过 props 向下传递数据给子组件，子组件通过 events 给父组件发送消息 Prop 123456789Vue.component(&apos;child&apos;, &#123; // 声明 props props: [&apos;myMessage&apos;], // 就像 data 一样，prop 可以用在模板内 // 同样也可以在 vm 实例中像 “this.myMessage” 这样使用 template: &apos;&lt;span&gt;&#123;&#123; myMessage &#125;&#125;&lt;/span&gt;&apos;&#125;)&lt;child my-message=&quot;hello!&quot;&gt;&lt;/child&gt; //传入属性值 HTML 特性是不区分大小写的。所以，当使用的不是字符串模版，camelCased (驼峰式) 命名的 prop 需要转换为相对应的 kebab-case (短横线隔开式) 命名 每次父组件更新时，子组件的所有 prop 都会更新为最新值,不应该在子组件内部改变 prop,如果有改变的需要，可通过A.定义一个局部变量;B.定义一个计算属性 Prop验证 12345678910111213141516171819202122232425262728293031Vue.component(&apos;example&apos;, &#123; props: &#123; // 基础类型检测 （`null` 意思是任何类型都可以） propA: Number, // 多种类型 propB: [String, Number], // 必传且是字符串 propC: &#123; type: String, required: true &#125;, // 数字，有默认值 propD: &#123; type: Number, default: 100 &#125;, // 数组／对象的默认值应当由一个工厂函数返回 propE: &#123; type: Object, default: function () &#123; return &#123; message: &apos;hello&apos; &#125; &#125; &#125;, // 自定义验证函数 propF: &#123; validator: function (value) &#123; return value &gt; 10 &#125; &#125; &#125;&#125;) type 可以：String/Number/Boolean/Function/Object/Array 自定义事件 每个 Vue 实例都实现了事件接口(Events interface)，即： 使用 $on(eventName) 监听事件 使用 $emit(eventName) 触发事件 123456789101112131415161718192021222324252627282930&lt;div id=&quot;counter-event-example&quot;&gt; &lt;p&gt;&#123;&#123; total &#125;&#125;&lt;/p&gt; &lt;button-counter v-on:increment=&quot;incrementTotal&quot;&gt;&lt;/button-counter&gt;&lt;/div&gt;Vue.component(&apos;button-counter&apos;, &#123; template: &apos;&lt;button v-on:click=&quot;increment&quot;&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;&apos;, data: function () &#123; return &#123; counter: 0 &#125; &#125;, methods: &#123; increment: function () &#123; this.counter += 1 this.$emit(&apos;increment&apos;) &#125; &#125;,&#125;)new Vue(&#123; el: &apos;#counter-event-example&apos;, data: &#123; total: 0 &#125;, methods: &#123; incrementTotal: function () &#123; this.total += 1 &#125; &#125;&#125;) 非父子组件通信 1234567var bus = new Vue()// 触发组件 A 中的事件bus.$emit(&apos;id-selected&apos;, 1)// 在组件 B 创建的钩子中监听事件bus.$on(&apos;id-selected&apos;, function (id) &#123; // ...&#125;) 使用Slot分发内容 为了让组件可以组合，我们需要一种方式来混合父组件的内容与子组件自己的模板，这个过程被称为 内容分发 使用特殊的 元素作为原始内容的插槽 父组件模板的内容在父组件作用域内编译；子组件模板的内容在子组件作用域内编译 12&lt;!-- 无效,试图在父组件模板内将一个指令绑定到子组件的属性/方法 --&gt;&lt;child-component v-show=&quot;someChildProperty&quot;&gt;&lt;/child-component&gt; 如果要绑定作用域内的指令到一个组件的根节点，你应当在组件自己的模板上做： 123456789Vue.component(&apos;child-component&apos;, &#123; // 有效，因为是在正确的作用域内 template: &apos;&lt;div v-show=&quot;someChildProperty&quot;&gt;Child&lt;/div&gt;&apos;, data: function () &#123; return &#123; someChildProperty: true &#125; &#125;&#125;)]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CommonJS规范&AMD&CMD]]></title>
    <url>%2F2018%2F10%2F26%2F%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-2018-10-26-CommonJS%E8%A7%84%E8%8C%83-AMD-CMD%2F</url>
    <content type="text"><![CDATA[浏览器端的js和服务器端js都主要做了哪些事 服务器端JS 浏览器端JS 相同的代码需要多次执行 代码需要从一个服务器端分发到多个客户端执行 CPU和内存资源是瓶颈 带宽是瓶颈 加载时从磁盘中加载 加载时需要通过网络加载 CommonJS是主要为了JS在==后端的表现制定==的，他是不适合前端的;AMD(异步模块定义)出现了，它就主要==为前端JS的表现制定规范== CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。 AMD规范则是非同步加载模块，允许指定回调函数。 由于Node.js主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以CommonJS规范比较适用。但是，如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用AMD规范 [toc] CommonJS CommonJS规范: http://javascript.ruanyifeng.com/nodejs/module.html CommonJS模块的特点如下: 123所有代码都运行在模块作用域，不会污染全局作用域。模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。模块加载的顺序，按照其在代码中出现的顺序 CommonJS是一种规范，NodeJS是这种规范的实现 JavaScript是一个强大面向对象语言，它有很多快速高效的解释器。官方JavaScript标准定义的API是为了构建基于浏览器的应用程序。然而，并没有定于一个用于更广泛的应用程序的标准库。 CommonJS API定义很多普通应用程序（主要指非浏览器的应用）使用的API，从而填补了这个空白。它的终极目标是提供一个类似Python，Ruby和Java标准库。这样的话，开发者可以使用CommonJS API编写==应用程序==，然后这些应用可以运行在不同的JavaScript解释器和不同的主机环境中。 CommonJS定义的模块分为:模块引用(require)；模块定义(exports)；模块标识(module) require require命令用于加载文件，后缀名默认为.js 每个模块中有一个自由变量require，它是一个方法，这个方法接受一个参数，即模块的唯一ID。 CommonJS模块的加载机制是，输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值 require根据外部模块ID，返回该模块输出的API。如果外部模块被required的时候还没有执行完，require至少应改返回该模块的exports（另一个自由变量）。如果必需的模块不存在，require方法应该抛出一个异常。 require可以有一个main属性，属性值要么为undefined，要么等于module（另一个自由变量）;可以用来判断模块是直接执行，还是被调用执行。直接执行的时候（node module.js），require.main属性指向模块本身;调用执行的时候（通过require加载该脚本执行），==require.main === module== 返回false require可以有一个paths属性，属性值为由路径字符串组成的数组，路径按优先级从高到低的顺序排列 根据参数的不同格式，require命令去不同路径寻找模块文件 123456* 如果参数字符串以“/”开头，则表示加载的是一个位于绝对路径的模块文* 如果参数字符串以“./”开头，则表示加载的是一个位于相对路径的模块文件* 如果参数字符串不以“./“或”/“开头，则表示加载的是一个默认提供的核心模块或者一个位于各级node_modules目录的已安装模块* 如果参数字符串不以“./“或”/“开头，而且是一个路径如果参数字符串不以“./“或”/“开头，而且是一个路径，比如require(&apos;example-module/path/to/file&apos;)，则将先找到example-module的位置，然后再以它为参数，找到后续路径。* 如果指定的模块文件没有发现，Node会尝试为文件名添加.js、.json、.node后，再去搜索* 如果想得到require命令加载的确切文件名，使用require.resolve()方法 exports 每个模块中还有一个自由变量exports，它是一个对象，==模块对外输出的API就绑定在这个对象上==。而且==exports是模块对外输出API的唯一途径==。Node为每个模块提供一个exports变量，指向module.exports 不能直接将exports变量指向一个值，因为这样等于切断了exports与module.exports的联系 module CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。==加载某个模块，其实是加载该模块的module.exports属性== 每个模块中必须有一个自由变量module，它是对象。这个对象有一个id属性，表示该模块的id，同时应该是只读属性。 module对象可以有一个uri属性，表示这个模块被加载的来源。 每个模块内部，都有一个module对象，代表当前模块。它有以下属性: 123456module.id 模块的识别符，通常是带有绝对路径的模块文件名。module.filename 模块的文件名，带有绝对路径。module.loaded 返回一个布尔值，表示模块是否已经完成加载。module.parent 返回一个对象，表示调用该模块的模块。module.children 返回一个数组，表示该模块要用到的其他模块。module.exports 表示模块对外输出的值 目录的加载规则 通常，我们会把相关的文件会放在一个目录里面，便于组织。这时，最好为该目录设置一个入口文件，让require方法可以通过这个入口文件，加载整个目录 在目录中放置一个package.json文件，并且将入口文件写入main字段 如果package.json文件没有main字段，或者根本就没有package.json文件，则会加载该目录下的index.js文件或index.node文件 模块的缓存 第一次加载某个模块时，Node会缓存该模块。以后再加载该模块，就直接从缓存取出该模块的module.exports属性 所有缓存的模块保存在require.cache之中，如果想删除模块的缓存，可以像下面这样写 1234567// 删除指定模块的缓存delete require.cache[moduleName];// 删除所有模块的缓存Object.keys(require.cache).forEach(function(key) &#123; delete require.cache[key];&#125;) AMD AMD就只有一个接口：define(id?,dependencies?,factory); RequireJS就是实现了AMD规范 CMD 大名远扬的玉伯写了seajs，就是遵循他提出的CMD规范，与AMD蛮相近的，不过用起来感觉更加方便些，最重要的是中文版]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[middleware]]></title>
    <url>%2F2018%2F10%2F26%2Freact-rn-2018-10-26-middleware%2F</url>
    <content type="text"><![CDATA[https://zhuanlan.zhihu.com/p/20597452 简介 middleware 提供了一个分类处理 action 的机会，在 middleware 中你可以检阅每一个流过的 action，挑选出特定类型的 action 进行相应操作，给你一次改变 action 的机会 redux 的 middleware 是为了增强 dispatch 而出现的 redux 提供了 applyMiddleware 这个 api 来加载 middleware 四步理解 middleware 机制 12345var middlewareAPI = &#123; getState: store.getState, dispatch: (action) =&gt; dispatch(action)&#125;;chain = middlewares.map(middleware =&gt; middleware(middlewareAPI)); 函数式编程思想设计 middleware middleware 的设计有点特殊，是一个层层包裹的匿名函数，这其实是函数式编程中的柯里化 curry，一种使用匿名单参数函数来实现多参数函数的方法。applyMiddleware 会对 logger 这个 middleware 进行层层调用，动态地对 store 和 next 参数赋值 柯里化的 middleware 结构好处在于： 易串联，柯里化函数具有延迟执行的特性，通过不断柯里化形成的 middleware 可以累积参数，配合组合（ compose，函数式编程的概念，Step. 2 中会介绍）的方式，很容易形成 pipeline 来处理数据流 共享store，在 applyMiddleware 执行过程中，store 还是旧的，但是因为闭包的存在，applyMiddleware 完成后，所有的 middlewares 内部拿到的 store 是最新且相同的 给 middleware 分发 store 创建一个普通的 store 通过如下方式： 12345//applyMiddleware 函数陆续获得了三个参数//第一个是 middlewares 数组，[mid1, mid2, mid3, ...]//第二个 next 是 Redux 原生的 createStore//最后一个是 reducerlet newStore = applyMiddleware(mid1, mid2, mid3, ...)(createStore)(reducer, null); 组合串联 middlewares 1dispatch = compose(...chain)(store.dispatch); compose 是函数式编程中的组合，compose 将 chain 中的所有匿名函数，[f1, f2, … , fx, …, fn]，组装成一个新的函数，即新的 dispatch，当新 dispatch 执行时，[f1, f2, … , fx, …, fn]，从右到左依次执行（ 所以顺序很重要） 在 middleware 中调用 dispatch 在middleware 中调用 store.dispatch() 和在其他任何地方调用效果是一样的，而在 middleware 中调用 next()，效果是进入下一个 middleware]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redux-thunk]]></title>
    <url>%2F2018%2F10%2F26%2Freact-rn-2018-10-26-redux-thunk%2F</url>
    <content type="text"><![CDATA[简介 redux-thunk 是一个比较流行的 redux 异步 action 中间件，比如 action 中有 setTimeout 或者通过 fetch 通用远程 API 这些场景，那么久应该使用 redux-thunk 了 redux-thunk 帮助你统一了异步和同步 action 的调用方式，把异步过程放在 action 级别解决，对 component 没有影响 redux-thunk中间件可以让action创建函数先不返回一个action对象，而是返回一个函数，函数传递两个参数(dispatch,getState),在函数体内进行业务逻辑的封装 12345678910111213141516function add() &#123; return &#123; type: &apos;ADD&apos;, &#125;&#125;function addIfOdd() &#123; return (dispatch, getState) =&gt; &#123; const currentValue = getState(); if (currentValue % 2 == 0) &#123; return false; &#125; //分发一个任务 dispatch(add()) &#125;&#125; 使用方式 安装:npm install redux-thunk --save-dev 导入thunk： import thunk from ‘redux-thunk’ 导入中间件: import {createStore,applyMiddleware} from ‘redux’ 创建store：let store = createStore(reducer函数，applyMiddleware(thunk)) 激活redux-thunk中间件，只需要在createStore中加入applyMiddleware(thunk)就可以]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>redux组件库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React相关需学习]]></title>
    <url>%2F2018%2F10%2F26%2Freact-rn-2018-10-26-React%E7%9B%B8%E5%85%B3%E9%9C%80%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[ImmutableJS简介 ImmutableJS是FaceBook开发的一个JS库，能够在JS种实现不可变对象 不可变对象可以大大提高对象的比较性能，用于状态和属性判断非常有效 实际上，提高比较性能的代价是降低修改性能，只不过收益更大 Flux简介 Flux不是一个具体的框架，而是Facebook提出的一种代码架构 React只是一个视图库，Fulx是在React基础上对于前端整体的组织方案 Fulx目的是保证逻辑清晰、数据流向清晰、依赖关系清晰]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jest]]></title>
    <url>%2F2018%2F10%2F26%2Freact-rn-2018-10-26-Jest%2F</url>
    <content type="text"><![CDATA[简介 Jest是一个JS的单元测试工具 单元测试可以保证函数或者模块完成我们想要的功能，测试具体功能是否正常 使用Jest需要配置NodeJS环境 入门 npm install jest-cli sum.js 1234function sum(a,b)&#123; return a+b;&#125;module.exports=sum; test.js 12345678jest.dontMock(&apos;../sum&apos;);describe(&apos;sum&apos;,function()&#123; it(&apos;adds 1 + 2 to equal 3&apos;,function()&#123; var sum = require(&apos;../sum&apos;); expect(sum(1,2)).toBe(3); &#125;);&#125;);]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-router-redux]]></title>
    <url>%2F2018%2F10%2F26%2Freact-rn-2018-10-26-react-router-redux%2F</url>
    <content type="text"><![CDATA[概述 用Redux去管理你的应用状态（state），使用React Router去管理路由，但是，这两个库不能协同工作，react-router-redux库可以协调这两个库 react-router-redux允许你使用React Router库中的api，使用Redux库像平常一样去管理应用的状态state。 本库只是简单的加强了React Router库中history这个实例，以允许将history中接受到的变化反应到stae中去。 原理示例 现在，你进行的所有页面导航和App导航，加强版的history会首先将新的路径通过Redux store传递，然后再通过React Router去更新组件树]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>React组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redux入门]]></title>
    <url>%2F2018%2F10%2F26%2Freact-rn-2018-10-26-Redux%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[123http://redux.js.org/http://www.redux.org.cn/http://www.imooc.com/learn/744 视频教程 简介 Redux 由 Flux 演变而来，但受 Elm 的启发，避开了 Flux 的复杂性 1234567891011121314151617181920212223242526272829303132333435363738394041import &#123; createStore &#125; from &apos;redux&apos;;/** * 这是一个 reducer，形式为 (state, action) =&gt; state 的纯函数。 * 描述了 action 如何把 state 转变成下一个 state。 * * state 的形式取决于你，可以是基本类型、数组、对象、 * 甚至是 Immutable.js 生成的数据结构。惟一的要点是 * 当 state 变化时需要返回全新的对象，而不是修改传入的参数。 * * 下面例子使用 `switch` 语句和字符串来做判断，但你可以写帮助类(helper) * 根据不同的约定（如方法映射）来判断，只要适用你的项目即可。 */function counter(state = 0, action) &#123; switch (action.type) &#123; case &apos;INCREMENT&apos;: return state + 1; case &apos;DECREMENT&apos;: return state - 1; default: return state; &#125;&#125;// 创建 Redux store 来存放应用的状态。// API 是 &#123; subscribe, dispatch, getState &#125;。let store = createStore(counter);// 可以手动订阅更新，也可以事件绑定到视图层。store.subscribe(() =&gt; console.log(store.getState()));// 改变内部 state 惟一方法是 dispatch 一个 action。// action 可以被序列化，用日记记录和储存下来，后期还可以以回放的方式执行store.dispatch(&#123; type: &apos;INCREMENT&apos; &#125;);// 1store.dispatch(&#123; type: &apos;INCREMENT&apos; &#125;);// 2store.dispatch(&#123; type: &apos;DECREMENT&apos; &#125;);// 1 Redux 没有 Dispatcher 且不支持多个 store。相反，只有一个单一的 store 和一个根级的 reduce 函数（reducer） 中间件 12345678910111213redux-thunk — 用最简单的方式搭建异步 action 构造器redux-promise — 遵从 FSA 标准的 promise 中间件redux-axios-middleware — 使用 axios HTTP 客户端获取数据的 Redux 中间件redux-observable — Redux 的 RxJS 中间件redux-rx — 给 Redux 用的 RxJS 工具，包括观察变量的中间件redux-logger — 记录所有 Redux action 和下一次 state 的日志redux-immutable-state-invariant — 开发中的状态变更提醒redux-unhandled-action — 开发过程中，若 Action 未使 State 发生变化则发出警告redux-analytics — Redux middleware 分析redux-gen — Redux middleware 生成器redux-saga — Redux 应用的另一种副作用 modelredux-action-tree — Redux 的可组合性 Cerebral-style 信号apollo-client — 针对 GraphQL 服务器及基于 Redux 的 UI 框架的缓存客户端 三大原则 Redux 可以用这三个基本原则来描述： 单一数据源 整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中 State 是只读的 惟一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象 使用纯函数来执行修改 为了描述 action 如何改变 state tree ，你需要编写 reducers；Reducer 只是一些纯函数，它接收先前的 state 和 action，并返回新的 state 总结 应用中所有的 state 都以一个对象树的形式储存在一个单一的 store 中 惟一改变 state 的办法是触发 action，一个描述发生什么的对象 为了描述 action 如何改变 state 树，你需要编写 reducers 编写专门的函数来决定每个 action 如何改变应用的 state，这个函数被叫做 reducer 安装 安装redux：npm install redux --save 使用 React 绑定库和开发者工具：npm install react-redux --save；npm install redux-devtools --save-dev 原理 Action Action 是把数据从应用传到 store 的有效载荷,它是 store 数据的唯一来源。一般来说会通过 store.dispatch() 将 action 传到 store。 action 内必须使用一个字符串类型的 type 字段来表示将要执行的动作.多数情况下，type 会被定义成字符串常量,建议使用单独的模块或文件来存放 action。除了 type 字段外，action 对象的结构完全由自己决定 1import &#123; ADD_TODO, REMOVE_TODO &#125; from &apos;../actionTypes&apos; Action 创建函数 Action 创建函数 就是生成 action 的方法 123456function addTodo(text) &#123; return &#123; type: ADD_TODO, text &#125;&#125; bindActionCreators() 可以自动把多个 action 创建函数 绑定到 dispatch() 方法上。 Reducer 永远不要在 reducer 里做这些操作： 修改传入参数； 执行有副作用的操作，如 API 请求和路由跳转； 调用非纯函数，如 Date.now() 或 Math.random() 1234567891011121314151617181920function todoApp(state = initialState, action) &#123; switch (action.type) &#123; case SET_VISIBILITY_FILTER: return Object.assign(&#123;&#125;, state, &#123; visibilityFilter: action.filter &#125;) case ADD_TODO: return Object.assign(&#123;&#125;, state, &#123; todos: [ ...state.todos, &#123; text: action.text, completed: false &#125; ] &#125;) default: return state &#125;&#125; 不要修改 state。 使用 Object.assign() 新建了一个副本。不能这样使用 Object.assign(state, { visibilityFilter: action.filter })，因为它会改变第一个参数的值。你必须把第一个参数设置为空对象。你也可以开启对ES7提案对象展开运算符的支持, 从而使用 { …state, …newState } 达到相同的目的。 在 default 情况下返回旧的 state Object.assign() 是 ES6 特性，但多数浏览器并不支持。你要么使用 polyfill，Babel 插件，或者使用其它库如 _.assign() 提供的帮助方法。 新的 todos 对象就相当于旧的 todos 在末尾加上新建的 todo。而这个新的 todo 又是基于 action 中的数据创建的 Store Store 有以下职责： 维持应用的 state； 提供 getState() 方法获取 state； 提供 dispatch(action) 方法更新 state； 通过 subscribe(listener) 注册监听器; 通过 subscribe(listener) 返回的函数注销监听器 搭配react Redux 和 React 之间没有关系。Redux 支持 React、Angular、Ember、jQuery 甚至纯 JavaScript。 连接到 Redux：我们需要做出两个变化，将 App 组件连接到 Redux 并且让它能够 dispatch actions 以及从 Redux store 读取到 state 获取从之前安装好的 react-redux 提供的 Provider，并且在渲染之前将根组件包装进 1234567891011121314151617//index.jsimport React from &apos;react&apos;import &#123; render &#125; from &apos;react-dom&apos;import &#123; createStore &#125; from &apos;redux&apos;import &#123; Provider &#125; from &apos;react-redux&apos;import App from &apos;./containers/App&apos;import todoApp from &apos;./reducers&apos;let store = createStore(todoApp);let rootElement = document.getElementById(&apos;root&apos;)render( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt;, rootElement) 通过 react-redux 提供的 connect() 方法将包装好的组件连接到Redux 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import React, &#123; Component, PropTypes &#125; from &apos;react&apos;;import &#123; connect &#125; from &apos;react-redux&apos;;import &#123; addTodo, completeTodo, setVisibilityFilter, VisibilityFilters &#125; from &apos;../actions&apos;;import AddTodo from &apos;../components/AddTodo&apos;;import TodoList from &apos;../components/TodoList&apos;;import Footer from &apos;../components/Footer&apos;;class App extends Component &#123; render() &#123; // 通过调用 connect() 注入: const &#123; dispatch, visibleTodos, visibilityFilter &#125; = this.props return ( &lt;div&gt; &lt;AddTodo onAddClick=&#123;text =&gt; dispatch(addTodo(text)) &#125; /&gt; &lt;TodoList todos=&#123;this.props.visibleTodos&#125; onTodoClick=&#123;index =&gt; dispatch(completeTodo(index)) &#125; /&gt; &lt;Footer filter=&#123;visibilityFilter&#125; onFilterChange=&#123;nextFilter =&gt; dispatch(setVisibilityFilter(nextFilter)) &#125; /&gt; &lt;/div&gt; ) &#125;&#125;App.propTypes = &#123; visibleTodos: PropTypes.arrayOf(PropTypes.shape(&#123; text: PropTypes.string.isRequired, completed: PropTypes.bool.isRequired &#125;)), visibilityFilter: PropTypes.oneOf([ &apos;SHOW_ALL&apos;, &apos;SHOW_COMPLETED&apos;, &apos;SHOW_ACTIVE&apos; ]).isRequired&#125;function selectTodos(todos, filter) &#123; switch (filter) &#123; case VisibilityFilters.SHOW_ALL: return todos; case VisibilityFilters.SHOW_COMPLETED: return todos.filter(todo =&gt; todo.completed); case VisibilityFilters.SHOW_ACTIVE: return todos.filter(todo =&gt; !todo.completed); &#125;&#125;// 基于全局 state ，哪些是我们想注入的 props ?// 注意：使用 https://github.com/reactjs/reselect 效果更佳。function select(state) &#123; return &#123; visibleTodos: selectTodos(state.todos, state.visibilityFilter), visibilityFilter: state.visibilityFilter &#125;;&#125;// 包装 component ，注入 dispatch 和 state 到其默认的 connect(select)(App) 中；export default connect(select)(App);]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Router]]></title>
    <url>%2F2018%2F10%2F26%2Freact-rn-2018-10-26-React-Router%2F</url>
    <content type="text"><![CDATA[https://reacttraining.com/react-router/ 概述 React Router 4.0 （以下简称 RR4） RR4 本次采用单代码仓库模型架构（monorepo），这意味者这个仓库里面有若干相互独立的包，分别是： 12345react-router React Router 核心react-router-dom 用于 DOM 绑定的 React Routerreact-router-native 用于 React Native 的 React Routerreact-router-redux React Router 和 Redux 的集成react-router-config 静态路由配置的小助手 它是官方维护的，事实上也是唯一可选的路由库。 react-router 还是 react-router-dom 在 React 的使用中，我们一般要引入两个包，react 和 react-dom react-router 和 react-router-dom 两个只要引用一个就行了，不同之处就是后者比前者多出了 这样的 DOM 类组件 学习 （阮一峰）http://www.ruanyifeng.com/blog/2016/05/react_router.html （gitbook）http://react-guide.github.io/react-router-cn/docs/API.html]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>React-Router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React入门]]></title>
    <url>%2F2018%2F10%2F26%2Freact-rn-2018-10-26-React%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[简介 React 是一个用于构建用户界面的 JAVASCRIPT 库 React主要用于构建UI，很多人认为 React 是 MVC 中的 V（视图） React 起源于 Facebook 的内部项目，用来架设 Instagram 的网站，并于 2013 年 5 月开源 React 拥有较高的性能，代码逻辑非常简单，越来越多的人已开始关注和使用它 React 拥有一个强大的组合模型，我们建议使用组合而不是继承以实现代码的重用 react有 函数式组件和类组件，现在的使用都以类组件为主，函数式组件不考虑 angualr霸道，用了之后原生定时器、jquery等都不能用，而react没有这个限制 react中对事件的大小写敏感，因为有一个编译过程 相关有用网址 123官网：https://facebook.github.io/react/中文网站：http://www.css88.com/react/中文论坛:http://react-china.org/ react特点 声明式设计 −React采用声明范式，可以轻松描述应用。 高效 −虚拟DOM,React通过对DOM的模拟，最大限度地减少与DOM的交互。React DOM 会将元素及其子元素与之前版本逐一对比, 并只对有必要更新的 DOM 进行更新, 以达到 DOM 所需的状态 灵活 −React可以与已知的库或框架很好地配合。 JSX − JSX 是 JavaScript 语法的扩展。React 开发不一定使用 JSX ，但我们建议使用它。 组件 − 通过 React 构建组件，使得代码更加容易得到复用，能够很好的应用在大项目的开发中。 单向响应的数据流 − React 实现了单向响应的数据流，从而减少了重复代码，这也是它为什么比传统数据绑定更简单 react全家桶（技术栈） 如果一个技术你不知道，那说明你还用不上 react：主体 webpack、grunt、gulp自动化构建工具 Flex：布局 react-route：路由 redux：view层 Mocha：测试 Istanbul：覆盖率 安装 网页使用 网页中用babel会页面加载会有编译过程，比较缓慢，babel也可以后台编译 123456789&lt;script src=&quot;https://cdn.bootcss.com/react/15.4.2/react.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.bootcss.com/react/15.4.2/react-dom.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.bootcss.com/babel-standalone/6.22.1/babel.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/babel&quot;&gt; ReactDOM.render( &lt;h1&gt;Hello, world!&lt;/h1&gt;, document.getElementById(&apos;example&apos;) );&lt;/script&gt; 引入了三个库： react.min.js 、react-dom.min.js 和 babel.min.js： react.min.js - React 的核心库 react-dom.min.js - 提供与 DOM 相关的功能 babel.min.js - Babel 可以将 ES6 代码转为 ES5 代码，这样我们就能在目前不支持 ES6 浏览器上执行 React 代码。Babel 内嵌了对 JSX 的支持。通过将 Babel 和 babel-sublime 包（package）一同使用可以让源码的语法渲染上升到一个全新的水平 使用 create-react-app 快速构建 create-react-app 是来自于 Facebook，通过该命令我们无需配置就能快速构建 React 开发环境。 create-react-app 自动创建的项目是基于 Webpack + ES6 create-react-app网址：https://github.com/facebookincubator/create-react-app create-react-app说明：https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#updating-to-new-releases 1234$ cnpm install -g create-react-app$ create-react-app my-app$ cd my-app/$ npm start 在浏览器中打开 http://localhost:3000/,查看结果 JSX JSX是可选的，对于使用 React而言不需要 React 使用 JSX 来替代常规的 JavaScript，JSX 是一个看起来很像 XML 的 JavaScript 语法扩展。 优点： JSX 执行更快，因为它在编译为 JavaScript 代码后进行了优化，需babel编译后才能运行，bower babel install,官网：http://babeljs.io/ 它是类型安全的，在编译过程中就能发现错误 使用 JSX 编写模板更加简单快速 使用过程中的注意事项： 组件必须返回一个单独的根元素。render的内容必须有且仅有一个父元 网页中使用： 123456789101112131415&lt;script src=&quot;js/react.js&quot; charset=&quot;utf-8&quot;/&gt;&lt;/script&gt;&lt;script src=&quot;js/react-dom.js&quot; charset=&quot;utf-8&quot;/&gt;&lt;/script&gt;&lt;script src=&quot;js/browser.js&quot; charset=&quot;utf-8&quot;/&gt;&lt;/script&gt;&lt;script type=&quot;text/babel&quot;&gt; window.onload=function()&#123; var oDiv = document.getElementById(&quot;div1&quot;); ReactDom.render( &lt;span&gt;111&lt;/span&gt;,//内容 oDiv//到哪 ); &#125;;&lt;/script&gt;&lt;body&gt; &lt;div id=&quot;div1&gt;&lt;/div&gt;&lt;/body&gt; 添加自定义属性需要使用 data- 前缀，因为jsx对html标签有识别，如果符合则不显示，而在自定义属性前面加data-可以保证显示显示 自定义组件可以单独文件存储 可以在 JSX 中使用 JavaScript 表达式。表达式写在花括号 {} 中；在 JSX 中不能使用 if else 语句，但可以使用 conditional (三元运算) 表达式来替代 React 推荐使用内联样式。我们可以使用 camelCase 语法来设置内联样式. React 会在指定元素数字后自动添加 px JSX 允许在模板中插入数组，数组会自动展开所有成员 注释:在标签内部的注释需要花括号;在标签外的的注释不能使用花括号 可以使用双引号来指定字符串字面量作为属性值 class 在JSX中变为className，tabindex 变为 tabIndex React DOM 使用驼峰(camelCase)属性命名约定, 而不是HTML属性名称 12345ReactDOM.render( /*注释 */ &lt;h1&gt;孙朝阳 &#123;/*注释*/&#125;&lt;/h1&gt;, document.getElementById(&apos;example&apos;)); 如果你有一个单一模块(module) ，但却 导出(exports) 多个 React 组件时十分有用 1234567891011import React from &apos;react&apos;;const MyComponents = &#123; DatePicker: function DatePicker(props) &#123; return &lt;div&gt;Imagine a &#123;props.color&#125; datepicker here.&lt;/div&gt;; &#125;&#125;function BlueDatePicker() &#123; return &lt;MyComponents.DatePicker color=&quot;blue&quot; /&gt;;&#125; JSX 中的 Children：在 JSX 表达式中可以包含开放标签和闭合标签，标签中的内容会被传递一个特殊的 props(属性) ： props.children 组件 组件名称总是以大写字母开始 组件有构造函数，构造函数的第一行应该是调用super函数，其参数为…args参数，在constructor方法中进行一些初始 绑定事件的方式：onChange={this.函数名称.bind(this)} 有狗那年，定时器中的this就不合适，在使用前通过_this=this保存一份，然后在定时中用_this代替 react处理了this，原生中如果要用this，最好也处理一下 react中阻止事件冒泡：ev.nativeEvent.stopImmediatePropergation 父级属性传递给子级直接通过属性，子级属性传递给父级需要通过在父级绑定回调函数如cb()，在子级中通过this.props.cb(传递的参数)的方式把参数传递到父级 react中设置样式style需要通过双大括号}}来设置 键(Keys) 帮助 React 标识哪个项被修改、添加或者移除了。数组中的每一个元素都应该有一个唯一不变的键(Keys)来标识。keys 只在数组的上下文中存在意义； keys 必须在它们的同辈之间唯一。然而它们并不需要全局唯一 自定义组件的方式如下： 12345class 组件名称 extends React.Component&#123; render()&#123; retrun &lt;span&gt;我的年龄是：&#123;this.props.age&#125;&lt;/span&gt; &#125; &#125; 123456//定义class Comp extends React.Component&#123; render()&#123; return &lt;span&gt;111&lt;/span&gt;; &#125;&#125; 组件使用：类似于标签的使用 1234ReactDom.render( &lt;Comp age=&quot;18&quot;/&gt;,//内容,类名 document.body//到哪); 123456789101112131415161718192021window.onload=function()&#123; ReactDom.render( &lt;Comp/&gt;,//内容,类名 document.body//到哪 ); &#125;;~~~ # 状态state* React 把组件看成是一个状态机（State Machines）。通过与用户的交互，实现不同状态，然后渲染 UI，让用户界面和数据保持一致。* React 里，只需更新组件的 state，然后根据新的 state 重新渲染用户界面（不要操作 DOM）。* this.setState(&#123;属性：&apos;值&apos;&#125;); * state(状态) 更新可能是异步的。React 为了优化性能，有可能会将多个 setState() 调用合并为一次更新。因为 this.props 和 this.state 可能是异步更新的，你不能依赖他们的值计算下一个state(状态)。# 属性propsstate 和 props 主要的区别在于 props 是不可变的，而 state 可以根据与用户交互来改变。这就是为什么有些容器组件需要定义 state 来更新和修改数据。 而子组件只能通过 props 来传递数据* 如果你没给 prop(属性) 传值，那么他默认为 true* 控制表单的value，如果用props设置了默认值，由于props是死的，不能修改，修改为defaultValue即可* 控制checkbox的默认值，修改为defalultChecked* 属性扩展:如果你已经有一个 object 类型的 props，并且希望在 JSX 中传入，你可以使用扩展操作符 ... 传入整个 props 对象。以上两种方法等效： function App1() { return ; } function App2() { const props = {firstName: ‘Ben’, lastName: ‘Hector’}; return &lt;Greeting {…props} /&gt;; } # 组件生命周期 组件的生命周期可分成三个状态： 1. Mounting：已插入真实 DOM 2. Updating：正在被重新渲染 3. Unmounting：已移出真实 DOM 生命周期的方法有： * componentWillMount 在渲染前调用,在客户端也在服务端 * componentDidMount : 在第一次渲染后调用，只在客户端。之后组件已经生成了对应的DOM结构，可以通过this.getDOMNode()来进行访问。 如果你想和其他JavaScript框架一起使用，可以在这个方法中调用setTimeout, setInterval或者发送AJAX请求等操作(防止异部操作阻塞UI) * componentWillReceiveProps 在组件接收到一个新的prop时被调用。这个方法在初始化render时不会被调用 * shouldComponentUpdate 返回一个布尔值。在组件接收到新的props或者state时被调用。在初始化时或者使用forceUpdate时不被调用 * componentWillUpdate在组件接收到新的props或者state但还没有render时被调用。在初始化时不会被调用 * componentDidUpdate 在组件完成更新后立即调用。在初始化时不会被调用 * componentWillUnmount在组件从 DOM 中移除的时候立刻被调用。==当使用异步加载数据时，在组件卸载前使用 componentWillUnmount 来取消未完成的请求== # React Refs * React 支持一种非常特殊的属性 Ref ，可以用来绑定到 render() 输出的任何组件上。 这个特殊的属性允许你引用 render() 返回的相应的支撑实例（ backing instance ）。这样就可以确保在任何时间总是拿到正确的实例 * 可以通过使用 this 来获取当前 React 组件，或使用 ref 来获取组件的引用 * ref 标示组件内的node，可以原生操作节点，在this.refs['ref名字']=原生 * React 支持给任何组件添加特殊属性。ref 属性接受回调函数，并且当组件 装载(mounted) 或者 卸载(unmounted) 之后，回调函数会立即执行 * 不能在函数式组件上使用 ref 属性，因为它们没有实例 # 使用 Chrome Timeline 分析组件性能 在 开发模式 中，你可以在支持相关功能的浏览器中使用性能工具来可视化组件 装载(mount) ，更新(update) 和 卸载(unmount) 的各个过程。在 Chrome 中具体操作如下： 1. 通过添加 ?react_perf 查询字段加载你的应用(例如：http://localhost:3000/?react_perf) 2. 打开 Chrome DevTools Timeline 并点击 Record 3. 执行你想要分析的操作，不要超过20秒，否则 Chrome 可能会挂起 4. 停止记录 5. 在 User Timing 标签下，React事件将会分组列出 注意：上述数字是相对的，组件会在生产环境中会更快 # route react-router + react-router-redux: 前者是业界标准，后者可以同步 route 信息到 state，这样你可以在 view 根据 route 信息调整展现，以及通过 action 来修改 route 。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker]]></title>
    <url>%2F2018%2F10%2F18%2F%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF-2018-10-18-docker%2F</url>
    <content type="text"><![CDATA[阿里云服务器购买 http://www.runoob.com/docker/docker-tutorial.html 官网：https://www.docker.com/ 中文社区：http://www.docker.org.cn/ http://www.cnblogs.com/SzeCheng/p/6822905.html Docker是基于CS架构，系统有两个程序：docker服务端和docker客户端，是一种Linux容器管理技术 其中docker服务端是一个服务进程，管理着所有的容器。 docker客户端则扮演着docker服务端的远程控制器，可以用来控制docker的服务端进程。 大部分情况下，docker服务端和客户端运行在一台机器上。 Docker为容器引入了镜像，使得容器可以从预先定义好的模版（images）创建出来，并且这个模版还是分层的 Docker容器通过镜像启动，是镜像的启动和执行阶段，采用写时复制（copy on write） Docker容器的能力 1文件系统隔离：每个容器都有自己的root文件系统 2进程隔离：每个容器都运行在自己的进程环境中 3网络隔离：容器间的虚拟网络接口和IP地址都是分开的 4资源隔离和分组：使用cgroups将CPU和内存之类的资源独立分配给每个Docker容器 docker Client客户端————&gt;向docker服务器进程发起请求，如:创建、停止、销毁容器等操作 docker Server服务器进程—–&gt;处理所有docker的请求，管理所有容器 docker Registry镜像仓库——&gt;镜像存放的中央仓库，可看作是存放二进制的软件配置管理（scm） https://www.cnblogs.com/atuotuo/p/6668233.html 安装：下载安装完成之后docker version查看 Kitematic， Vagrant+virtualbox https://www.vagrantup.com/ https://www.virtualbox.org/ https://app.vagrantup.com/boxes/search mkdir centos7 ls vagrant init centos/7 vagrant up vagrant ssh sudo yum update exit vagrant status vagrant halt vagrant destroy Docker Machine docker-machine ls docker-machine ssh demo 远程登录管理deocker和本地管理远程docker https://labs.play-with-docker.com/ docker提供了一个开发，打包，运行app的平台，把app和底层infratructure隔离开来 docker底层技术支持,依赖于Linux内核特性Namespaces和Cgroups Namespaces：做隔离pid，net，ipc，mnt，uts Control Groups：做资源限制 Union file Systems：Container和image的分层 namespace，容器隔离的基础，保证A容器看不到B容器. 6个名空间：User,Mnt,Network,UTS,IPC,Pid cgroups，容器资源统计和隔离。主要用到的cgroups子系统：cpu,blkio,device,freezer,memory unionfs，典型：aufs/overlayfs，分层镜像实现的基础 docker image：是容器的基石，本身为层叠的只读文件系统， docker通过联合加载技术一次加载多个文件系统，从外部看，只能看到一个文件系统，包含所有文件系统的文件和目录。bootfs-rootfs(如：ubuntu)-apache。。。，rootfs称为基础镜像 文件和meta data的集合（root filesystem） 分层的，并且每一层都可以添加改变删除文件，成为一个新的image 不同的image可以共享x相同的layer image本身是read-only的 sudo docker image ls docker history [imageID] image的获取 通过Dockerfile 从Registry获取，如：docker pull ubuntu:14.04，https://hub.docker.com/ 命令行的格式为：docker search 镜像名字 DIY一个Base Image Container docker容器可以理解为在沙盒中运行的进程。这个沙盒包含了该进程运行所必须的资源，包括文件系统、系统类库、shell 环境等等。但这个沙盒默认是不会运行任何程序的。你需要在沙盒中运行一个进程来启动某一个容器。这个进程是该容器的唯一进程，所以当该进程结束的时候，容器也会完全的停止。 通过Image创建 在Image Layer之上建立一个container layer（可读写） 类比面向对象：类和实例 Image负责app的存储和分发，Container负责运行app container id只要能够区分出来就行，不用全部输入 docker container ls //运行的 docker container ls -a //所有的，包括退出的和正在运行的 docker run命令有两个参数，一个是镜像名，一个是要在镜像中运行的命令。 docker run [name] //运行container docker run -it [name] //交互式运行container 命令简写 docker container ls -a == docker ps -a docker container rm [conatinerID] == docker rm [conatinerID] docker image ls == docker images docker image rm [imageID] == docker rmi [imageID] docker container ls -aq //列出所有conatinerID 构建自己的docker镜像 docker commit [containerName] [dockerhubID/imageNewName] 通过Dockerfile创建 新建空文件夹 创建Dockerfile文件 12FROM [BaseImageName] //如果没有则值为scratchRUN yum install -y vim docker build -t [dockerhubID/imageNewName] . //.表示当前目录中查找Dockerfile docker image ls查看 Dockerfile语法梳理及最佳实践 FROM:尽量使用官方的iamge作为base image LABEL:Metadata不可少，让大家了解到image的信息，相当于image的注释 RUN:为了美观，复杂的RUN请用反斜线换行，避免无用分层，合并多条命令成一行 WORKDIR:设定当前工作目录，如果没有则会自动创建目录；用WORKDIR，不要用RUN cd，尽量使用绝对目录 ADD和COPY：把本地文件（构建目录中的相对地址 ）添加到image里面，同时ADD添加的文件如果是压缩文件的话，会自动解压缩，大部分情况COPY优于ADD，添加远程文件／目录请使用crul或wget；目标路径需指定docker中的绝对路径 ENV：设置环境变量，尽量使用ENV增加可维护性 https://github.com/docker-library/ MAINTAINER：指定容器的相关维护信息，维护人、邮箱等 RUN：执行命令并创建新的Image Layer，是在容器构建时执行 CMD：设置容器启动后默认执行的命令和参数，是在容器运行时运行的.如果docker run指定了其他命令，CMD命令被忽略；如果定义了多个CMD，只会执行最后一个；也可以只提供参数，作为ENTRYPOINT的默认参数 ENTRYPOINT：设置容器启动时运行的命令，让容器以应用程序或者服务的形式执行；不会被忽略，一定会执行；最佳实践是写一个shell脚本作为entrypoint EXPOSE：指定运行该镜像的容器使用的端口，但此端口并未自动打开，在使用的时候需要映射／设置端口 VOLUME：用来向基于镜像创建的容器，一个卷是可以存在于一个或多个容器的特定目录，这个目录可以绕过联合文件系统提供共享数据、数据持久化功能 WORKDIR：用于在容器内部设置工作目录，一般使用绝对路径，如果使用相对路径，路径会一致传递下去 USER：用来指定镜像被什么用户去运行，如果不设置，默认为root用户 ONBUILD：用来为镜像添加触发器，当一个镜像被其他镜像作为基础镜像执行时，此触发器会被执行 使用中间层镜像进行调试，查找错误 docker build命令只删除了中间层常见的容器，但是没有删除中间层创建的镜像 构建缓存：构建过程中会产生缓存，下次构建直接使用缓存镜像，如果不想使用构建缓存，则可通过：docker build --no-cache,或者通过dockerfile文件的ENV REFRESH_DATE修改日期，则本条语句后就不使用缓存了 docker history 镜像，用来查看镜像的构建过程 12COPY docker-entrypoint.sh /usr/local/bin/ENTRYPOINT [&quot;docker-entrypoint.sh &quot;] shell格式和EXEC格式 123RUN apt-get install -y vimCMD echo &quot;Hello Docker&quot;ENTRYPOINT echo &quot;Hello Docker&quot; 123RUN [&quot;apt-get&quot;,&quot;install&quot;,&quot;-y&quot;,&quot;vim&quot;]CMD [&quot;/bin/echo&quot;, &quot;Hello Docker&quot;]ENTRYPOINT [&quot;/bin/echo&quot;, &quot;Hello Docker&quot;] 登录dockerhub docker login: 用户名（非邮箱）／密码 本地push上去，其他人就可以pull 关联github，github管理Dockerfile，有修改后自动build。Create-Create Automated build 通过docker的registry本地自己搭建。https://hub.docker.com/_/registry/,后期学习 Dockerfile实战 Dockerfile是docker构建镜像的基础，也是docker区别于其他容器的重要特征，正是有了Dockerfile，docker的自动化和可移植性才成为可能。 不论是开发还是运维，学会编写Dockerfile几乎是必备的 容器的操作 //对容器执行命令 docker exec docker exec -it [containerID] /bin/bash docker inspect [imageName] //查看 docker logs [containerID] 前3章 Docker常见命令 容器相关操作 docker create # 创建一个容器但是不启动它 docker run # 创建并启动一个容器 docker stop # 停止容器运行，发送信号SIGTERM docker start # 启动一个停止状态的容器 docker restart # 重启一个容器 docker rm # 删除一个容器 docker kill # 发送信号给容器，默认SIGKILL docker attach # 连接(进入)到一个正在运行的容器 docker wait # 阻塞到一个容器，直到容器停止运行 获取容器相关信息 docker ps # 显示状态为运行（Up）的容器 docker ps -a # 显示所有容器,包括运行中（Up）的和退出的(Exited) docker inspect # 深入容器内部获取容器所有信息 docker logs # 查看容器的日志(stdout/stderr) docker events # 得到docker服务器的实时的事件 docker port # 显示容器的端口映射 docker top # 显示容器的进程信息 docker diff # 显示容器文件系统的前后变化 导出容器 docker cp # 从容器里向外拷贝文件或目录 docker export # 将容器整个文件系统导出为一个tar包，不带layers、tag等信息 执行 docker exec # 在容器里执行一个命令，可以执行bash进入交互式 镜像操作 docker images # 显示本地所有的镜像列表 docker import # 从一个tar包创建一个镜像，往往和export结合使用 docker build # 使用Dockerfile创建镜像（推荐） docker commit # 从容器创建镜像 docker rmi # 删除一个镜像 docker load # 从一个tar包创建一个镜像，和save配合使用 docker save # 将一个镜像保存为一个tar包，带layers和tag信息 docker history # 显示生成一个镜像的历史命令 docker tag # 为镜像起一个别名 镜像仓库(registry)操作 docker login # 登录到一个registry docker search # 从registry仓库搜索镜像 docker pull # 从仓库下载镜像到本地 docker push # 将一个镜像push到registry仓库中 docker system df //查看镜像、容器、数据卷所占用的空间 docker commit -m “ubuntu with vim” -a “sgy” aa97ba3292ce sgy/ubuntu:vim 前后端分离部署及运维 高性能高负载高可用 https://www.renren.io renren-fast Swagger: JWT: https://www.ghostcloud.cn/ 服务器虚拟化 （vsphere cas ZStack不通厂家命名）：裸机虚拟化、半裸机虚拟化 网络虚拟化 SDN 存储虚拟化 VSAN 服务器做raid保证系统安全，然后做存储虚拟化 Mac 上的 Docker 背后应该是一个 Linux 虚机，和 Windows 版本的 Docker 是一样的原理 容器一旦被直接推出，之前安装的gcc啊vim啊啥的就会全部gg掉。如果要保存修改，就需要将当前容器封装成一个新的镜像，这样下次启动这个新的镜像后之前作出的修改还都在。 容器不适合构建那种发布周期以周或月为单位的大型单一架构企业软件，容器适合采用微服务的方式，以及探索诸如持续部署这样的技术，使得我们能安全地在一天内多次更新生产环境。 https://blog.csdn.net/xdy3008/article/details/74531125 https://www.missshi.cn/api/view/blog/5a6327c00a745f6335000004 想看到docker容器的ip地址，只需要安装net-tools就可以了：yum install net-tools -y 如果你仅仅是想管理虚拟机，那么你应该使用vagrant。如果你想快速开发和部署应用，那么应该使用docker。 vagrant是一款管理虚拟机的工具，而docker是一款通过将应用打包到轻量级容器，而实现构建和部署的工具。两者适用范围不同。一个容器就是一个包含了应用执行所依赖的数据(包括lib，配置文件等等)。它可以保证应用在一个可重复的环境中随时执行。 数据卷：是经过特殊设计的目录，可以绕过联合文件系统ufs，为一个或多个容其提供访问。让你可以不受容器生命周期影响进行数据持久化。它们表现为容器内的空间，但实际保存在容器之外，从而允许你在不影响数据的情况下销毁、重建、修改、丢弃容器。 Docker允许你定义应用部分和数据部分，并提供工具让你将他们分开。容器是短暂和一次性的。 docker run -v ~/container_data:/data:ro -it centos,映射本地~/container_data到容器/data下,且/data的权限为ro只读，登录进去后ls查看，发现会有data目录 数据卷容器：命名的容器挂载数据卷，其他容器通过挂载这个容器实现数据共享，挂载数据卷的容器，就叫做数据卷容器。 docker run --volumes-from 数据卷容器名称 即使删除了数据卷容器，挂载了数据卷容器的容器，仍然可以访问数据卷容器的目录，数据卷容器起的作用仅仅是将挂载配置传递到待挂载容器 Docker数据卷的备份与还原：通过挂载目录压缩后放到挂载目录 Docker For Mac的Docker Daemon是运行于虚拟机(xhyve)中的, 而不是像Linux上那样作为进程运行于宿主机，因此Docker For Mac没有docker0网桥，不能实现host网络模式，host模式会使Container复用Daemon的网络栈(在xhyve虚拟机中)，而不是与Host主机网络栈，这样虽然其它容器仍然可通过xhyve网络栈进行交互，但却不是用的Host上的端口(在Host上无法访问)。bridge网络模式 -p 参数不受此影响，它能正常打开Host上的端口并映射到Container的对应Port。 docker容器的网络连接 docker0：是Linux的虚拟网桥（网桥是数据链路层的一种设备），Linux的虚拟网桥可以设置IP地址，相当于拥有一个隐藏的虚拟网卡 docker0地址划分：IP127.17.42.1,掩码255.255.0.0,总共提供了65534个地址 网桥操作需安装bridge-utils工具，安装之后brctl show查看网桥信息，可以添加网桥或者配置网桥信息 docker容器的IP地址在重启容器之后会变化，是不可靠的 容器互联：在同一宿主机下，docker容器是通过虚拟网桥互相连接的，默认在同一宿主机下docker允许所有容器互联。让容器之间可以相互连接主要借用了一个link的功能。 在使用纯Docker时，被连接的容器必须在同一个Docker宿主机中。不同宿主机之间的容器如果想要连接，则需要借助Swarm或Kubernetes等编排工具。 –link:链接容器，docker run -it --name cct3 --link=cct1:webtest bitchofgod/testnet （webtest为cct1的别名），然后在cct3中ping webtest即可互联 Docker在父容器中的以下两个地方写入了连接信息： /etc/hosts文件中，–link在此文件中写入了映射信息，当docker重新启动的时候，docker会自动维护此文件中的映射 包含连接信息的环境变量中 如果拒绝所有容器互联，则修改docker配置，在/ect/default/docker文件中添加DOCKER_OPTS=&quot; --icc=false&quot;后重启docker服务即可 如果需要特定容器互联，则通过–link、–icc=false、–iptables=true来实现 docker容器与外部网络的连接 ipforward iptables Ctrl+p，Ctrl+q退出交互界面 docker attach containerName重新打开交互界面 CaaS(Container as a Service):镜像容器托管 从Docker到Caas 容器集群管理工具 容器调度 配置管理 服务发现 日志／监控／报警 LaaS（基础设施） 出租计算、存储、网络、DNS等基础IT服务 PaaS（基础设施+系统平台—应用服务器应用框架 编程语言） 提供应用运行和开发环境 提供应用开发组件（邮件、消息、计费、支付） SaaS （基础设施+系统平台+软件应用）互联网Web2.0应用 企业应用（ERP/CRM等） 通俗点讲 SaaS：软件即服务，简单来说就是把企业想要的功能开发好成应用软件，然后直接卖给用户使用。通俗点讲就是去饭店吃饭一样，什么都是店家的。 PaaS：平台即服务，简单来说就是云计算平台提供硬件、编程语言、开发库等帮助用户更好更快的开发软件。通俗来说就是点外卖，使用时店家的，但是餐桌是自己的。 IaaS：基础设施即服务，简单来说就是云服务商提供企业所需要的服务器、存储、网络给企业用。通俗来说就是买菜买面，回家自己做饭。 https://blog.csdn.net/weixin_38003389/article/details/84025762 Docker Machine：目的是简化 Docker 的安装和远程管理,是官方提供的一个工具。 先创建Docker Machine机器 Docker Compose：Docker Compose 是 Docker 官方编排（Orchestration）项目之一，负责快速在集群中部署分布式应用。 Docker Compose允许用户通过一个单独的 docker-compose.yml 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project） Compose 中有两个重要的概念： 项目 ( project )：由一组关联的应用容器组成的一个完整业务单元，在 dockercompose.yml 文件中定义。 服务 ( service )：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例 运行 compose 项目：docker-compose up Docker Compose命令集 管理镜像：build/pull 管理服务：up/start/stop/kill/rm/scale 服务状态：ps/logs/port 一次性服务：run Docker Swarm:Docker集群管理工具，支持标准的Docker API,其主要作用是把若干台Docker主机抽象为一个整体，并且通过一个入口统一管理这些Docker主机上的各种Docker资源。 Swarm和Kubernetes比较类似，但是更加轻，具有的功能也较kubernetes更少一些。 Docker Compose 是一个在单个服务器或主机上创建多个容器的工具，而 Docker Swarm 则可以在多个服务器或主机上创建容器集群服务，对于微服务的部署，显然 Docker Swarm 会更加适合。 三大主流调度框架：Swarm、Kubernetes和Mesos Kubernetes：交互工具kubectl pods：创建、调度及管理的最小单元，共存的一组容器的集合，同一pods中的容器共享pid、网络、ipc及utf命名空间和共享存储卷]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#]]></title>
    <url>%2F2018%2F10%2F17%2FC-%E5%BC%80%E5%8F%91-2018-10-17-C%2F</url>
    <content type="text"><![CDATA[双问号操作符意思是取所赋值??左边的，如果左边为null，取所赋值??右边的，双问号操作符意思是取所赋值??左边的，如果左边为null，取所赋值??右边的， https://blog.csdn.net/zmh458/article/details/78935172 https://www.cnblogs.com/lanpingwang/p/6596758.html https://www.cnblogs.com/Inspire-Yi/p/6230567.html https://www.jianshu.com/p/c82ef6babf8e https://www.cnblogs.com/caofangsheng/p/5715876.html https://blog.csdn.net/beglorious/article/details/39637475 https://www.cnblogs.com/servicehot/p/6510199.html 首先我觉得action的跳转大致可以这样归一下类，跳转到同一控制器内的action和不同控制器内的action、带有参数的action跳转和不带参数的action跳转。 一、RedirectToAction(“Index”);//一个参数时在本Controller下，不传入参数。 二、RedirectToAction(ActionName,ControllerName) //可以直接跳到别的Controller. 三、RedirectToRoute(new {controller=“Home”,action=“Index”});//可跳到其他controller 四、RedirectToRoute(new {controller=“Home”,action=“Index”， id=param});//可跳到其他controller,带参数。 五、Response.Redirect(“Index?id=1”);//适用于本controller下的方法名称,可带参数。 六、return Redirect(“Index”);//适用于本controller下的方法名称。 七、return View(“Index”); //直接显示对应的页面 不经过执行Controller的方法。 八、return View(&quot;~/Views/Home/Index.aspx&quot;);//这种方法是写全路径,直接显示页面,不经过Controller方法 九、return View();//直接显示页面,不经过Controller方法 https://blog.csdn.net/zhensoft163/article/details/7174661?utm_source=blogxgwz1 一般情况下我们返回的都是本页面，所以使用return View()就可以解决问题了， https://www.cnblogs.com/Cwj-XFH/p/5956142.html Model验证是ASP.NET MVC中的重要部分，它主要用于判断输入的数据类型及值是否符合我们设定的规则，这篇文章就介绍下ASP.NET MVC中Model验证的几种方式。 后台验证 DataAnnotation ValidationAttribute IValidatableObject IDataErrorInfo 前端验证 ViewData和ViewBag https://blog.csdn.net/pasic/article/details/7093802 https://www.cnblogs.com/webapi/p/9505400.html 系列文章： https://blog.csdn.net/ydm19891101/article/details/43338999 WebForm与MVC的本质区别：请求的url不同 https://blog.csdn.net/liupantao/article/details/78582078?locationNum=3&amp;fps=1 MVC action 返回javascriptResult 需要引入的文件是 需要引用这个文件 ： jquery.unobtrusive-ajax.min.js 同时 用javascrptResult 作为action的返回结果 的话 ，前台必须用ajax.BeginForm https://www.cnblogs.com/zjf1987/p/ActionResult.html]]></content>
      <categories>
        <category>C#</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[React全家桶]]></title>
    <url>%2F2018%2F10%2F15%2Freact-rn-2018-10-15-React%E5%85%A8%E5%AE%B6%E6%A1%B6%2F</url>
    <content type="text"><![CDATA[React全家桶+Antd共享单车后台管理系统 react基础知识 Vue生态：Vue+Vue-Router+Vuex+Axios+Babel+Webpack React生态：React+React-Router+Redux+Axios+Babel+Webpack 编程式实现：需要以具体代码表达在哪里做什么，如何实现 声明式实现：只需声明在哪里做什么，无需关心如何实现 https://react.docschina.org/ https://reactjs.org.cn/ http://facebook.github.io/react/ yarn： https://yarnpkg.com/zh-Hans/ yarn init yarn add yarn remove yarn install react生命周期 react-router ／react-router-dom 按需加载： Antd中less样式 yarn eject:暴露webpack配置， less-loader安装 webpack.config.xxx.js 修改完之后，重启项目 https://ant.design/docs/react/use-with-create-react-app-cn babel-plugin-import css3 calc属性 height:calc(100vh) jsonp：https://www.npmjs.com/package/jsonp 浏览器添加debugger 伪类方式 项目中前端路由用的是 React-Router V4。 官方文档：https://reacttraining.com/react-router/web/guides/quick-start 中文文档：http://reacttraining.cn/ React-Router 4.0 React-Router：基础包 React-Router-DOM：浏览器端实现 https://segmentfault.com/a/1190000011399153 箭头函数不加{}表示直接返回结果 this.props.match.params.XXX 处理404则不设置path，只设置component即可 路由外面添加Switch 详情页面、登录页面、主页面是同层级页面，还有其他自页面嵌套路由 App.js设置为{this.props.children}代表可以接受任何组件，APP组件作为HashRouter的根组件 子路由、子组件模式 传参数需要箭头函数 Modal.confirm() 等价于 Modal[‘confirm’] {}里面必须是一个根对象 https://blog.csdn.net/little_blue_ljy/article/details/80281803 https://www.cnblogs.com/guolintao/p/9019504.html https://www.cnblogs.com/xuyuntao/articles/6391728.html https://github.com/fomenyesu/egg-restapi-module-tool/blob/master/README.cn.md ES6模版语法:]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>Antd</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows git]]></title>
    <url>%2F2018%2F10%2F08%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-2018-10-08-windows-git%2F</url>
    <content type="text"><![CDATA[https://git-scm.com/ https://www.cnblogs.com/vitah/p/3612473.html]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gitblit搭建git服务器]]></title>
    <url>%2F2018%2F10%2F08%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-2018-10-08-Gitblit%E6%90%AD%E5%BB%BAgit%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[http://www.gitblit.com/ https://www.cnblogs.com/ucos/p/3924720.html https://blog.csdn.net/llengnuo/article/details/73477355 http://gitblit.com/setup_go.html https://blog.csdn.net/zhangwenjie1105/article/details/81482238 https://www.cnblogs.com/royi123/p/7754235.html]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信公众平台使用]]></title>
    <url>%2F2018%2F10%2F06%2F%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91-2018-10-06-%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%B9%B3%E5%8F%B0%2F</url>
    <content type="text"><![CDATA[官方文档 https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1445241432 接口整体介绍 微信接口请求返回格式介绍： 微信接口是通过GET方式请求 返回数据格式为JSON 测试号配置 无需公众账号，可直接体验和测试公众平台所有高级接口。 配置： 登录公众账号 开发&gt;开发者工具&gt;公众平台测试账号 微信扫一扫登录 配置URL、TOKEN、JS接口安全域名 注意事项 接口频率限制说明 全局返回码说明 网页授权登录： 如果用户在微信客户端中访问第三方网页，公众号可以通过微信网页授权机制，来获取用户基本信息。 两种scope模式： snsapi_base时只能获取到openid，静默授权， snsapi_userinfo时可获取到其他信息，需要用户手动同意授权的 微信公众平台（互斥） 编辑模式 开发者模式-openid 接入开发者模式步骤 为了识别用户，每个用户针对每个公众号会产生一个安全的OpenID 如果需要在多公众号、移动应用之间做用户共通，则需前往微信开放平台，将这些公众号和应用绑定到一个开放平台账号下，绑定后，一个用户虽然对多个公众号和应用有多个不同的OpenID，但他对所有这些同一开放平台账号下的公众号和应用，只有一个UnionID 公众平台以access_token为接口调用凭据，来调用接口，所有接口的调用需要先获取access_token，access_token在2小时内有效，过期需要重新获取，但1天内获取次数有限，开发者需自行存储 公众平台接口调用仅支持80端口。 网页授权获取用户基本信息：通过该接口，可以获取用户的基本信息（获取用户的OpenID是无需用户同意的，获取用户的基本信息则需用户同意） 微信JS-SDK：是开发者在网页上通过JavaScript代码使用微信原生功能的工具包，开发者可以使用它在网页上录制和播放微信语音、监听微信分享、上传手机本地图片、拍照等许多能力。 调试接口可能需要取消关注之后才能看到最新的效果 https://blog.csdn.net/z496007165/article/details/73239971 http://www.php.cn/xiaochengxu-405121.html 网页授权接口： 授权回调页面域名：没有http，如：http://89495c4f.ngrok.io是错误的，应该是： 89495c4f.ngrok.io http://www.106jiekou.com/ https://blog.csdn.net/kingmax54212008/article/details/50811885 https://www.cnblogs.com/hoobey/p/6078584.html https://blog.csdn.net/qianxing111/article/details/79884527 http://www.it165.net/pro/html/201606/70831.html]]></content>
      <categories>
        <category>微信</category>
      </categories>
      <tags>
        <tag>微信公众平台</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ngrok的使用]]></title>
    <url>%2F2018%2F10%2F06%2F%E5%85%B6%E4%BB%96-2018-10-06-ngrok%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[https://ngrok.com/ https://blog.csdn.net/liu_005/article/details/79557818]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>ngrok</tag>
        <tag>网络工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信第三方登录]]></title>
    <url>%2F2018%2F10%2F06%2F%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91-2018-10-06-%E5%BE%AE%E4%BF%A1%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95%2F</url>
    <content type="text"><![CDATA[https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421140842 用户在微信客户端中访问第三方网页，公众号可以通过微信网页授权机制，来获取用户基本信息，进而实现业务逻辑。 open id：在关注者与公众号产生消息交互后，公众号可获得关注者的open id， 同一个用户，在不同公众号或移动应用下对应有不同open id标识； union id：同一个用户，在不同公众号或移动应用下unionID相同；前提是，如若需要做多个公众号以及移动应用账户互通，得到唯一身份标识union id，则需要将多个公众号或移动应用在微信开放平台进行绑定，然后我们才能给拿到union id； 微信联合登录；也就是我们常用的微信移动端/PC端之间的扫码登录，PC端用微信扫码登录，微信移动端确认授权登录后，应用可以从微信拿到用户的open id或union id，将微信获取的用户信息与自己账户体系中的用户身份进行关联； 授权登录：需要用户确认登录，这样可以通过用户的个人确认，获取用户全面的信息，无论是否关注相关微信公众号等都可以获取。]]></content>
      <categories>
        <category>微信</category>
      </categories>
      <tags>
        <tag>微信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ASP.NET HTML表单元素]]></title>
    <url>%2F2018%2F10%2F06%2FC-%E5%BC%80%E5%8F%91-2018-10-06-ASP-NET-HTML%E8%A1%A8%E5%8D%95%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[BeginForm https://www.cnblogs.com/sheng-jie/p/6305385.html]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>ASP.NET</tag>
        <tag>HTML表单元素</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ASP.NET WebForms学习笔记]]></title>
    <url>%2F2018%2F10%2F05%2FC-%E5%BC%80%E5%8F%91-2018-10-05-ASP-NET-WebForms%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[申明 文章内容记录自：http://www.w3school.com.cn/aspnet/aspnet_intro.asp， 为个人学习笔记记录。 说明 WebForms可类比WinForm开发，通过可视化拖动的方式快速完成Web页面开发.]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>ASP.NET</tag>
        <tag>WebForms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ASP.NET MVC学习笔记]]></title>
    <url>%2F2018%2F10%2F05%2FC-%E5%BC%80%E5%8F%91-2018-10-05-ASP-NET-MVC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[申明 文章内容记录自：http://www.w3school.com.cn/aspnet/mvc_intro.asp， 为个人学习笔记记录。 MVC项目文件夹 典型的 ASP.NET MVC web 应用程序拥有如下文件夹内容： 123456789101112131415161718192021222324应用程序信息* Properties* 引用应用程序文件夹* App_Data 文件夹 //用于存储应用程序数据* App_Start 文件夹 //含应用程序的配置逻辑文件 ** BundleConfig.cs: 注册所使用的捆绑的CSS 和 JS文件。 ** FilterConfig.cs: 注册外部/全局过滤器，这些过滤器可以被应用到每个Action和Controller中去. ** RouteConfig.cs: 配置MVC应用程序的系统路由路径。 ** Startup.Auth.cs: 配置MVC应用程序的安全信息，包括Authentication和Authorization配置 * Content 文件夹 //用于静态文件，比如样式表（CSS 文件）、图表和图像* Controllers 文件夹 //包含负责处理用户输入和响应的控制器类,名称必须以 &quot;Controller&quot; 结尾* Models 文件夹 //包含表示应用程序模型的类。模型存有并操作应用程序的数据* Scripts 文件夹 //存储应用程序的 JavaScript 文件* Views 文件夹 //存有与应用程序的显示相关的 HTML 文件 ** Shared //用于存储控制器间分享的视图 ** [名称] //每个控制器对应的一个文件夹 ** _ViewStart.cshtml //其内代码被自动添加到由应用程序显示的所有视图。配置文件* Global.asax //主要是web应用程序的全局设置文件，该文件包含响应 ASP.NET 或HTTP模块所引发的应用程序级别和会话级别事件的代码。Global.asax 文件驻留在 ASP.NET 应用程序的根目录中。运行时，分析 Global.asax 并将其编译到一个动态生成的 .NET Framework 类，该类是从HttpApplication基类派生的。配置 ASP.NET，以便自动拒绝对 Global.asax 文件的任何直接的 URL 请求；外部用户不能下载或查看其中的代码。Global.asax 文件是可选的。只在希望处理应用程序事件或会话事件时，才应创建它.* packages.config //NuGet管理用的* Web.config 控制器位于 Controllers 文件夹，视图位于 Views 文件夹，模型位于 Models 文件夹。您不必在应用程序代码中使用文件夹名称 控制器Controllers web 服务器通常会将进入的 URL 请求直接映射到服务器上的磁盘文件.某个 URL 请求（比如 “http://www.abc.cn/index.asp”）将映射到服务器根目录上的文件 “index.asp”。 MVC 框架的映射方式有所不同。 MVC 将 URL 映射到方法。这些方法在类中被称为“控制器”。控制器负责处理进入的请求、处理输入、保存数据、并把响应发送回客户端。 在mvc中所有的controller类都必须使用&quot;Controller&quot;后缀来命名,并且对Action也有一定的要求： 必须是一个public方法 必须是实例方法 没有标志NonActionAttribute特性的(NoAction) 不能被重载 必须返回ActionResult类型 具体可返回数据类型请参考：https://blog.csdn.net/pasic/article/details/7110134 模型Models 模型包含所有应用程序逻辑（业务逻辑、验证逻辑、数据访问逻辑），除了纯视图和控制器逻辑。 HTML帮助器 HTML 帮助器用于修改 HTML 输出。 HTML 链接 通过 MVC，Html.ActionLink() 不连接到视图。它创建控制器操作（controller action）的连接。 HTML 表单元素 BeginForm() EndForm() TextArea() TextBox() CheckBox() RadioButton() ListBox() DropDownList() Hidden() Password() 1234567891011121314151617181920212223242526272829303132333435&lt;%= Html.ValidationSummary(&quot;Create was unsuccessful. Please correct the errors and try again.&quot;) %&gt;&lt;% using (Html.BeginForm())&#123;%&gt;&lt;p&gt;&lt;label for=&quot;FirstName&quot;&gt;First Name:&lt;/label&gt;&lt;%= Html.TextBox(&quot;FirstName&quot;) %&gt;&lt;%= Html.ValidationMessage(&quot;FirstName&quot;, &quot;*&quot;) %&gt;&lt;/p&gt;&lt;p&gt;&lt;label for=&quot;LastName&quot;&gt;Last Name:&lt;/label&gt;&lt;%= Html.TextBox(&quot;LastName&quot;) %&gt;&lt;%= Html.ValidationMessage(&quot;LastName&quot;, &quot;*&quot;) %&gt;&lt;/p&gt;&lt;p&gt;&lt;label for=&quot;Password&quot;&gt;Password:&lt;/label&gt;&lt;%= Html.Password(&quot;Password&quot;) %&gt;&lt;%= Html.ValidationMessage(&quot;Password&quot;, &quot;*&quot;) %&gt;&lt;/p&gt;&lt;p&gt;&lt;label for=&quot;Password&quot;&gt;Confirm Password:&lt;/label&gt;&lt;%= Html.Password(&quot;ConfirmPassword&quot;) %&gt;&lt;%= Html.ValidationMessage(&quot;ConfirmPassword&quot;, &quot;*&quot;) %&gt;&lt;/p&gt;&lt;p&gt;&lt;label for=&quot;Profile&quot;&gt;Profile:&lt;/label&gt;&lt;%= Html.TextArea(&quot;Profile&quot;, new &#123;cols=60, rows=10&#125;)%&gt;&lt;/p&gt;&lt;p&gt;&lt;%= Html.CheckBox(&quot;ReceiveNewsletter&quot;) %&gt;&lt;label for=&quot;ReceiveNewsletter&quot; style=&quot;display:inline&quot;&gt;Receive Newsletter?&lt;/label&gt;&lt;/p&gt;&lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;Register&quot; /&gt;&lt;/p&gt;&lt;%&#125;%&gt; MVC参考手册 http://www.w3school.com.cn/aspnet/mvc_reference.asp]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>ASP.NET</tag>
        <tag>MVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Razor使用]]></title>
    <url>%2F2018%2F10%2F05%2FC-%E5%BC%80%E5%8F%91-2018-10-05-Razor%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[申明 文章内容记录自：http://www.w3school.com.cn/aspnet/razor_intro.asp， 为个人学习笔记记录。 说明 Razor 是一种允许您向网页中嵌入基于服务器的代码的标记语法。Razor 基于 ASP.NET，它为 web 应用程序的创建而设计。 当网页被写入浏览器时，基于服务器的代码能够创建动态内容。在网页加载时，服务器在向浏览器返回页面之前，会执行页面内的基于服务器代码。由于是在服务器上运行，这种代码能执行复杂的任务，比如访问数据库。 C# 的主要 Razor 语法规则 Razor 代码块由 @{ … } 包围 行内表达式（变量和函数）以 @ 开始 代码语句以分号结束 变量通过 var 关键词进行声明 字符串用引用来包围 C# 代码对大小写敏感 C# 文件的扩展名是 .cshtml 编程 Razor编程支持变量、循环、逻辑。 变量 1234567var myString = &apos;103&apos;;int counter = 103; if (myString.IsInt())&#123; myInt=myString.AsInt();&#125; 循环 1234&lt;body&gt;@for(var i = 10; i &lt; 21; i++) &#123;&lt;p&gt;Line @i&lt;/p&gt;&#125;&lt;/body&gt; 123456&lt;body&gt;&lt;ul&gt;@foreach (var x in Request.ServerVariables) &#123;&lt;li&gt;@x&lt;/li&gt;&#125;&lt;/ul&gt;&lt;/body&gt; 12345678910&lt;body&gt;@&#123;var i = 0;while (i &lt; 5) &#123; i += 1; &lt;p&gt;Line #@i&lt;/p&gt; &#125;&#125;&lt;/body&gt; 1234567891011121314151617@&#123;var price=25;&#125;&lt;html&gt;&lt;body&gt;@if (price&gt;=30) &#123; &lt;p&gt;The price is high.&lt;/p&gt; &#125;else if (price&gt;20 &amp;&amp; price&lt;30) &#123; &lt;p&gt;The price is OK.&lt;/p&gt; &#125;else &#123; &lt;p&gt;The price is low.&lt;/p&gt; &#125; &lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425@&#123;var weekday=DateTime.Now.DayOfWeek;var day=weekday.ToString();var message=&quot;&quot;;&#125;&lt;html&gt;&lt;body&gt;@switch(day)&#123;case &quot;Monday&quot;: message=&quot;This is the first weekday.&quot;; break;case &quot;Thursday&quot;: message=&quot;Only one day before weekend.&quot;; break;case &quot;Friday&quot;: message=&quot;Tomorrow is weekend!&quot;; break;default: message=&quot;Today is &quot; + day; break;&#125;&lt;p&gt;@message&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>ASP.NET</tag>
        <tag>Razor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ASP.NET WebPages学习笔记]]></title>
    <url>%2F2018%2F10%2F05%2FC-%E5%BC%80%E5%8F%91-2018-10-05-WebPages%2F</url>
    <content type="text"><![CDATA[申明 文章内容记录自：http://www.w3school.com.cn/aspnet/webpages_intro.asp， 为个人学习笔记记录。 说明 Web Pages 是三种 ASP.NET 编程模型中的一种，用于创建 ASP.NET 网站和 web 应用程序。 布局 在因特网上，您会发现很多拥有统一外观的网站： 每页拥有相同的页眉 每页拥有相同的页脚 每页拥有相同的样式和布局 可以通过以下方式实现： 使用 @RenderPage() 方法从不同的文件导入内容 1234567&lt;html&gt;&lt;body&gt;@RenderPage("header.cshtml")&lt;h1&gt;Hello Web Pages&lt;/h1&gt; @RenderPage("footer.cshtml")&lt;/body&gt;&lt;/html&gt; 使用布局页面 布局网页包含网页的结构，而不是内容。当网页（内容页）链接到布局页时，它会根据布局页（模板）来显示。布局页类似普通的网页，但是会在引用内容页的位置调用 @RenderBody() 方法。每个内容页必须以 Layout 指令开头。 布局页面： 12345&lt;html&gt;&lt;body&gt; @RenderBody() &lt;/body&gt;&lt;/html&gt; 任意网页： 12@&#123;Layout="Layout.cshtml";&#125;&lt;h1&gt;Welcome to W3Schools&lt;/h1&gt; 防止代码泄露 在 ASP.NET 中，名称以下划线开头的文件无法通过 web 来浏览。如果您希望禁止用户查看内容块或布局文件，请对文件重新命名,如：_Layout.cshtml ~ 操作符 与 Href 方法 使用 ~ 操作符在编程代码中规定虚拟根目录,作为项目资源路径根路径，如：var myImagesFolder = “~/images”; Href 方法把代码中的路径转换为浏览器能够理解的路径（浏览器无法理解 ~ 操作符），如： 123@&#123;var myStyleSheet = &quot;~/Shared/Site.css&quot;;&#125;&lt;!-- 创建指向 CSS 文件的链接 --&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;@Href(myStyleSheet)&quot; /&gt; Page对象 Page对象为内置对象，类似与JSP中的Request等对象 方法 描述 href 使用指定的参数构建 URL。 RenderBody() 在布局页中，将呈现不在指定部分中的内容页部分。 RenderPage(page) 在其他页内呈现某一页的内容。 RenderSection(section) 在布局页中，将呈现指定部分的内容。 Write(object) 将指定的对象作为 HTML 编码的字符串写入。 WriteLiteral 无需先对指定的对象进行 HTML 编码，即可将其写入。 属性 描述 isPost 返回一个值（true 或 false），指示客户端用来请求网页的 HTTP 数据传输方法是否为 POST 请求。 Layout 获取或设置布局页的路径。 Page 提供对页面、布局页和分页之间共享的页数据的类似属性的访问。 Request 获得当前 HTTP 请求的 HttpRequest 对象。 Server 获取 HttpServerUtility 对象，该对象所提供的方法能够在网页处理过程中使用。 Web Pages帮助器 Web Helpers 极大地简化了 web 开发和常见的编程任务。其内部实现了表格、图表等内容显示的逻辑及样式，进行了特定封装。 Web Pages参考手册 http://www.w3school.com.cn/aspnet/webpages_ref_classes.asp]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>ASP.NET</tag>
        <tag>WebPages</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ASP.NET简介]]></title>
    <url>%2F2018%2F10%2F05%2FC-%E5%BC%80%E5%8F%91-2018-10-05-ASP-NET%2F</url>
    <content type="text"><![CDATA[申明 文章内容记录自：http://www.w3school.com.cn/aspnet/index.asp， 为个人学习笔记记录。 简介 ASP.NET 是一个开发框架，用于通过 HTML、CSS、JavaScript 以及服务器脚本来构建网页和网站。 ASP.NET 是新一代的 ASP。它无法兼容经典 ASP，但 ASP.NET 可以引用 ASP。 当浏览器请求 ASP.NET 文件时，ASP.NET 引擎读取该文件，编译并执行文件中的脚本，然后以纯 HTML 向浏览器返回结果。 ASP.NET 支持三种开发模式／服务器技术： Web Pages：单页面模型 MVC：模型视图控制器 Web Forms：事件驱动模型 ASP.NET 文件扩展名 ASP 文件的文件扩展名是 .asp ASP.NET 文件的文件扩展名是 .aspx ASP.NET 文件使用 C# 语法的文件扩展名是 .cshtml ASP.NET 文件使用 Razor VB 语法的文件扩展名是 .vbhtml 版本区别 2009年发行ASP.NET MVC 1.0版 2010年发行ASP.NET MVC 2.0版，VS2010 2011年发行ASP.NET MVC 3.0版+EF4，需要.Net4.0支持，VS2011 2012年发行ASP.NET MVC 4.0版+EF5，需要.Net4.0支持，VS2012 2013年发行ASP.NET MVC 5.0版+EF6，需要.Net4.5支持，VS2013 2015年发行ASP.NET MVC 6.0版+EF7，需要.Net5.0支持，VS2015 ASP.NET 5.0 将改名为 ASP.NET Core 1.0 ASP.NET MVC 6 将改名为 ASP.NET MVC Core 1.0 Entity Framework 7.0 将改名为 Entity Framework Core 1.0 .NET新的跨平台版本将命名为.NET Core 1.0 推荐文章 WebForms vs. MVC： http://www.cnblogs.com/heyuquan/p/webForms-vs-mvc.html]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>ASP.NET</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows下SVN服务器搭建及VS2015插件安装联动]]></title>
    <url>%2F2018%2F10%2F05%2FC-%E5%BC%80%E5%8F%91-2018-10-05-Windows%E4%B8%8BSVN%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E5%8F%8AVS2015%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85%E8%81%94%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[SVN服务端软件下载：https://www.visualsvn.com/server/download/ VisualSVN-Server-3.9.1-x64以管理员权限（有的话）安装,一路默认，选择standard版本,其他都是默认 SVN客户端软件下载：https://www.visualsvn.com/visualsvn/download/tortoisesvn/ 默认安装 VS2015插件下载： https://www.visualsvn.com/visualsvn/download/]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>版本控制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jenkins]]></title>
    <url>%2F2018%2F10%2F05%2FCI-Jekins%2F</url>
    <content type="text"><![CDATA[Jenkins 官网下载：https://jenkins.io/download/ ,注意下载的版本要与jdk的版本对应 Jenkins是基于Java开发的一种持续集成工具，用于监控持续重复的工作，功能包括：持续的软件版本发布/测试项目；监控外部调用执行的工作 持续集成：指开发者在代码的开发过程中，可以频繁的将代码部署集成到主干，并进程自动化测试 持续交付：指的是在持续集成的环境基础之上，将代码部署到预生产环境 持续部署：在持续交付的基础上，把部署到生产环境的过程自动化，持续部署和持续交付的区别就是最终部署到生产环境是自动化的]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>持续集成</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL安装_Windows]]></title>
    <url>%2F2018%2F10%2F05%2F%E6%95%B0%E6%8D%AE%E5%BA%93-2018-10-05-MySQL%E5%AE%89%E8%A3%85-Windows%2F</url>
    <content type="text"><![CDATA[下载页面：https://dev.mysql.com/downloads/mysql/ 选择&quot;Microsoft Windows&quot;,下载免安装版的zip文件; 将zip文件解压到本地 新建一个配置文件（my.ini）用于配置字符集、端口等信息，用以覆盖原始的配置文件（my-default.ini），当然也可以修改这个默认的配置文件 123456789101112131415161718[mysql] # 设置mysql客户端默认字符集 default-character-set=utf8 [mysqld] #设置3306端口 port = 3306 # 设置mysql的安装目录 basedir=D:\\softwares\\mysql-5.7.14-winx64 # 设置mysql数据库的数据的存放目录 datadir=D:\\softwares\\mysql-5.7.14-winx64\\data # 允许最大连接数 max_connections=200 # 服务端使用的字符集默认为UTF8 character-set-server=utf8 # 创建新表时将使用的默认存储引擎 default-storage-engine=INNODB 输入cmd，以管理员身份运行控制台 S C:\Windows\system32&gt; cd S C:\Windows\system32&gt; cd … S C:\Windows&gt; cd … S C:&gt; cd .\mysql-8.0.12-winx64 S C:\mysql-8.0.12-winx64&gt; cd .\bin\ S C:\mysql-8.0.12-winx64\bin&gt; .\mysqld.exe -install ervice successfully installed. S C:\mysql-8.0.12-winx64\bin&gt; net start mysql ySQL 服务正在启动 . ySQL 服务无法启动。 服务没有报告任何错误。 请键入 NET HELPMSG 3534 以获得更多的帮助。 S C:\mysql-8.0.12-winx64\bin&gt; .\mysqld.exe -remove ervice successfully removed. S C:\mysql-8.0.12-winx64\bin&gt; .\mysqld.exe --initialize S C:\mysql-8.0.12-winx64\bin&gt; .\mysqld.exe -install ervice successfully installed. S C:\mysql-8.0.12-winx64\bin&gt; net start mysql ySQL 服务正在启动 . ySQL 服务已经启动成功。 S C:\mysql-8.0.12-winx64\bin&gt; .\mysqladmin.exe -u root password “axn7Og=ve;+2” ysqladmin: connect to server at ‘localhost’ failed alter user user() identified by “root”; alter user user() identified by “新密码”; mysql -u root -p ysql&gt; use mysql atabase changed ysql&gt; ALTER USER ‘root’@‘localhost’ IDENTIFIED WITH mysql_native_password BY ‘root’; uery OK, 0 rows affected (0.04 sec) ysql&gt; flush privileges; uery OK, 0 rows affected (0.00 sec) use mysql 4.ALTER USER ‘root’@‘localhost’ IDENTIFIED WITH mysql_native_password BY ‘root’; 5.flush privileges; 6.可以用navicat登陆了 https://www.cnblogs.com/anstoner/p/6414440.html net stop mysql https://blog.csdn.net/czhilovely/article/details/80360146 https://blog.csdn.net/qq_42923798/article/details/81540122 https://blog.csdn.net/u012561176/article/details/78557320]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL安装_Windows]]></title>
    <url>%2F2018%2F10%2F05%2F%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL%E5%AE%89%E8%A3%85-Windows%2F</url>
    <content type="text"><![CDATA[[toc] 软件准备 mysql从官网下载，包括workbench。 地址： http://dev.mysql.com/downloads/mysql/ http://dev.mysql.com/downloads/workbench/ 安装mysql dmg下载后直接打开，安装过程中，会弹窗里边有随机生成的密码。记好了！不然还得卸载重装。 修改密码(方法一) 进入终端 输入：cd /usr/local/mysql/bin/ su root ./mysqld_safe --skip-grant-tables &amp; //禁止mysql验证功能 在root 模式下 123sh-3.2# alias mysql=/usr/local/mysql/bin/mysqlsh-3.2# alias mysqladmin=/usr/local/mysql/bin/mysqladminsh-3.2# mysqladmin -u root -p password 然后输入临时密码 然后提示输入新密码 修改密码（方法二） 按账号mysql并启动服务 进入终端输入命令行 由于刚刚安装好的mysql密码为空，输入命令：mysql -u root -p 按回车即可登录mysql命令行 显示所有数据库,输入命令：show databases; 进入到名为mysql的数据库 显示出mysql数据库里面的表, 有一个user表，里面就存储的是mysql用户名，密码 打印user表结构 更新authentication_string（相当于windows里面的password字段）字段，此处要用PASSWORD（）函数修改：update user set authentication_string=PASSWORD(‘root’) where user=‘root’; 添加用户 123456789mysql -uroot -punistolllink;GRANT USAGE ON *.* TO &apos;ITS_GANSU&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;ITS_GANSU_STI&apos; WITH GRANT OPTION;use mysql;update user set host=&apos;%&apos; where user=&apos;ITS_GANSU&apos; and host=&apos;localhost&apos;; grant all privileges on *.* to ITS_GANSU@&quot;%&quot; identified by &apos;ITS_GANSU_STI&apos;;flush privileges;exit]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQLServer连接测试]]></title>
    <url>%2F2018%2F10%2F05%2F%E6%95%B0%E6%8D%AE%E5%BA%93-SQLServer%E8%BF%9E%E6%8E%A5%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[windows系统下： 新建文件 后缀改成.udl 打开后，输入IP地址、用户名、密码，选择数据库进行连接]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>SQLServer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo使用速记]]></title>
    <url>%2F2018%2F10%2F04%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-10-hexo%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[说明 Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。详细学习请参考：https://hexo.io/zh-cn/docs 。 本文章只是个人使用过程中重点内容记录。 安装 前置安装：node，git 安装：npm install -g hexo-cli 初始化项目 mkdir [项目名称, 如：test] hexo init [项目名称, 如：test] //此处要求文件夹内为空 cd [项目名称, 如：test] npm install 常用命令 hexo new [layout] ‘【文章名称】’ //创建不通类型文章 1234laytou及路径如下：post source/_postspage sourcedraft source/_drafts hexo clean //清除hexo生成静态网站内容 hexo g //生成hexo静态网站 hexo s //启用hexo服务 hexo d //hexo网站部署，配合hexo-deployer-git插件使用 hexo version //hexo相关软件版本 hexo list [type] //type:post,page等 Front-matter和JSON Front-matter 用来设定文章的一些参数，如是否添加密码、版权、标签、分类等信息。 Front-matter 是文件最上方以 — 分隔的区域，用于指定个别文件的变量，基于YAML 123title: Hello Worlddate: 2013/7/13 20:46:25--- JSON Front-matter 使用 JSON 来编写 Front-matter，只要将 — 代换成 ;;; 即可 123&quot;title&quot;: &quot;Hello World&quot;,&quot;date&quot;: &quot;2013/7/13 20:46:25&quot;;;; 可配置参数如下： 参数 描述 默认值 layout 布局 title 标题 date 建立日期 文件建立日期 updated 更新日期 文件更新日期 comments 开启文章的评论功能 true tags 标签（不适用于分页） categories 分类（不适用于分页） permalink 覆盖文章网址 可以通过直接修改scaffolds内的模版来设定统一的文章额外信息，如： 123456789101112---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;tags: - - categories: password: copyright: truecomments: truetoc: true--- 部署 安装 hexo-deployer-git：npm install hexo-deployer-git --save 配置hexo的_config.yml文件 1234567# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://[XXX]@github.com/[XXX]/[XXX].github.io //库（Repository）地址,如：https://epaypad@github.com/epaypad/epaypad.github.io branch: master //分支名称 message: https://github.com/chetaofeng/MyHexoBlogSource 内容部署 &#123;&#123; now(&apos;YYYY-MM-DD HH:mm:ss&apos;) &#125;&#125; //自定义提交信息 hexo d //命令执行后，稍等一会查看部署结果 hexo主题 hexo默认主题为landscape，大家可以根据各自需要使用不通主题。 本人使用的是NexT主题，使用请参考：http://theme-next.iissnan.com ，NexT更多配置，请参考： https://www.jianshu.com/p/1f8107a8778c]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL安装配置]]></title>
    <url>%2F2018%2F10%2F04%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-11-MySQL%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[简介 下载地址：https://dev.mysql.com/downloads/mysql/ 官方数据客户端工具： https://dev.mysql.com/downloads/workbench/ 推荐客户端工具：Navicat Premium- https://www.navicat.com/en/download/navicat-premium 安装登陆 mac系统 安装dmg安装包，如：mysql-5.7.8-rc-osx10.9-x86_64.dmg，安装过程中会弹出临时的密码，务必截图保存方便后面更改密码，安装过程有时会卡顿，时间会比较长，需耐心等待一会。 在【系统偏好设置】中启动MySQL服务，如果启动不起来，可选择开机启动，然后重启macOS 在MySQLWorkBench中，创建连接信息,hostname-127.0.0.1或localhost，端口3307 点击&quot;Store in Keychain…&quot;输入安装时提示的临时密码后确定 如果临时密码输入正确，则会弹出修改密码界面，修改密码后重新登陆即可 Linux系统 Linux下安装有多种方式： 直接用软件仓库自动安装（如：ubuntu下，sudo apt-get install mysql-server） 通过下载deb或rmp安装包，直接双击安装 下载tar安装包，解压到硬盘，然后自己配置mysql 通过源码编译安装 以下以tar包安装记录:参考文章（http://www.pianshen.com/article/975954037/） sudo cp mysql-8.0.13-linux-glibc2.12-x86_64.tar.xz /usr cd /usr sudo tar xvJf mysql-8.0.13-linux-glibc2.12-x86_64.tar.xz 为MySQL创建专用用户，用户名为mysql，用户组为mysql； sudo groupadd mysql //创建组 sudo useradd -r -g mysql mysql //创建用户并划入mysql组下 为解压出来的所有文件更改用户和组 sudo chown -R mysql mysql-8.0.13-linux-glibc2.12-x86_64 //更改拥有者 sudo chgrp -R mysql mysql-8.0.13-linux-glibc2.12-x86_64 //更改组 sudo apt-get install libaio1 libaio-dev 初始化数据库: sudo ./bin/mysqld --initialize --user mysql 执行过程中会生成一个临时密码，一定要保存好，后面修改密码需要用到，如图： 开启服务: bin/mysqld_safe --user=mysql &amp; 使用用户root登录: bin/mysql -uroot -p 更改root用户密码: 12345ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;root&apos; PASSWORD EXPIRE NEVER; //修改root的密码与加密方式use mysql; #切换到mysql库 update user set host=&apos;%&apos; where user=&apos;root&apos;; //更改可以登录的IP为任意IPALTER user &apos;root&apos;@&apos;%&apos; IDENTIFIED WITH mysql_native_password BY &apos;root&apos;; //再次更改root用户密码，使其可以在任意IP访问flush privileges; #刷新权限 通过客户端测试登陆即可 Navicat安装 Linux 进入安装包所在目录下，如：navicat_premium12_cs_x64_for_linux.zip sudo cp navicat_premium12_cs_x64_for_linux.zip /usr/ cd /usr/ sudo unzip navicat_premium12_cs_x64_for_linux.zip cd navicat120_premium_cs_x64 命令行启动：sudo ./start_navicat，正常的话应该会出现一个Win Mono下载界面，可不下载，跳过即可 Windows &amp; macOS 直接下载安装就行，破解请自行查找]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VirtualBox安装]]></title>
    <url>%2F2018%2F10%2F04%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-11-VirturalBox%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[https://jingyan.baidu.com/article/36d6ed1f821ca21bcf4883da.html]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>容器技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Github Pages进行个人博客搭建]]></title>
    <url>%2F2018%2F10%2F02%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-2018-10-02-GithubPages%2F</url>
    <content type="text"><![CDATA[Github Pages介绍 官网：https://pages.github.com/ GitHub Pages 是一个静态网站托管服务，使用github.io域名和HTTPS来提供服务。一个github账号只能有一个Github Pages网站。 GitHub Pages 网站是在网络上公开使用的，即使他们的库是私有的。如果你敏感的数据在你的Page库中，你可能需要在发布之前删除它。 Github Pages创建 申请邮箱 申请github账号 1前两步是为了准备没有进行Github Pages服务开通的github账号，如果已经有，可以跳过 创建repository。和普通创建一样，但是名称要以&quot;.github.io&quot;结尾，如：test.github.io，这样创建完之后才在这个项目的settings中有github pages选项 访问：https://test.github.io/,即可以看见Github Pages网站 Github Pages网站内容编辑 创建源码repository，用来存放Github Pages网站源码 此处选用Hexo作为网站模版，在本地初始化hexo项目，参考： 在hexo中安装配置hexo-deployer-git进行github项目管理 下载【1】中github代码到本地，本人是通过webstorm进行编辑操作的 拷贝【2】中代码到【1】中的repository中，在本地运行查看hexo效果 编辑.gitignore文件,忽略操作系统文件、编辑器临时文件、node临时文件等，提交 提交repository到github hexo部署本地代码到Github Pages，查看效果]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activity启动模式]]></title>
    <url>%2F2018%2F10%2F02%2F%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91-Activity%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[https://blog.csdn.net/carson_ho/article/details/54669547]]></content>
      <categories>
        <category>移动开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava从源码到应用移动端开发效率秒提速]]></title>
    <url>%2F2018%2F10%2F02%2F%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91-RxJava%2F</url>
    <content type="text"><![CDATA[响应式编程思想概述 响应式编程：是一种面向数据流和变化传播的编程范式 数据流：只能以事先规定好的顺序被读取一次的数据的一个序列 变化传播：类似观察者模式，变化了要通知别人 RxJava源码分析 基本元素 RxJava是一个基于回调的异步的库，是一个基于事件分发和消息传递的库 Operator操作符变换原理 Scheduler线程变换原理 整体变换compose和transformer原理]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>andrioid</tag>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cordova入门]]></title>
    <url>%2F2018%2F10%2F02%2F%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91-Cordova%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[123* 官网网站：http://cordova.apache.org/* 中文文档：http://cordova.axuer.com/docs/zh-cn/latest/guide/overview/index.html* 英文文档：http://cordova.apache.org/docs/en/latest/ 概述 Apache Cordova是一个开源的移动开发框架。允许你用标准的web技术-HTML5,CSS3和JavaScript做跨平台开发。 应用在每个平台的具体执行被封装了起来，并依靠符合标准的API绑定去访问每个设备的功能，比如说：传感器、数据、网络状态等 架构 WebView：Cordova启用的WebView可以给应用提供完整用户访问界面。在一些平台中，他也可以作为一个组件给大的、混合应用，这些应用混合和Webview和原生的应用组件 Web App：这是你应用程序代码存在的地方。应用的实现是通过web页面，默认的本地文件名称是是index.html，这个本地文件应用CSS,JavaScript,图片，媒体文件和其他运行需要的资源。应用执行在原生应用包装的WebView中，这个原生应用是你分发到app stores中的；这个容器中包含一个非常重要文件- config.xml 文件他提供App的重要的信息和特定的参数用来影响App的工作 插件：提供了Cordova和原生组件相互通信的接口并绑定到了标准的设备API上。这使你能够通过JavaScript调用原生代码. 注意:当你创建一个Cordova项目它不存在任何插件。这是新的默认行为。任何你需要的组件，哪怕是核心组件，你也必须明确添加。 开发工作流:Cordova提供两个基本的工作流用来创建移动App. 跨平台(CLI)的工作流:如果你想你的App运行在尽可能多的移动操作系统，那么就使用这个工作流，你只需要很少的特定平台开发。这个工作流围绕这’cordova’CLI(命令行)。CLI把公用的web资源复制到每个移动平台的子目录，根据每个平台做必要的配置变化，运行构建脚本生成2进制文件。一般都是使用这种方式。 平台为中心的工作流:如果你专注于构建单独平台的App或者需要需要在底层修改它那么就使用这个工作流吧。 创建第一个App 安装Cordova CLI 下载和安装Node.js。安装完成后你可以在命令行中使用node 和 npm mac上xcode开发环境已OK mac上Android开发环境已OK，且Android的全局变量已配置，如：ANDROID_HOME 12export ANDROID_HOME=/Users/Neel/Documents/Softwares/adt-bundle-mac-x86_64-20140321/sdkexport PATH=$&#123;PATH&#125;:$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools sudo npm install -g cordova //-g标志是告诉 npm 我们全局安装 cordova 命令行输入cordova,检验是否安装成功 123456789101112CLI命令概要Help：显示可用CLI命令的信息。Create：创建Cordova项目并关联项目文件夹和文件。Plateform：管理Cordova项目使用的移动平台。Plugin：管理Cordova插件的安装和卸载。Prepare：从Cordova项目的www文件夹复制web应用内容到项目移动平台项目文件夹中。Compile：把web应用打包成Cordova应用。Build：先执行Prepare命令然后打包web应用。Emulate：在一个或多个移动设备平台的设备模拟器中运行Cordova应用。Run：在一个或多个移动设备中运行Cordova应用。Serve：启动一个服务器加载web内容以便于用浏览器访问 创建App 方法一：cordova create hello com.example.hello HelloWorld 方法二：webstorm创建 webstorm添加cordova支持：Settings → Plugins webstorm创建项目 添加平台 检查你当前平台设置状况:cordova platform ls，运行add或者remove平台的命令将会影响项目 platforms的内容，在这个目录中每个指定平台都有一个子目录 添加Android平台支持：cordova platform add android --save 添加IOS平台支持：cordova platform add ios --save 添加浏览器支持：cordova platform add browser --save npm install ios-sim -g //如果ios环境，可能需要添加这个 构建及测试 安装构建先决条件检查：cordova requirements 构建App：cordova build，构建所有平台；cordova build ios，构建特定平台 测试：模拟器-cordova emulate android；或者可将手机插入电脑，在手机上直接测试-cordova run android 说明：构建和测试也可通过webstorm直接进行 添加插件 App要接触设备级别的特性，就需要你添加插件了.个插件 通过JavascriptAPI暴露原生SDK功能。插件通常由npm分发(http://cordova.axuer.com/plugins/),一些关键的API由Apache Cordova开源项目提供并且这些插件是作为[核心插件API]的. 搜索插件：cordova plugin search camera 查看当前安装的插件:cordova plugin ls 添加插件：cordova plugin add cordova-plugin-camera //plugin要添加camera插件，我们需要指定camera的npm包名 添加插件：cordova plugin add https://git-wip-us.apache.org/repos/asf/cordova-plugin-camera.git 使用 merges自定义每个平台 顶级merges目录提供了特定平台部署特定资源的地方。每个特定平台在merges中的子目录反映了www 源代码树中的结构， 允许你重写和添加文件。 存放各个平台特殊的文件，会和www进行合并编译，相同的文件merges下的文件优先。 比如： 1234567merges/ |-- ios/ | `-- app.js |-- android/ | `-- android.js www/ `-- app.js 编译成iOS应用的话，包含merges/ios/app.js；而Android应用的话，包含www/app.js、merges/android/android.js hooks目录 存放自定义cordova命令的脚本文件。每个project命令都可以定义before和after的Hook，比如：before_build、after_build。 Hook可以采用任何编程语言来写，Cordova CLI采用的是Node.js，所以一般都是用它来写 更新Cordova和项目 要查找最新的cordova版本:npm info cordova version 查看当前版本:cordova -v 更新到最新版本:sudo npm update -g cordova 安装指定版本:sudo npm install -g cordova@3.1.0-0.2.0 更新目标项目的平台:cordova platform update android --save 平台开发 查看所有支持的模拟器：cordova run --list Android 要想知道你的Cordova项目中安装的Cordova Android包的版本，你可以在项目目录中运行cordova platform ls 平台搭建过程 安装Java Development Kit (JDK) 7或者最新的 安装Android SDK 添加SDK包： 1Android API级别查看：http://developer.android.com/guide/topics/manifest/uses-sdk-element.html#ApiLevels 打开Android SDK Manager (例如，在终端上运行`android)，并确保下面已经安装: 目标Android版本的Android Platform SDK Android SDK build-tools，版本19.1.0或者之上 Android Support Repository (在&quot;Extras&quot;查找) 设置环境变量 设置JAVA_HOME环境变量，指定为JDK安装路径 设置ANDROID_HOME环境变量，指定为Android SDK安装路径 添加Android SDK的tools和platform-tools目录到你的PATH Android Studio调试 Cordova的Android项目可以被Android IDEAndroid Studio打开; 如果你想使用Android Studio内置的Android调试/分析工具或者你要开发Android插件这是十分有用的 在Android Studio中打开Cordova的Android项目: 启动 Android Studio. 选择 Import Project (Eclipse ADT, Gradle, etc). 选择你项目中的Android platform目录(/platforms/android) 对于Gradle Sync问题你可以简单的回答 Yes. ==注意==：当在Android studio里打开你的项目，建议你不要编辑你的代码在IDE中。这会在 platforms目录中编辑你的代码(而不是 www),并且变化将会被重写。而是编辑www目录并通过运行cordova build来拷贝过来你的变化。 6. Cordova和Android的生命周期 Cordova事件 粗略的Android等效 含义 deviceready onCreate() 应用程序开始(不是从背景) pause onPause() 应用程序移动到背景 resume onResume() 应用程序返回到前景 关于生命周期： 在Android设备中，操作系统可以选择在后台杀死活动来释放资源，如果当前设备运行程序的内存过低。由于这个原因，你的应用程序知道生命周期被触发并维持任何确保用户在离开应用程序用户上下文不丢失的状态，是必须的。 应该通过bindEvents 方法来注册应用程序回调来回应生命周期事件来保存状态。保存什么息和怎么保存信息由你决定，但是你要确保保存足够的信息，来精确的恢复到用户离开的地方 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485// 这个状态代表了应用程序的状态并且会在onResume()和onPause()中保存和恢复var appState = &#123; takingPicture: true, imageUri: &quot;&quot;&#125;;var APP_STORAGE_KEY = &quot;exampleAppState&quot;;var app = &#123; initialize: function() &#123; this.bindEvents(); &#125;, bindEvents: function() &#123; // 这里我们注册我们关心的生命周期事件回调 document.addEventListener(&apos;deviceready&apos;, this.onDeviceReady, false); document.addEventListener(&apos;pause&apos;, this.onPause, false); document.addEventListener(&apos;resume&apos;, this.onResume, false); &#125;, onDeviceReady: function() &#123; document.getElementById(&quot;take-picture-button&quot;).addEventListener(&quot;click&quot;, function() &#123; //由于camera插件方法启动了一个外部活动 //这里有一次机会我们的应用程序被kill掉在回调被成功或者失败调用之前 // 在onPause()和onResume()那里我们保存和恢复状态，来处理这个事情 appState.takingPicture = true; navigator.camera.getPicture(cameraSuccessCallback, cameraFailureCallback, &#123; sourceType: Camera.PictureSourceType.CAMERA, destinationType: Camera.DestinationType.FILE_URI, targetWidth: 250, targetHeight: 250 &#125; ); &#125;); &#125;, onPause: function() &#123; // 这里我们检测我们是否在获取图片，如果在，我们希望保存我们的状态以便onResume() // 恢复的时候使用，如果我们获得了图片URI我们也要存储 if(appState.takingPicture || appState.imageUri) &#123; window.localStorage.setItem(APP_STORAGE_KEY, JSON.stringify(appState)); &#125; &#125;, onResume: function(event) &#123; // 这里我们检差存储的状态，如果需要恢复他。由你跟踪任何添加的插件结果的来源 // (也就是说你代码的哪一步被调用)，还有什么参数提供给插件如果相关 var storedState = window.localStorage.getItem(APP_STORAGE_KEY); if(storedState) &#123; appState = JSON.parse(storedState); &#125; // 检查如果我们需要恢复我们的图片 if(!appState.takingPicture &amp;&amp; appState.imageUri) &#123; document.getElementById(&quot;get-picture-result&quot;).src = appState.imageUri; &#125; // 现在我们可以检测如果插件结果在事件对象里面 // 这里需要cordova-android 5.1.0+ else if(appState.takingPicture &amp;&amp; event.pendingResult) &#123; // 检测插件调用是否成功并调用相应的回调。对于camera插件，&quot;OK&quot; //意味着成功其他意味着错误 if(event.pendingResult.pluginStatus === &quot;OK&quot;) &#123; // camera放置同样的结果在resume对象，因为成功回调传递给了getPicture(), // 因此我们可以传递同样的回调，返回一些其他东西。查询文档，了解怎么解释你使用 // 插件的结果字段 cameraSuccessCallback(event.pendingResult.result); &#125; else &#123; cameraFailureCallback(event.pendingResult.result); &#125; &#125; &#125;&#125;// 这里是回调我们传入getPicture()function cameraSuccessCallback(imageUri) &#123; appState.takingPicture = false; appState.imageUri = imageUri; document.getElementById(&quot;get-picture-result&quot;).src = imageUri;&#125;function cameraFailureCallback(error) &#123; appState.takingPicture = false; console.log(error);&#125;app.initialize(); 自定义图标(Icon) 对启动画面(splash screen)的支持已经被移动到Cordova自己的插件中了，http://cordova.axuer.com/docs/zh-cn/latest/reference/cordova-plugin-splashscreen/ 当工作在CLI工作流中，你可以通过元素(config.xml)定义你的app图标。如果没用指定图标将使用ApacheCordova的logo. 属性 描述 src 必要 图片文件位置，相对于项目根路径 platform 可选 目标平台 width 可选 图片的像素宽度 height 可选 图片的像素高度 density 可选 Android 指定图标密度 target 可选 Windows 图片文件和所有多渲染目标(MRT)伙伴的目标文件名 1&lt;icon src=&quot;res/icon.png&quot; /&gt; //用来定义用于所有平台的唯一默认图标 Android 12345678910111213141516&lt;platform name=&quot;android&quot;&gt; &lt;!-- ldpi : 36x36 px mdpi : 48x48 px hdpi : 72x72 px xhdpi : 96x96 px xxhdpi : 144x144 px xxxhdpi : 192x192 px --&gt; &lt;icon src=&quot;res/android/ldpi.png&quot; density=&quot;ldpi&quot; /&gt; &lt;icon src=&quot;res/android/mdpi.png&quot; density=&quot;mdpi&quot; /&gt; &lt;icon src=&quot;res/android/hdpi.png&quot; density=&quot;hdpi&quot; /&gt; &lt;icon src=&quot;res/android/xhdpi.png&quot; density=&quot;xhdpi&quot; /&gt; &lt;icon src=&quot;res/android/xxhdpi.png&quot; density=&quot;xxhdpi&quot; /&gt; &lt;icon src=&quot;res/android/xxxhdpi.png&quot; density=&quot;xxxhdpi&quot; /&gt; &lt;/platform&gt; IOS 12345678910111213141516171819202122232425262728&lt;platform name=&quot;ios&quot;&gt; &lt;!-- iOS 8.0+ --&gt; &lt;!-- iPhone 6 Plus --&gt; &lt;icon src=&quot;res/ios/icon-60@3x.png&quot; width=&quot;180&quot; height=&quot;180&quot; /&gt; &lt;!-- iOS 7.0+ --&gt; &lt;!-- iPhone / iPod Touch --&gt; &lt;icon src=&quot;res/ios/icon-60.png&quot; width=&quot;60&quot; height=&quot;60&quot; /&gt; &lt;icon src=&quot;res/ios/icon-60@2x.png&quot; width=&quot;120&quot; height=&quot;120&quot; /&gt; &lt;!-- iPad --&gt; &lt;icon src=&quot;res/ios/icon-76.png&quot; width=&quot;76&quot; height=&quot;76&quot; /&gt; &lt;icon src=&quot;res/ios/icon-76@2x.png&quot; width=&quot;152&quot; height=&quot;152&quot; /&gt; &lt;!-- iOS 6.1 --&gt; &lt;!-- Spotlight Icon --&gt; &lt;icon src=&quot;res/ios/icon-40.png&quot; width=&quot;40&quot; height=&quot;40&quot; /&gt; &lt;icon src=&quot;res/ios/icon-40@2x.png&quot; width=&quot;80&quot; height=&quot;80&quot; /&gt; &lt;!-- iPhone / iPod Touch --&gt; &lt;icon src=&quot;res/ios/icon.png&quot; width=&quot;57&quot; height=&quot;57&quot; /&gt; &lt;icon src=&quot;res/ios/icon@2x.png&quot; width=&quot;114&quot; height=&quot;114&quot; /&gt; &lt;!-- iPad --&gt; &lt;icon src=&quot;res/ios/icon-72.png&quot; width=&quot;72&quot; height=&quot;72&quot; /&gt; &lt;icon src=&quot;res/ios/icon-72@2x.png&quot; width=&quot;144&quot; height=&quot;144&quot; /&gt; &lt;!-- iPhone Spotlight and Settings Icon --&gt; &lt;icon src=&quot;res/ios/icon-small.png&quot; width=&quot;29&quot; height=&quot;29&quot; /&gt; &lt;icon src=&quot;res/ios/icon-small@2x.png&quot; width=&quot;58&quot; height=&quot;58&quot; /&gt; &lt;!-- iPad Spotlight and Settings Icon --&gt; &lt;icon src=&quot;res/ios/icon-50.png&quot; width=&quot;50&quot; height=&quot;50&quot; /&gt; &lt;icon src=&quot;res/ios/icon-50@2x.png&quot; width=&quot;100&quot; height=&quot;100&quot; /&gt; &lt;/platform&gt; 存储数据 LocalStorage LocalStorage提供了简单和同步的键值对存储方式，而且在各个Cordova平台，底层的WebView实现都支持它。 LocalStorage可以通过window.localStorage访问到。以下的代码片段展示了返回的storage对象的最重要的几个方法。 1234var storage = window.localStorage;var value = storage.getItem(key); // 传递键的名字获取对应的值。storage.setItem(key, value) // 传递键的名字和对应的值去添加或者更新这个键值对。storage.removeItem(key) // 传递键的名字去从LocalStorage里删除这个键值对。 SQLite 插件 cordova-sqlite-storage - 包含sqlite3实现的核心版本，它支持iOS, Android和Windows平台。 cordova-sqlite-ext - 包含Android和iOS的正则支持等额外特性的扩展版本。 cordova-sqlite-evfree - 与cordova-sqlite-ext类似，但提供了高级的内存管理。GPL版本低于v3或者有商业许可的话可用。 安全管理建议 使用app内置浏览器打开外链：因为app内置浏览器会使用原生浏览器的安全特性，而且不会让你的Cordova环境被外部访问到 校验所有的用户输入，服务端同样需要验证输入，特别是在传递数据到后台服务之前。 不要缓存敏感信息 不要使用eval()除非你知道你自己正在做什么 白名单 外部域是应用无法控制的，而域名白名单则是一种控制访问外部域的安全模型。Cordova提供了一项可配置的安全策略来定义哪些外部站点可以访问。默认情况下，新的app被配置成可以访问任何站点。然而在发布到生产环境前，你应该制定一份白名单，限制应用可以访问的域名和子域名。 对于Android 可以使用cordova-plugin-whitelist实现，虽然实现白名单插件是可能的，但还是不推荐这样做，除非你的app有非常明确的安全策略需要 对于其他平台 依赖于使用app的config.xml文件里的标签，它是用来声明可以访问的特定域名的。 事件 Cordova给我们提供了很多的事件，可以在应用程序中使用。应用程序代码中可以添加这些事件的监听。事件相关定义都在www/js/index.js中 支持的平台/ 事件 android ios 备注 deviceready Cordova设备API准备好并可以访问的信号 pause 当原生平台把应用程序放入后台这个pause事件会触发，通常是用户切换到了不同的应用程序 resume 当原生平台将应用程序从后台运行拉出resume事件就会触发 backbutton X 当用户按下返回按钮事件触发 menubutton X 当用户按下菜单按钮事件触发 searchbutton X 当用户按下搜索按钮事件触发 startcallbutton X X 当用户按下通话按钮事件触发 endcallbutton X X 当用户按下挂断通话按钮事件触发 volumedownbutton X 当用户按下降低声音按钮事件触发 volumeupbutton X 当用户按下增加声音按钮事件触发 参考 config.xml http://cordova.axuer.com/docs/zh-cn/latest/config_ref/index.html 问题解决： https://forum.ionicframework.com/t/ionic-3-ionic-serve-error-cannot-read-property-filter-of-undefined/85682/11 http://ionicframework.com/docs/components/#overview http://www.runoob.com/ionic/ionic-tutorial.html https://creator.ionic.io/app/dashboard/projects 123456789101112131415ionic run ios --deviceionic run ios --emulatorionic run ios --target=&quot;iPhone-5s&quot;ionic run ios --target=&quot;iPhone-6&quot;ionic run ios --target=&quot;iPhone-6s&quot;ionic run ios --emulator --target=&quot;iPhone-6s&quot; -l http://localhost:8100/ ios-sim showdevicetypescordova run ios --target &quot;iPad-Pro&quot; --emulatorxcrun simctl list devices ios-sim命令行工具。 ios-sim 是一个可以在命令控制iOS模拟器的工具。利用这个命令，我们可以启动一个模拟器，安装app，启动app，查询iOS SDK。它可以使我们像自动化测试一样不用打开Xcode。 1234567891011121314151617181920212223242526272829303132Usage: ios-sim &lt;command&gt;&lt;/command&gt; &lt;options&gt; [--args ...] Commands: showsdks List the available iOS SDK versions showdevicetypes List the available device types launch &lt;application path&gt; Launch the application at the specified path on the iOS Simulator start Launch iOS Simulator without an app install &lt;application path&gt; Install the application at the specified path on the iOS Simulator without launching the app Options: --version Print the version of ios-sim --help Show this help text --exit Exit after startup --log &lt;log file path&gt; The path where log of the app running in the Simulator will be redirected to --devicetypeid &lt;device type&gt; The id of the device type that should be simulated (Xcode6+). Use &apos;showdevicetypes&apos; to list devices. e.g &quot;com.apple.CoreSimulator.SimDeviceType.Resizable-iPhone6, 8.0&quot; Removed in version 4.x: --stdout &lt;stdout file path&gt; The path where stdout of the simulator will be redirected to (defaults to stdout of ios-sim) --stderr &lt;stderr file path&gt; The path where stderr of the simulator will be redirected to (defaults to stderr of ios-sim) --sdk &lt;sdkversion&gt; The iOS SDK version to run the application on (defaults to the latest) --family &lt;device family&gt; The device type that should be simulated (defaults to `iphone&apos;) --retina Start a retina device --tall In combination with --retina flag, start the tall version of the retina device (e.g. iPhone 5 (4-inch)) --64bit In combination with --retina flag and the --tall flag, start the 64bit version of the tall retina device (e.g. iPhone 5S (4-inch 64bit)) Unimplemented in this version: --verbose Set the output level to verbose --timeout &lt;seconds&gt; The timeout time to wait for a response from the Simulator. Default value: 30 seconds --args &lt;...&gt; All following arguments will be passed on to the application --env &lt;environment file path&gt; A plist file containing environment key-value pairs that should be set --setenv NAME=VALUE Set an environment variable&lt;/environment file path&gt;&lt;/seconds&gt;&lt;/device family&gt;&lt;/sdkversion&gt;&lt;/stderr file path&gt;&lt;/stdout file path&gt;&lt;/device type&gt;&lt;/log file path&gt;&lt;/application path&gt;&lt;/application path&gt;&lt;/options&gt; ios-sim launch /Users/YDZ/Desktop/app.app --devicetypeid iPhone-6s 其中，/Users/YDZ/Desktop/app.app这个是设计师收到app之后的路径。–devicetypeid参数后面是给定一个模拟器的版本。 只需要把上面的命令发给设计师，无脑粘贴到命令行，装好app的模拟器就会自动启动，打开app了。 大公司的话可以应该有两个账号，一个上appstore的开发账户，这个严格保密。还有一个打线下包的企业账号，这样就能达到需求了]]></content>
      <categories>
        <category>移动开发</category>
      </categories>
      <tags>
        <tag>Cordova</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gradle3.0自动化项目构建技术]]></title>
    <url>%2F2018%2F10%2F02%2F%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91-Gradle3-0%E8%87%AA%E5%8A%A8%E5%8C%96%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[Groovy快速入门 领域特定语言DSL（Domain Specific Language）：其核心思想为&quot;求专不求全，解决特定问题&quot;， Groovy： http://www.groovy-lang.org/ Groovy：是一种基于JVM的敏捷开发语言，结合了Python、Ruby等脚本语言的许多强大特性，可以与Java完美结合，使用Java的所有库； 语法上支持动态类型，闭包等新一代语言特性 无缝继承所有Java的库（可以完全用Java写，但是不推荐） 即支持面向对象编程，也支持面向过程编程 优势：一种更加敏捷的编程语言；入门非常容易，但是功能非常强大；既可以作为编程语言也可以作为脚本语言；熟练掌握Java的人会非常容易掌握Groovy Groovy开发环境搭建： java平台上有各种语言的翻版，例如kotlin对c#,scala对haskell,Clojure对lisp，groovy对ruby macOS/Linux 安装配置好JDK 下载Groovy SDK并解压到合适未知 配置bin目录到/.bash_profile中，如添加如下内容到/.bash_profile 1export PATH=$PATH:/usr/groovy-2.5.5/bin groovy -version InteliJ IDEA配置 确保已安装Groovy插件 配置Groovy SDK未知 编写Groovy版本HelloWorld，注意查看编译后文件 123456//Java版本class Test &#123; public static void main(String[] args)&#123; System.out.println(&quot;Hello world&quot;); &#125;&#125; 12//Groovy版本print &quot;Hello world&quot; Groovy基础语法 变量 变量的类型：基本类型+对象类型，Groovy中没有基本类型，所有的基本类型都会被编译器包装成对象类型，如：int-&gt;Integer 变量的定义：强类型定义方式+弱类型def定义方式，Groovy中如果变量的值可以推断除其类型，则可通过def声明为弱类型，区别于java中的强类型定义方式，如：int i=1； 推荐在自有使用模块使用def方式定义，如果有其他模块或其他类使用推荐强类型定义方式 字符串：String + GString String的使用和Java中一致，GString定义方式如下： def name = ‘Hello name’ //不支持可扩展字符串 def doubleName = “Hello doubleName” //可扩展字符串，如：def doubleName = “Hello doubleName and ${name}”,结果为： Hello doubleName and Hello name，此时doubleName是org.codehaus.groovy.runtime.GStringImpl的子类 def thupleName = ‘’‘Hello thupleName’’’ //支持多行方式 无可扩展字符串时以上3种方式的String都是java.lang.String的子类，编码过程中String和GString是可以通用的，更多从方便使用角度考虑即可 Groovy字符串方法介绍 java中String原有的方法 DefalutGroovyMethods StringGroovyMethods：普通类型的参数+闭包类型的参数 12345678910def str = &quot;Groovy&quot;，str2 = &quot;Hello&quot;,str3= &quot;Hello minus&quot;//字符串填充:center(),paddingLeft(),paddingRight()println str.center(8,&apos;a&apos;) //aGroovya//字符串比较：类似于数字比较；compareTo()println str &gt; str2 //false//获取字符串索引:类似于数组下标；charAt()println str[0..1] //Gr//减法运算:类似于数字减法；minus()println str3.minus(str2) // minus//其他方法自己摸索 逻辑控制：单步顺序执行|if／else|switch-case|while|for，基本和Java操作一致，针对Groovy扩展介绍如下： 123456789101112131415161718192021//switch-casedef x=1.23,resultswitch(x)&#123; //switch(x.class) case &quot;name&quot;: result = &quot;name&quot; break case Integer: result = &quot;Integer&quot; break case BigDecimal: result = &quot;BigDecimal&quot; break case [1,2,3]: //列表 result = &quot;list&quot; break case 1..10: //范围 result = &quot;range&quot; default: result=&quot;defalut&quot;&#125;println result //BigDecimal for循环控制 1234567891011121314//对范围的for循环def sum =0for(i in 0..9)&#123; sum += i&#125;println sum //45//对list的for循环for(i in [1,2,3,4,5])&#123; sum += i&#125;//对map的for循环for(i in [&quot;lili&quot;:1,&quot;lucy&quot;:2])&#123; println i.key + &quot;:&quot; +i.value&#125; 闭包 闭包就是一个代码块，所以需要通过{}括起来，def clouser = { println “Hello Groovy!”};clouser.call();clouser(); //推荐call()方式调用来区分是闭包 def clouser = {String name -&gt; println “Hello Groovy ${name}!”};clouser.call(“a”);clouser(“b”); 隐式参数it：def clouser = {println “Hello Groovy ${it}!”};clouser.call(“a”);clouser(“b”); 闭包返回值：总是有返回值的，当闭包体没有明确返回值的时候，返回结果就是null 如果最后一个参数是闭包，闭包可以写在外面 闭包的使用 与基本类型的结合使用 123456789101112131415161718192021int fab1(int number)&#123; int result = 1 1.upto(number,&#123;num -&gt; result *= num &#125;) return result&#125;int fab2(int number)&#123; int result = 1 number.downto(1) &#123; num -&gt; result *= num &#125; return result&#125;int cal(int number)&#123; int result = 0 number.times &#123; num -&gt; result += num &#125; return result&#125; 与String结合使用 123456def str = &quot;the 2 and 3 is 5&quot;str.each &#123;String tmp -&gt; print tmp.multiply(2)&#125; //tthhee 22 aanndd 33 iiss 55println str.find &#123;String tmp -&gt; tmp.isNumber()&#125; //2println str.any &#123;String tmp -&gt; tmp.isNumber()&#125; //trueprintln str.every &#123;String tmp -&gt; tmp.isNumber()&#125; //falsedef list = str.collect &#123;it.toUpperCase()&#125;;println list.toListString() //[T, H, E, , 2, , A, N, D, , 3, , I, S, , 5] 与数据结构结合使用 与文件等结合使用 闭包进阶：闭包关键字（this，owner，delegate）+闭包委托策略 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465def scriptClosure = &#123; println &quot;scriptClosure this:&quot;+this //代表闭包定义处的类 println &quot;scriptClosure owner:&quot;+owner //代表闭包定义处的类或对象 println &quot;scriptClosure delegate:&quot;+delegate //代表任意对象，默认值为owner&#125;scriptClosure.call()//scriptClosure this:Test@3c130745//scriptClosure owner:Test@3c130745//scriptClosure delegate:Test@3c130745class Person&#123; def static classClosure = &#123; println &quot;classClosure this:&quot;+this println &quot;classClosure owner:&quot;+owner println &quot;classClosure delegate:&quot;+delegate &#125; def static say()&#123; def methodClosure = &#123; println &quot;methodClosure this:&quot;+this println &quot;methodClosure owner:&quot;+owner println &quot;methodClosure delegate:&quot;+delegate &#125; methodClosure.call() &#125;&#125;//静态方法调用Person.classClosure()Person.say()//全部指向Person类,闭包指向离他最近的封闭类//classClosure this:class Person//classClosure owner:class Person//classClosure delegate:class Person//methodClosure this:class Person//methodClosure owner:class Person//methodClosure delegate:class Person//修改Person类中方法，取消static限定符调用Person p = new Person()p.classClosure()p.say()//全部指向Person类对象，闭包指向离他最近的封闭类对象classClosure this:Person@a9cd3b1classClosure owner:Person@a9cd3b1classClosure delegate:Person@a9cd3b1methodClosure this:Person@a9cd3b1methodClosure owner:Person@a9cd3b1methodClosure delegate:Person@a9cd3b1//嵌套闭包def outerClosure = &#123; def innerClosure = &#123; println &quot;innerClosure this:&quot;+this println &quot;innerClosure owner:&quot;+owner println &quot;innerClosure delegate:&quot;+delegate &#125; innerClosure.call()&#125;outerClosure.call()//innerClosure this:Test@3c130745//innerClosure owner:Test$_run_closure7@9353778 //指向outerClosure//innerClosure delegate:Test$_run_closure7@9353778 总结：this、owner、delegate的值在大多数情况都是一样的，在嵌套闭包中this的值和owner、delegate的值不一致，只有在给delegate赋值后owner和delegate的值才不一致 闭包的委托策略 123456789101112131415161718192021222324class Student&#123; String name def sayName = &#123; &quot;My name is $&#123;name&#125;&quot;&#125; String toString()&#123; sayName.call() &#125;&#125;class Teacher&#123; String name&#125;def stu = new Student(name: &quot;XingFeng&quot;)println stu.toString()def tea = new Teacher(name: &quot;Lily&quot;)stu.sayName.delegate = teaprintln stu.toString()stu.sayName.resolveStrategy = Closure.DELEGATE_FIRST //先从delegate中查找name属性，没有了再从owner中查找println stu.toString()//My name is XingFeng//My name is XingFeng//My name is Lily 数据结构 列表的定义：def list = [1,2,3,4] 此为一个ArrayList； 数组的定义：def list = [1,2,3,4] as int[]; int[] arr=[1,2,3] 列表的排序：def list = [1,12,3,444]; Collections.sort(list);list.sort() map的定义：def colors=[“red”:1,“blue”:2];def colors=[red:1,blue:2] 索引map：println colors.red;println colors[“red”]; 添加map：colors.yellow=3 //Groovy中map可以添加不同类型的数据：colors.complex =[a:1,b:2] 遍历map： list.each{def tmp,int index -&gt; …} list.eachWithIndex{ key,value,index -&gt; …} 查找map： any find findAll every 分组map： groupBy{} 排序map：sort 范围Range：定义 def range = 1…10;println range[0];range.contains(10);println range.from;println range.to Range继承自java.util.List 1234switch(number)&#123; case 0..&lt;60 ...&#125; 面向对象 类、接口等的定义和使用 Groovy中默认类、方法等都是public类型 Groovy中无论是直接调用属性还是通过get／set方法其实质都是通过getter／setter方法调用的属性，getter／setter方法默认自动继承 接口实现需实现接口的所有方法；trait中可以有默认方法实现，没有实现的方法需添加abstract关键字，实现时只需实现abstract的方法即可 元编程（Metaprogramming）是指某类计算机程序的编写，这类计算机程序编写或者操纵其他程序（或者自身）作为它们的数据，或者在运行时完成部分本应在编译时完成的工作。很多情况下与手工编写全部代码相比工作效率更高。编写元程序的语言称之为元语言，被操作的语言称之为目标语言。一门语言同时也是自身的元语言的能力称之为反射 元编程通常有两种方式起作用。一种方式是通过应用程序接口（API）来暴露运行时引擎的内部信息。另一种方法是动态执行包含编程命令的字符串。因此，“程序能编写程序”。虽然两种方法都能用，但大多数方法主要靠其中一种。 123456789101112class Baby &#123; def invokeMethod(String name,Object args)&#123; return &quot;the method is $&#123;name&#125;,the args is $&#123;args&#125;&quot; &#125; def methodMissing(String name,Object args)&#123; return &quot;the method $&#123;name&#125; is missing&#125;&quot; &#125;&#125;def baby = new Baby()println baby.cry() 结合上图理解：Java中对象方法的调用没有上图否流程分支，在Groovy中对象方法调用有否分支调用，上例中通过注释invokeMethod、methodMissing方法查看运行效果，通过以下代码可动态添加对象属性和方法： 123Baby.metaClass.sex = &quot;male&quot;Baby.metaClass.play = &#123; ... &#125;Baby.metaClass.static.play = &#123; ... &#125; //静态方法 通过ExpandoMetaClass.enableGlobally()设置让动态添加方法全局启用 Json操作 对象转换成JSON字符串：JsonOutput.toJson() Json格式化打印：JsonOutput.prettyPrint(jsonObject) Json字符串转对象：def jsonSlurper = new JsonSlurper();jsonSlurper.parse() xml操作 Java对xml的处理：DOM文档驱动处理方式+SAX事件驱动处理方式 Groovy解析xml数据：def xmlSlurper = new XmlSlurper();def response = xmlSlurper.parse(xml); ／／response对象可以逐级访问节点，节点的属性添加@符号，如：response.books.@id，也可以通过闭包过滤信息 Groovy深度遍历xml：可以通过逐级遍历解析后的response数据，也可通过response.depFirst().find{ …}遍历或 response.’’.find{ …}遍历（’'代表深度遍历） Groovy深度遍历xml：response.books.children().find{…}或response.books.’’.find{…}（’'代表深度遍历） Groovy创建xml数据： 12345678910111213141516171819202122&apos;&apos;&apos;&lt;langs type=&apos;current&apos; count=&apos;3&apos;&gt; &lt;language flavor=&apos;static&apos; version=&apos;1.5&apos; /&gt; &lt;language flavor=&apos;public&apos; version=&apos;2.5&apos; /&gt;&lt;/langs&gt;&apos;&apos;&apos;def sw = new StringWriter()def xmlBuilder = new MarkupBuilder(sw)xmlBuilder.langs(type:&apos;current&apos;,count:3)&#123; language(flavor:&apos;static&apos;,version:&apos;1.5&apos;) language(flavor:&apos;public&apos;,version:&apos;2.5&apos;)&#125;println swdef langs = new Langs()xmlBuilder.langs(type:langs.type,count:langs.count)&#123; langs.languages.each &#123; language(flavor:it.flavor,version:it.version) &#125;&#125;println sw 文件操作 Java文件处理：节点流（InputStream、OutputStream及其子类）+处理流（Reader、Writer及其子类），所有Java对文件的操作Groovy都支持 遍历文件内容：def file = new File(“Test.iml”);file.eachLine { println it } 或 def text = file.getText() 或 def text = file.readLines() … gradle Gradle是一款最新的，功能强大的构建工具，使用程序代替传统的xml配置，项目构建更加灵活，有丰富的第三方库 gradle组成：groovy核心语法+build script block+gradle api gradle生命周期 执行./gradlew clean 观察执行过程，其生命周期包括：初始化、配置、执行 gradle生命周期的监听 在项目的build.gradle中添加如下 12345678//在配置阶段开始之前的回调this.beforeEvaluate &#123;&#125;//配置阶段完成以后的回调this.afterEvaluate &#123;&#125;//gradle生命周期执行完以后的回调this.gradle.buildFinished &#123;&#125; Gradle Project ./gradlew projects //查看工程Project数量，学会区分Project与module及根Project与子Project，每个Project必须有一个build.gradle文件 Project API组成： Project相关API：如何管理父Project及如何操作子Project this.getAllProjects()，this.getSubProjects(),this.getParent()，在gradl文件中，对应allprojects、project、subprojects进行操作 ./gradlew projects可实现显示所有项目，自我实现如下： 12345678910111213141516def getProjects()&#123; println &quot;------------------------&quot; this.getAllprojects().eachWithIndex&#123; Project project, int index -&gt; if(index == 0)&#123; println &quot;Root project:$&#123;project.name&#125;&quot; &#125;else&#123; println &quot;+--- project:$&#123;project.name&#125;&quot; &#125; &#125;&#125;this.getProjects()//------------------------//Root project:MyApplication//+--- project:app task相关API 属性相关API 父Project的属性在子项目中会被继承，可直接使用 可以在项目中通过common.gradle文件来定义扩展属性ext，然后在根Project中通过apply from:this.file(‘common.gradle’)引入后，按rootProject.ext.定义属性的方式使用 在gradle.properties中定义key-value属性，如：isLoadTest=false，然后在settings.gradle中就可以编码控制是否加载Test项目 123if(hasProperty(&apos;isLoadTest&apos;)? isLoadTest.toBoolean() : false)&#123; include &apos;:Test&apos;&#125; 自定义属性的两种方式：ext方式+gradle.properties中定义 4. file相关API 路径获取API：getRootdir()、getBuildDir()、getProjectDir() 文件操作相关API：都是基于根工程操作的，不支持跨工程操作 123456789//文件／文件夹拷贝copy &#123; from file(&apos;test.txt&apos;) into getRootProject().getBuildDir()&#125;//文件树遍历fileTree(&apos;build/&apos;)&#123; FileTree fileTree -&gt; fileTree.visit&#123; FileTreeElement element -&gt; ... &#125;&#125; gradle生命周期API 其他API 依赖相关API 12345678910111213141516171819buildscript &#123; repositories &#123; google() jcenter() &#125; dependencies &#123; classpath &apos;com.android.tools.build:gradle:3.2.1&apos; &#125;&#125;//等价于以下操作：buildscript &#123; ScriptHandler scriptHandler -&gt; scriptHandler.repositories &#123; RepositoryHandler repositoryHandler -&gt; repositoryHandler.google() repositoryHandler.jcenter() &#125; scriptHandler.dependencies &#123; classpath &apos;com.android.tools.build:gradle:3.2.1&apos; &#125;&#125; 依赖传递：A模块依赖B模块，B模块依赖C模块，如果A模块也需要C模块功能，不需依赖使用，防止B修改后去掉C依赖而导致错误，可在A中引入C模块，通过exclude排除依赖，transitive禁止依赖传递 占位编译provided：A.类库只在编译阶段起作用 B.父项目已引入类库，子项目直接使用父项目类库，但为了子项目编译通过使用占位编译 外部命令执行 1234567891011121314task abc() &#123; doLast&#123; def command = &apos;ls&apos; exec&#123; try&#123; executable &apos;bash&apos; args &apos;-c&apos;,command println &apos;command is execute success.&apos; &#125;catch(GradleException ex)&#123; println &quot;Excepiotn....&quot; &#125; &#125; &#125;&#125; 执行：./gradlew abc Task Task定义及配置 直接通过task函数去创建 1234567891011121314task(&quot;abcd&quot;) &#123; doLast&#123; def command = &apos;ls -al&apos; exec&#123; try&#123; executable &apos;bash&apos; args &apos;-c&apos;,command println &apos;command is execute success.&apos; &#125;catch(GradleException ex)&#123; println &quot;Excepiotn....&quot; &#125; &#125; &#125;&#125; 通过TaskContainer创建 123this.tasks.create(&quot;aa&quot;)&#123; println &apos;Hello task&apos;&#125; Task创建之后可在开发工具的gradle插件重查找到task，如果没有设置group，则默认在other分组中，更多配置可通过task源码查看 2. Task执行详解 doFirst/doLast执行阶段执行，否则在配置阶段执行 1234567891011task aa&#123; doFirst&#123; println &apos;Hello 2&apos; &#125;&#125;task.doFirst&#123; println &apos;Hello 1&apos;&#125;//Hello 1//Hello 2 编写一个统计build时长的task app.gradle中编写： 12345678910111213def startBuilderTime,endBuilderTimethis.afterEvaluate &#123; Project project -&gt; def preBuildTask = this.tasks.getByName(&quot;preBuild&quot;) preBuildTask.doFirst &#123; startBuilderTime = System.currentTimeMillis() println &apos;------开始计时...&apos; &#125; def buildTask = this.tasks.getByName(&quot;build&quot;) buildTask.doLast &#123; endBuilderTime = System.currentTimeMillis() println &apos;------计时结束,耗时：&apos;+(endBuilderTime - startBuilderTime) &#125;&#125; ./gradlew build执行查看结果 3. Task的依赖及执行顺序 dependsOn强依赖方式 12345678910111213task t1() &#123; doLast&#123;println &apos;task t1&apos;&#125; &#125;task t2() &lt;&lt; &#123; println &apos;task t2&apos; &#125; //此处&quot;&lt;&lt;&quot;等同于doLasttask t3(dependsOn:[t1,t2]) &#123; doLast&#123;println &apos;task t3&apos;&#125; &#125;task t4() &#123; dependsOn this.tasks.findAll &#123; task -&gt; return task.name.equals(&quot;t2&quot;)&#125;;doLast&#123;println &apos;task t4&apos;&#125; &#125;//./gradlew t3: (t1和t2执行顺序是随机的)//task t1//task t2//task t3//./gradlew t4//task t2//task t4 通过Task输入输出指定 TaskInputs:参数为任意对象及文件、文件夹；TaskOutputs:只输出文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374ext&#123; println &apos;------配置中...&apos; versionCode = 100 versionName = &quot;V2.0.0&quot; versionInfo = &quot;第一个版本&quot; destFile = file(&quot;release.xml&quot;) if(destFile != null &amp;&amp; !destFile.exists())&#123; destFile.createNewFile() &#125;&#125;class VersionMsg&#123; Integer versionCode String versionName String versionInfo&#125;task writerTask&#123; //为task指定输入 inputs.property(&quot;versionCode&quot;,this.versionCode) inputs.property(&quot;versionName&quot;,this.versionName) inputs.property(&quot;versionInfo&quot;,this.versionInfo) //为task指定输出 outputs.file destFile doLast&#123; def data = inputs.getProperties() File file = outputs.getFiles().getSingleFile() def versionMsg = new VersionMsg(data) def sw = new StringWriter() def xmlBuilder = new groovy.xml.MarkupBuilder(sw) if(file.text != null &amp;&amp; file.text.size() &lt;=0)&#123; xmlBuilder.releases&#123; release&#123; versionCode(versionMsg.versionCode) versionName(versionMsg.versionName) versionInfo(versionMsg.versionInfo) &#125; &#125; file.withWriter &#123; writer -&gt; writer.append(sw.toString()) &#125; &#125;else&#123; def lines = file.readLines() def lengths = lines.size() - 1 file.withWriter &#123; writer -&gt; lines.eachWithIndex&#123; String line, int index -&gt; if(index != lengths)&#123; writer.append(line +&quot;\r\n&quot;) &#125;else if(index == lengths)&#123; writer.append(&quot;\r\n&quot; + sw.toString()+&quot;\r\n&quot;) writer.append(lines.get(lengths)) &#125; &#125; &#125; &#125; &#125;&#125;task readTask&#123; inputs.file destFile doLast&#123; def file = inputs.files.singleFile println file.text &#125;&#125;task taskTest&#123; dependsOn readTask,writerTask doLast&#123; println &quot;输入输出任务结束&quot; &#125;&#125; destFile作为writerTask输出结果输入到readTask 通过API指定执行顺序：mustRunAfter／shouldRunAfter 12task t1() &#123; doLast&#123;println &apos;task t1&apos;&#125; &#125;task t2() &#123; mustRunAfter t1 doLast &#123;println &apos;task t2&apos;&#125; &#125; 通过./gradlew t2 t1查看执行结果 4. Task类型 详见官方文档：https://docs.gradle.org/current/dsl/org.gradle.api.tasks.Delete.html#org.gradle.api.tasks.Delete 5. 构建到生命周期 12345678this.project.afterEvaluate &#123;project -&gt; println &quot;开始挂接...&quot; def buildTask = project.tasks.getByName(&quot;build&quot;) if(buildTask == null) throw GradleException(&quot;build Task not found&quot;) buildTask.doLast &#123; writerTask.execute() &#125;&#125; Gradle其他模块 Settings类：对应Settings.gradle 123if(hasProperty(&apos;isLoadTest&apos;)? isLoadTest.toBoolean() : false)&#123; include &apos;:Test&apos;&#125; SourceSet类:AndroidSourceSet/JavaSourceSet,决定了代码、资源、第三方库要存放的位置 123456789//修改.so等jnilibs的存放位置android&#123; sourceSets &#123; main&#123; jniLibs.srcDirs = [&apos;libs&apos;] res.srcDirs = [&apos;src/main/res&apos;,&apos;src/main/res-ad&apos;] //对res文件夹内容进行分类，但是只能在Project视图查看到效果 &#125; &#125;&#125; Gradle的Plugin Gradle没有提供创建自定义Gradle插件工程的模板，需要开发者手动创建Gradle插件工程 使用Groovy开发，其Gradle插件工程必须遵循如下的目录结构： groovy代码必须位于xxxProject/src/main/groovy/目录下 提供插件属性声明文件，该文件必须位于xxxProject/src/main/resources/META-INF/gradle-plugins/xxx.properties android插件对gradle的扩展 android具体能配置那些属性，可查看源码通过BaseExtension查看 gradle插件： https://avatarqing.gitbooks.io/gradlepluginuserguidechineseverision/content/introduction/README.html varints变体]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>andrioid</tag>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iphone8p重装系统]]></title>
    <url>%2F2018%2F01%2F02%2F%E5%85%B6%E4%BB%96-2019-1-02-iphone8p%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[Github Pages介绍]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>忘记锁屏密码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于]]></title>
    <url>%2Fabout%2Findex.html</url>
    <content type="text"><![CDATA[关于我]]></content>
  </entry>
  <entry>
    <title><![CDATA[归档]]></title>
    <url>%2Farchives%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[分类]]></title>
    <url>%2Fcategories%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[schedule]]></title>
    <url>%2Fschedule%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[标签]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
</search>
