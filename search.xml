<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java并发编程]]></title>
    <url>%2F2019%2F01%2F02%2FJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[ExecutorService Semaphore 并发实现一个计数器：引入问题 并发与高并发： Java内存模型-写一篇文章 Java内存模型：Java Memory Model（JMM） CPU包括运算逻辑部件、寄存器部件和控制部件等。寄存器在CPU上 Java堆：Heap运行时数据区，有垃圾回收来负责，可以动态分配大小，生存期也不必提前告诉编译器，是在运行时动态分配内存的，由于需要动态分配，所以速度比栈慢 Java栈：Stack速度仅次于寄存器，数据可以共享，缺点是栈中的数据的大小及生存期必须是确定的， 线程之间操作必须通过主内存 https://www.cnblogs.com/zhehan54/p/6130030.html 实现并发的方式有多种：比如多进程、多线程、IO多路复用。 进程是资源（CPU、内存等）分配的基本单位 自定义注解 https://blog.csdn.net/motui/article/details/79012846 线程安全性-原子性 compareAndSwapXXX：当前值和底层值对比，如果一样则执行，如果不一样，则重新获取再比较 AtomicLong LongAdder https://blog.csdn.net/jesonjoke/article/list/1 http://www.cnblogs.com/hongten/p/hongten_oracle_plsql.html https://me.csdn.net/jesonjoke]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[aa]]></title>
    <url>%2F2018%2F12%2F19%2Faa%2F</url>
    <content type="text"><![CDATA[https://www.cnblogs.com/god--love-you/p/6133390.html springboot https://blog.csdn.net/forezp/column/info/15397/1 https://blog.csdn.net/vbirdbest/article/category/7490600/3 https://github.com/lenve/vhr netty https://waylau.com/netty-4-user-guide/ https://github.com/doocs/advanced-java https://blog.csdn.net/qq_38765404/article/details/78615572 http://www.cnblogs.com/felixzh/p/5869212.html oracle https://www.cnblogs.com/kane1990/p/OracleNetManager.html https://blog.csdn.net/u011179993/article/details/51554324 https://www.cnblogs.com/yadongliang/p/5840203.html http://blog.51cto.com/mazongfei/2126876 https://blog.csdn.net/weixin_37480339/article/details/81017214 https://blog.csdn.net/wangjialiang/article/details/7867791 http://blog.sina.com.cn/s/blog_13689d7d40102y3d3.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[mac系统安装]]></title>
    <url>%2F2018%2F12%2F19%2FLinux-01-linux-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%90%AF%E5%8A%A8%E9%A1%BA%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[https://www.cnblogs.com/GO-NO-1/p/9084713.html]]></content>
      <tags>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac系统安装]]></title>
    <url>%2F2018%2F12%2F19%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-01-mac%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[U盘启动 U盘启动：目的是为了在没有装系统的情况下进行临时启动，它可以启动DOS、备份还原软件或内存中运行的PE系统。现在大部分的电脑都支持U盘启动。U盘启动在系统奔溃和快速安装系统时能起到很大的作用。 mac系统安装启动盘制作 准备一个 8GB 或更大容量的 U盘，并备份好里面的所有资料 下载好需要安装的系统。在App Store中搜索系统，如：MacOS Sierra，完成下载。 打开 “应用程序 → 实用工具 → 磁盘工具”，将U盘「抹掉」(格式化) 成「Mac OS X 扩展（日志式）」格式、GUID 分区图，并将U盘命名为「Sierra」。(注意：这个盘符名称将会与后面的命令一一对应，如果你改了这盘符的名字，必须保证后面的命令里的名称也要一致) 打开 “应用程序→实用工具→终端”，将下面的一段命令复制并粘贴进去： 1sudo /Applications/Install\ macOS\ Sierra.app/Contents/Resources/createinstallmedia --volume /Volumes/Sierra --applicationpath /Applications/Install\ macOS\ Sierra.app --nointeraction 回车并执行该命令，这时会提示让你输入管理员密码，便会开始制作过程了： 如上图，这时系统已经在制作中了，请耐心等待直到屏幕最后出现 Done. 字样即表示大功告成了 mac系统U盘安装 （此步骤可选：如果想格式化磁盘则进行此操作）启动时按住[command + r]，进入磁盘管理工具抹掉磁盘即可 先在目标电脑上插上 U 盘，然后重启你的 Mac，然后一直按住[option」(alt)] 按键不放，直到屏幕显示多出一个 USB 启动盘的选项。 选择 U 盘的图标回车，即可通过 U 盘来安装 macOS Sierra 了！这时，你可以直接覆盖安装系统(升级)，也可以在磁盘工具里面格式化抹掉整个硬盘，或者重新分区等实现全新的干净的安装 启动过程中电脑会重启，重启的时候，拔掉U盘 安装软件 在登陆App Store之后，往常安装过的软件在&quot;已购项目&quot;列表中有，不用每次安装系统后再一一去查找安装过的程序。 非App Store安装的程序，在安装时，又是会提示app出现某些安装包已损坏、显示未激活、打开崩溃等的提示！！这种多是因为新系统屏蔽了任何来源的设置，所以需要大家打开“允许任何来源”方可安装，可按如下方式操作 步骤1：Spotlight搜索(快捷键：command+空格或右上角搜索的符号)：搜索 “终端” 步骤2：直接复制粘贴 sudo spctl --master-disable 回车 步骤3：输入你的 开机密码 步骤4：回到系统偏好设置 的“安全与隐私”，勾选 “允许任何来源”完成安装. macOS一些其他维护相关知识 官方技术支持网址：https://support.apple.com/zh-cn 关于 Mac 启动时您看到的屏幕：在从 OS X 启动 Mac 时，系统会显示不同的屏幕，以让您了解 Mac 的启动方式，或是启动可能未完成的原因。 https://support.apple.com/zh-cn/HT204156 启动 Mac 时显示闪烁的问号 如果启动时在 Mac 屏幕上看到闪烁的问号，这意味着您的 Mac 无法找到自身的系统软件。 https://support.apple.com/zh-cn/HT204323 如何重新安装 macOS https://support.apple.com/zh-cn/HT204904 关于 macOS 恢复功能 https://support.apple.com/zh-cn/HT201314 使用 Time Machine 备份或恢复 Mac https://support.apple.com/zh-cn/HT201250 如何重置 Mac 上的 NVRAM Command-Option-P-R https://support.apple.com/zh-cn/HT204063 重置 Mac 上的系统管理控制器 (SMC) Shift-Control-Option https://support.apple.com/zh-cn/HT201295 如何识别 MacBook Pro 机型 https://support.apple.com/zh-cn/HT201300]]></content>
      <tags>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac系统神奇：Homebrew]]></title>
    <url>%2F2018%2F12%2F19%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-02-Homebrew%2F</url>
    <content type="text"><![CDATA[Homebrew Homebrew是一款Mac OS平台下的软件包管理工具，拥有安装、卸载、更新、查看、搜索等很多实用的功能。简单的一条指令，就可以实现包管理，而不用你关心各种依赖和文件路径的情况，十分方便快捷。 可以类比Homebrew的功能类似于前端技术的npm，RetHat系列的yum，Ubuntu系统的apt-get 安装 参考官网，使用非常简单： https://brew.sh/index_zh-cn 安装完之后可更新源： brew update/brew upgrade Homebrew使用 搜索软件：brew search 软件名，如brew search wget 安装软件：brew install 软件名，如brew install wget 卸载软件：brew remove 软件名，如brew remove wget 在macOS系统上，git、node都推荐通过Homebrew安装]]></content>
      <tags>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac虚拟机安装及设置]]></title>
    <url>%2F2018%2F12%2F19%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-03-mac%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%8F%8A%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[简介 Parallels Desktop是一款运行在 Mac 电脑上的极为优秀的虚拟机软件。用户可以在 Mac OS X 下非常方便运行 Windows、Linux 等操作系统及应用。 安装 PD为收费软件，链接: https://pan.baidu.com/s/1CBa7tIghlF7JIiJTtuqdYQ 提取码: es9m，有经济能力的希望支持正版 PD安装操作系统需准备一个系统ISO镜像,虚拟机系统安装过程和普通系统安装过程基本一致。 windows10镜像下载： https://www.microsoft.com/zh-cn/software-download/windows10ISO/ 系统安装完成之后，需安装Parallels Tools，否则使用时鼠标使用等方面会有很多不便，注意安装Parallels Tools时注意PD版本，防止有和系统不兼容。 如下图： PD使用注意事项 虚拟机系统安装完之后在虚拟机系统的【配置】中进行系统内存、硬盘相关参数设置 虚拟机系统安装完之后在虚拟机系统的【配置】中进行系统共享文件夹设置，方便系统间数据共享 虚拟机初试安装后，再进行系统其他重要软件安装前，请先保存快照，再进行操作，操作不成功还可回退 虚拟机系统更新、相关开发环境设置完成之后，建议移动硬盘保存虚拟机，方便后期恢复和循环使用 虚拟机系统文件在右键【显示包内容】后，如下 其中.hdd文件为硬盘文件，可在虚拟机系统故障时优先保存此文件，或者将此文件复制替换到备份的虚拟机系统即可恢复]]></content>
      <tags>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git安装配置]]></title>
    <url>%2F2018%2F12%2F19%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-04-git%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[简介 官网：https://git-scm.com/ Git是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。 Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。 详细学习，推荐： http://www.runoob.com/git/git-tutorial.html 廖雪峰大神的git教程 https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000 git的前世今生： https://blog.csdn.net/csdnprogram/article/details/52155078 工作原理 本地 工作区（Working Directory）：就是你在电脑里能看到的目录 版本库（Repository）：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库 Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。 我们把文件往Git版本库里添加的时候，是分两步执行的： 第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区； 第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。 远程配合 git安装 参考教程：https://git-scm.com/book/zh/v2/起步-安装-Git 各平台都支持安装包安装方式 mac系统 12&gt; brew install git&gt; git --version //验证安装 git全局设置 config 配置有system级别 global（用户级别） 和local（当前仓库）三个 设置先从system-》global-》local,底层配置会覆盖顶层配置 查看git不同级别配置信息 123git config --system --listgit config --global --listgit config --和local --list git安装完成后，还需要最后一步设置，在命令行输入： 12$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;email@example.com&quot; 因为Git是分布式版本控制系统，所以，每个机器都必须自报家门 git账号关联流程 生成SSHkey ssh-keygen命令用于为“ssh”生成、管理和转换认证密钥，它支持RSA和DSA两种认证密钥. ssh-keygen(选项) 12345678910-b：指定密钥长度； -e：读取openssh的私钥或者公钥文件； -C：添加注释； -f：指定用来保存密钥的文件名； -i：读取未加密的ssh-v2兼容的私钥/公钥文件，然后在标准输出设备上显示openssh兼容的私钥/公钥； -l：显示公钥文件的指纹数据； -N：提供一个新密语； -P：提供（旧）密语；-q：静默模式； -t：指定要创建的密钥类型。 登陆git服务器，添加public key信息 测试登陆 1234测试是否成功,第一此输入命令，需输入yes后再次输入测试命令后出现类似&quot;Hi...&quot;，表示配置成功&gt; ssh -T git@github.com&gt; ssh -T git@gitee.com&gt; ssh -T git@gitlab.com git单账号关联 12&gt; ssh-keygen -t rsa -C xxxxx@gmail.com（注册github时的email）&gt; cat ~/.ssh/id_rsa.pub 登陆网站，如github／gitee／gitlab等，在如设置／Settings中有SSH and GPG keys中【add new keys】，将id_rsa.pub内容添加，会自动识别标题,设置完成之后测试登陆 git多账号设置关联 多账号配置是通过.ssh文件夹下config文件实现，操作如下： 123456&gt; touch ~/.ssh/config &gt; chmod 600 ~/.ssh/config &gt; ssh-keygen -f ~/.ssh/id_rsa.github -t rsa -C &quot;chetaofeng@163.com&quot;&gt; ssh-keygen -f ~/.ssh/id_rsa.gitee -t rsa -C &quot;chetaofeng@163.com&quot;&gt; ssh-keygen -f ~/.ssh/id_rsa.gitlab -t rsa -C &quot;chetaofeng@163.com&quot; config文件内容如下： 1234567891011121314151617# githubHost github.com HostName github.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa.github# giteeHost gitee.com HostName gitee.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa.gitee# gitlabHost gitlab.com HostName gitlab.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa.gitlab Host： 是我们在输入命令的时候的名字 比如我这里是lab 那么我使用ssh命令的时候需要使用 ssh lab HostName： 是目标主机的主机名，也就是平时我们使用ssh后面跟的地址名称。 Port：指定的端口号。 User：指定的登陆用户名。 IdentifyFile：指定的私钥地址。 .gitignore文件 不添加到版本库的内容记录，创建项目后一定要添加.gitignore文件 开发环境中配置 在Jetbrains系列开发工具中，【Version Control】界面中github选项默认有，进行设置即可 gitlab／gitee没有配置选项，需先安装相应插件，如下： 以前配置gitlab的时候，是通过Other Settings-&gt;GitLab Settings设置如下： GitLab Server Url: https://gitlab.com/ GitLab API Key： https://gitlab.com/profile/account git项目权限管理 Git项目一般有五种身份权限，分别是： Owner 项目所有者，拥有所有的操作权限 Master 项目的管理者，除更改、删除项目元信息外其它操作均可 Developer 项目的开发人员，做一些开发工作，对受保护内容无权限 Reporter 项目的报告者，只有项目的读权限，可以创建代码片断 Guest 项目的游客，只能提交问题和评论内容 私服项目使用推荐流程 以下为项目owner需进行工作 在私服先创建项目，添加人员并设置人员权限 在本地webstorm中clone项目 在clone项目中添加.gitignore文件 添加.gitignore及相关需要版本控制的文件夹到版本控制（选中项后右键操作） 提交项目并备注为初始提交 以下为项目成员需做工作 在本地webstorm中clone项目 创建项目分支（可一人一个，也可通过项目模块进行分支创建），如果直接在master分支，则无法成功push项目提示被rejected 进行代码编写 提交需管理分支 在gitlab私服网页发起合并请求，并添加详细描述 等待相关人员进行合并 合并结束后更新master分支 创建分支继续工作]]></content>
      <tags>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node安装配置]]></title>
    <url>%2F2018%2F12%2F19%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-05-node%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[相关概念 nodejs：在项目开发时的所需要的代码库 nvm：nodejs 版本管理工具。 npm：nodejs包管理工具，在安装的 nodejs 的时候，npm也会跟着一起安装，它是包管理工具，管理nodejs中的第三方插件 yarn：Yarn是由Facebook、Google、Exponent 和 Tilde 联合推出了一个新的 JS 包管理工具 ， 是为了弥补 npm 的一些缺陷而出现的 即：一个nvm可以管理多个node版本和npm版本 nvm安装 官网： https://github.com/creationix/nvm 安装：curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.34.0/install.sh | bash 安装完成后的提示界面会有类似一下的提示信息： 12export NVM_DIR=&quot;$HOME/.nvm&quot;[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \. &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm 在~/.bash_profile中添加以上内容(如果没有这个文件则创建)后保存；通过source ~/.bash_profile使设置生效。 安装完成后关闭终端，重新打开终端输入 nvm 验证一下是否安装成功 注：curl看系统是否已安装，如果没有安装则：sudo apt-get install curl nvm常用命令 nvm install stable ## 安装最新稳定版 node，当前是node v9.5.0 (npm v5.6.0) nvm install ## 安装指定版本，可模糊安装，如：安装v4.4.0，既可nvm install v4.4.0，又可nvm install 4.4 nvm uninstall ## 删除已安装的指定版本，语法与install类似 nvm use ## 切换使用指定的版本node nvm ls ## 列出所有安装的版本 nvm ls-remote ## 列出所有远程服务器的版本（官方node version list） nvm current ## 显示当前的版本 nvm alias ## 给不同的版本号添加别名 nvm unalias ## 删除已定义的别名 nvm reinstall-packages ## 在当前版本 node 环境下，重新全局安装指定版本号的 npm 包 nvm安装node nvm install stable yarn 快速、可靠、安全的依赖管理工具 安装 brew install yarn brew install yarn --without-node Yarn和npm命令对比 npm yarn npm install yarn install npm install react --save yarn add react npm uninstall react --save yarn remove react npm install react --save-dev yarn add react --dev npm update --save yarn upgrade]]></content>
      <tags>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java JDK安装配置]]></title>
    <url>%2F2018%2F12%2F19%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-06-Java%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[JDK下载 http://www.oracle.com/technetwork/java/javase/downloads/index.html https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html 环境变量设置说明 （jdk 需要配置三个环境变量； 1.5之后可以不再设置classpath，但建议保留classpath设置） CLASS_PATH 保证class文件能够在任意目录下运行 PATH 保证javac可以在任意目录下运行 mac系统 环境变量配置文件执行的顺序： /etc/profile /etc/paths ~/.bash_profile ~/.bash_login ~/.profile ~/.bashrc /etc/profile和/etc/paths是系统级别的，系统启动就会加载，剩下的是用户级别的。 下载dmg安装包后直接安装后，通过java -version；java；javac验证，个人发现最新版本中不用系统环境变量配置，重启电脑验证过， 配置环境变量的方式： 找到JDK安装目录，如：/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home 编辑文件~/.bash_profile 文件 12345JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/HomePATH=$JAVA_HOME/bin:$PATH:.export JAVA_HOMEexport PATH 使配置生效：source .bash_profile 输入 echo $JAVA_HOME 显示刚才配置的路径 验证安装 Linux系统 安装前，请在终端中通过java命令查看是否系统已默认安装OpenJDK，如果有，则先卸载 下载安装包后解压，如：sudo tar -zxvf jdk-8u77-linux-x64.tar.gz,得到jdk1.8.0_77文件夹 sudo mkdir /usr/java sudo cp -r jdk1.8.0_77/ /usr/java/ 配置环境变量,sudo vim /etc/profile,在前面添加 123export JAVA_HOME=/usr/java/jdk1.8.0_77export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH source /etc/profile 使配置立即生效 检查新安装的jdk:java -version;java;javac]]></content>
      <tags>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java JDK安装配置]]></title>
    <url>%2F2018%2F12%2F19%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-07-CentOS%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[https://blog.csdn.net/ganeshys2017/article/details/81300246 http://www.cnblogs.com/linnuo/p/6257204.html https://blog.csdn.net/lwwl12/article/details/78247307]]></content>
      <tags>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu系统安装后的设置]]></title>
    <url>%2F2018%2F12%2F19%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-08-Ubuntu%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E5%90%8E%E7%9A%84%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[修改默认源为国内源 cd /etc/apt cp /etc/apt/sources.list /etc/apt/sources.list.bak 备份/etc/apt/sources.list 在/etc/apt/sources.list文件前面添加源条目,具体源条目可百度，如阿里源： 1234567891011#添加阿里源deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse 更新源 12sudo apt-get updatesudo apt-get upgrade 系统分辨率设置 安装Ubuntu系统后分辨率为800*600且无法修改，通过以下方式修改： 首先打开终端Terminal，输入: sudo apt-get install xdiagnose sudo xdiagnose 启动【X 诊断工具设置】，点击【Apply】 sudo reboot 重启系统 再次打开设置发现分辨率可以设置了,如设置为：1280*800 chrome浏览器安装 wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb sudo dpkg -i google-chrome-stable_current_amd64.deb]]></content>
      <tags>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JetBrains系列软件安装配置]]></title>
    <url>%2F2018%2F12%2F19%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-09-JetBrains%E7%B3%BB%E5%88%97%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[软件破解 软件破解请参考： http://idea.lanyus.com/ 使用前请将“0.0.0.0 account.jetbrains.com”添加到hosts文件中 在网页获取注册码，在注册页面填入注册码即可 Android Studio安装 以下为相关软件下载，2／3中软件为采用第三方模拟器的时候需要下载，利用自带模拟器则可跳过下载 下载Android Studio安装软件： https://developer.android.google.cn/studio/#downloads 下载virtualbox： https://www.virtualbox.org/wiki/Linux_Downloads 下载Genymotion： https://www.genymotion.com/download 安装前请确保网络状态良好，现在安装Android Studio，所需Android SDK、自带模拟器镜像、gradle等都可以在线直接通过开发工具下载安装 mac系统 直接安装dmg安装包即可 Linux系统 进入安装包所在目录下，如：android-studio-ide-181.5056338-linux.zip sudo mkdir /usr/JetBrains sudo cp android-studio-ide-181.5056338-linux.zip /usr/JetBrains cd /usr/JetBrains sudo unzip android-studio-ide-181.5056338-linux.zip cd android-studio/bin 命令行启动AndroidStuido： ./studio.sh，正常的话应该会出现软件的配置设置 软件启动，因为没有Android SDK，会弹出提示界面，点击cancle之后会自动下载Android SDK，然后创建测试项目，过程中运行所需资源都会自动下载，耐心等待即可 设置启动图标启动Android Studio sudo vim /usr/share/applications/android-studio.desktop 编辑文件内容： 123456[Desktop Entry]Type=ApplicationName=Android StudioComment=Android Studio Integrated Development EnvironmentIcon=/usr/JetBrains/android-studio/bin/studio.pngExec=/usr/JetBrains/android-studio/bin/studio.sh 在启动器别表即可找到Android Studio启动图标，点击启动即可 模拟器 Android程序调试可通过真机、自带模拟器、第三方模拟器调试 第三方模拟器大多使用Genymotion，官网下载：https://www.genymotion.com/download/ android Studio安装Genymotion插件使用 安装过程遇到的问题 linux中启动模拟器出现grant current user access to /dev/kvm错误 解决方法：打开terminal,输入代码who／whoami查找当前用户名；sudo chown username -R /dev/kvm 注意username是你用的用户名 无法修改模拟器创建时的选项 emulated performance 解决方法： Nexus 5X和Nexus 5镜像不支持，换成其他镜像即可 https://blog.csdn.net/wshish920907/article/details/78249528 InteliJ IDEA安装 下载地址：http://www.jetbrains.com/idea/?fromMenu Linux系统 进入安装包所在目录下，如：ideaIU-2016.1.2.tar.gz sudo cp android-studio-ide-181.5056338-linux.zip /usr/JetBrains，如果没有JetBrains则自己创建 cd /usr/JetBrains sudo tar -zxvf ideaIU-2016.1.2.tar.gz sudo mv idea-IU-145.971.21 idea cd idea/bin 命令行启动Idea： ./idea.sh，正常的话应该会出现软件的配置设置 软件启动，创建任意Java程序，配置JDK路径，然后创建测试项目，过程中运行所需资源都会自动下载，耐心等待即可 设置启动图标启动Idea sudo vim /usr/share/applications/idea.desktop，当然软件启动后也会提示是否创建快捷访问链接，可通过IDEA创建启动图标 编辑文件内容： 123456[Desktop Entry]Type=ApplicationName=InteliJ IDEAComment=InteliJ IDEA Integrated Development EnvironmentIcon=/usr/JetBrains/idea/bin/idea.pngExec=/usr/JetBrains/idea/bin/idea.sh 在启动器别表即可找到InteliJ IDEA启动图标，点击启动即可 WebStorm安装 下载地址：http://www.jetbrains.com/webstorm/download/#section=linux webstorm安装请参考AndroidStudio和IDEA 设置启动图标启动Idea sudo vim /usr/share/applications/idea.desktop，当然软件启动后也会提示是否创建快捷访问链接，可通过IDEA创建启动图标 编辑文件内容： 123456[Desktop Entry]Type=ApplicationName=WebStormComment=WebStorm Integrated Development EnvironmentIcon=/usr/JetBrains/WebStorm/bin/webstorm.pngExec=/usr/JetBrains/WebStorm/bin/webstorm.sh]]></content>
      <tags>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle]]></title>
    <url>%2F2018%2F12%2F12%2Foracle%2F</url>
    <content type="text"><![CDATA[官网：https://www.oracle.com/index.html 版本中字母的含义：c（cloud）、g（grid）、i（internet） 下载：https://www.oracle.com/downloads/，需要登录oracle官网，下载的两个文件解压在一个文件夹中 安装： 安装Oracle11g出现INS-13001环境不满足最低要求 https://blog.csdn.net/q_sea__/article/details/79012808 Environment variable: “PATH” 安装时确保不要关机或断电；安装过程中复制文件过程比较耗费时间 完整的Oracle数据库通常由两部分组成：Oracle数据库和数据库实例。 数据库是一系列物理文件的集合（数据文件，控制文件，联机日志，参数文件等）； Oracle数据库实例则是一组Oracle后台进程/线程以及在服务器分配的共享内存区。 在启动Oracle数据库服务器时，实际上是在服务器的内存中创建一个Oracle实例（即在服务器内存中分配共享内存并创建相关的后台内存），然后由这个Oracle数据库实例来访问和控制磁盘中的数据文件。Oracle有一个很大的内存快，称为全局区（SGA）。 数据库的创建与监听器的配置54C 创建数据库:Database Conguration Assistant,可以创建、配置、删除、管理数据库 全局数据库名称为数据库名称，其至少要有一个Oracle实例引用，该实例由SID唯一标识,如：orcl 配置Enterprise Manager会占用较大内存，先不配置;注意选择字符集;修改scott和hr的密码 sys用户为数据库的所有者，system用户为数据库的操作员 监听器的配置：Net Conguration Assistant，配置完成后在系统服务中查看添加了OracleOraDb11g_home1TNSListener,此服务启动之后就允许外部连接数据库了 OracleServiceORCL是关于数据库实例的服务，此服务启动之后，数据库才可用 oracle常用数据库工具 Oracle Universal Installer：OUI（Oracle全局安装器），用来安装卸载oracle数据库管理系统 Database Conguration Assistant：(DBCA)创建、配置、删除、管理数据库 Net Conguration Assistant：(NCA)监听器、命名方法、本地网络服务名、目录使用配置 SQL Plus：基于命令行的oracle官方操作工具 SQL Devloper：基于Java的图形化的oracle官方操作工具,需人工关联sqldeveloper.exe文件和配置JDK PL/SQL Devloper：第三方工具 TOAD：第三方工具 Oracle中的用户、权限与角色 用户管理：需切换到system用户操作 创建用户：create user 用户名 identified by 密码 [account lock|unlock] [password expire];（password expire表示密码立即过期，第一次登录后需修改密码）用户创建后还需授权才能操作数据库 修改用户：alter user 用户名 identified by 密码 [account lock|unlock] [password expire]; 删除用户：drop user 用户名 [cascade];(cascade用来表示删除用户下的所有数据对象) 权限管理：权限为系统中设置的安全规则或安全策略，分为系统权限（用户能否在数据库上完成某个动作）和对象权限（用户能否在某个数据库对象上完成某种操作） 系统权限授予：grant 权限 to user|role [with admin option];(表示可以级联授予) 系统权限回收：revoke 权限 from user|role; 对象权限授予：grant 权限[(col,…)] on 数据库对象 to user|role [with admin option]; 对象权限回收：revoke 权限[(col,…)] on 数据库对象 from user|role; 对象权限的回收是级联的，系统权限回收是非级联的 角色管理：角色是权限的集合，用来简化权限管理 创建／删除角色：create/drop role 角色; 角色上系统权限授予：grant 权限 to role [with admin option];(表示可以级联授予) 角色上系统权限回收：revoke 权限 from 角色; 角色上对象权限授予：grant 权限[(col,…)] on 数据库对象 to role [with admin option]; 角色上对象权限回收：revoke 权限[(col,…)] on 数据库对象 from role; 用户角色授予：grant 角色 to 用户; 用户角色回收：revoke 角色 from 用户; Oracle表：由行和列组成的数据库中基本的存储单元，访问其他用户的表需要加用户名作为前缀 约束：表级别约束和列级别约束，由主键、外键、非空、唯一、检查5种约束 启用表的只读状态便于备份和导出表：alter table 表名 read only;启用表的读写状态：alter table 表名 read write; Oracle事务:有一组DML组成的逻辑工作单元，有原子性、一致性、独立性和持久性 序列sequence：数值生成器，通常用于生成主键值， dual是Oracle提供的最小的工作表，只有一行一列，具有某些特殊功用，只有一条记录:‘X’,习惯上,我们称之为’伪表’,他的存在是为了操作上的方便,因为select都是要有特定对象的. select count(*) from dual; 索引和同义词的使用 索引：通过关联ROWID和关键值来提升查询速度 同义词：数据库对象的别名，public同义词对所有用户有用，创建需一定权限 创建：create [public] synonym 名称 for object; 删除：drop [public] synonym 名称 for object; PL/SQL：是一种程序语言，叫做过程化SQL语言（Procedural Language/SQL）。PL/SQL是Oracle数据库对SQL语句的扩展。在普通SQL语句的使用上增加了编程语言的特点 官网：https://www.oracle.com/technetwork/database/features/plsql/index.html PL/SQL developer官网：https://www.allroundautomations.com/ PLSQL Developer 12 注册码 product code： 4vkjwhfeh3ufnqnmpr9brvcuyujrx3n3le serial Number：226959 password: xs374ca 配置pl/sql的Database的两种方式： 确保OracleOraDb11g_home1TNSListener和OracleServiceXXXX服务已启动 1.登录时直接在Database选项输入数据库信息:在登录时输入数据库信息 ip:端口/数据库名,如：127.0.0.1:1521/ORCL 2.配置product\11.2.0\dbhome_1\NETWORK\ADMIN\tnsnames.ora文件，添加一下内容到文档最后，登录时输入如ORCL即可登录 ORCL = (DESCRIPTION = (ADDRESS_LIST = (ADDRESS = (PROTOCOL = TCP)(HOST = 127.0.0.1)(PORT = 1521)) ) (CONNECT_DATA = (SERVER = DEDICATED) (SERVICE_NAME = ORCL) ) ) https://www.jikexueyuan.com/course/oracledb/ https://www.oracle.com/technetwork/topics/winsoft-085727.html https://www.cnblogs.com/xiashiwendao/p/7634240.html 严格来讲SQL会分为三种类型: 1、数据操纵语言（DML）：用来操纵数据库中数据的命令。包括：select、insert、update、delete。 2、数据定义语言（DDL）：用来建立数据库、数据库对象和定义列的命令。包括：create、alter、drop。 3、数据控制语言（DCL）：用来控制数据库组件 用select * from tab;来查询用户下的表 查看表结构用:DESC 表名称 https://www.cnblogs.com/adforce/p/3312252.html 全局数据库名：就是一个数据库的标识，在安装时就要想好，以后一般不修改，修改起来也麻烦，因为数据库一旦安装，数据库名就写进了控制文件，数据库表，很多地方都会用到这个数据库名。 启动数据库：也叫全局数据库，是数据库系统的入口，它会内置一些高级权限的用户如SYS，SYSTEM等。我们用这些高级权限账号登陆就可以在数据库实例中创建表空间，用户，表了。 查询当前数据库名：select name from v$database; 我们访问Oracle都是访问一个实例，但这个实例如果关联了数据库文件，就是可以访问的，如果没有，就会得到实例不可用的错误。 实例名指的是用于响应某个数据库操作的数据库管理系统的名称。她同时也叫SID。实例名是由参数instance_name决定的 查询当前数据库实例名：select instance_name from v$instance; 从oracle9i版本开始，引入了一个新的参数，即数据库服务名。数据库的逻辑表示，它是数据库呈现给客户机的方式。参数名是SERVICE_NAME。如果数据库有域名，则数据库服务名就是全局数据库名；否则，数据库服务名与数据库名相同。 网络服务名(NET SERVICES NAME) 它是“连接描述符”简称，连接描述符是网络连接目标特殊格式的描述，它包括网络协议、主机名称或地址、和目标服务 在Oracle7和Oracle8版本,目标服务由Oracle系统标识符(SID)来标识，而Oracle8i、Oracle9i则通过数据库服务名来来标识。保存tnsnames.ora文件中在格式如下： myDB = (DESCRIPTION = (ADDRESS_LIST = (ADDRESS = (PROTOCOL = TCP)(HOST = 10.10.10.1)(PORT = 1521)) ) (CONNECT_DATA = (SERVICE_NAME = testDB.ChinaMobile.com) ) ) 若要向ORACLE代理商购买ORACLE，是以用户数来算钱的。那么，这个“用户”跟我们在ORACLE中通过 CREATE USER USERNAME IDENTIFIED BY PASSWORD创建的用户是不同概念，“用户数”指的是并发访问用户数， （我理解是同时间访问同一个内存地址的进程数）。要是我买了8个用户的，可以建几十、上百个用户也没问题，只要峰值达不到并发数就可以了。 打个比方，你的名字叫小明，但是你有很多外号。你父母叫你小明，但是朋友都叫你的外号。 这里你的父母就是oracle实例，小明就是sid，service name就是你的外号。 sid用于实例区分各个数据库，service name用于外部链接。 一个Oracle Server由一个Oracle实例和一个Oracle数据库组成。 即：Oracle Server = Oracle Instance + Oracle Database Oracle实例包括了内存结构(SGA)和一系列后台进程(Background Process),两者合起来称为一个Oracle实例，即：Oracle Instance = SGA + Background Process 数据库逻辑组织结构 表空间、段、区、块 一个数据库由一个或多个表空间组成，一个表空间只能属于一个数据库 一个表空间由一个或多个多个数据文件组成，一个数据文件只能属于一个表空间 一个数据文件由一个或多个操作系统块组成，每一个操作系统块只能数以一个数据文件 一个表空间可以包含一个或多个段，一个段只能属于一个表空间 一个段由一个或多个区组成，每一个区只能属于一个段 一个区由一个或多个Oracle 块组成，每一个Oracle块只能属于一个区 一个区只能属于一个数据文件，数据文件的空间可以分配到一个或多个区 一个Oracle 块由一个或多个操作系统块组成，一个操作系统块是一个Oracle块的一部分 https://blog.csdn.net/prince_lintb/article/details/78772999 pl/sql plus： &quot;／&quot;表示执行 scott库：https://www.2cto.com/database/201805/742911.html https://www.cnblogs.com/adforce/p/3312252.html http://www.cnblogs.com/kscnchina/p/4570865.html 声明时，变量以v_开头，常量以c_开头 https://blog.csdn.net/michaelehome/article/details/79464214 select userenv(‘language’) from dual; NLS_LANG=“AMERICAN_AMERICA.AL32UTF8” 字符集：https://www.cnblogs.com/kaishirenshi/p/9018343.html 本地动态sql SQL环境 begin … end pl/sql环境 一组SQL语句操作要成为事务，数据库管理系统必须保证这组操作的原子性（Atomicity）、一致性（consistency）、隔离性（Isolation）和持久性（Durability），这就是ACID特性。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDB]]></title>
    <url>%2F2018%2F12%2F10%2FMongoDB%2F</url>
    <content type="text"><![CDATA[https://www.jikexueyuan.com/course/mongoDB/ NoSQL数据库：NoSQL(NoSQL = Not Only SQL )，意即&quot;不仅仅是SQL&quot;，指的是非关系型的数据库 mongodb官网：https://www.mongodb.com/ https://docs.mongodb.com/manual/ MongoDB是一个基于分布式文件存储的数据库。由C++语言编写。旨在为WEB应用提供可扩展的高性能数据存储解决方案。 MongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。 http://www.runoob.com/mongodb/mongodb-tutorial.html NoSQL保证数据的最终一致性，数据由更新延迟 CAP理论 适用场景：数据缓存；json格式数据存储；高伸缩性场景； MongoDB更多适合大数据量、高并发、弱事务的互联网应用，其内置的水平扩展机制提供了从几百万到十亿级别的数据处理能力，可很好的满足Web2.0和移动互联网应用的s数据存储要求。 MongoDB由C++编写，支持32位（2G限制）和64位应用，是一个基于分布式文件存储的开源数据库系统。 MongoDB3.0特性： 加入WiredTiger存储引擎: 开源的存储引擎；为现代硬件设计：多核CPU，充分利用内存／芯片级缓存；RAM/SSD/HDD；为大数据设计：高性能，低延迟，高并发稳定性 MMAPv1:内存映射存储引擎，为默认引擎 ，提供了Collection锁；无缝迁移MMAP 可插拔引擎API 基于Web的可视化管理工具：Ops Manager MongoDB数据模型 文档：本质上是一种类JSON的BSON格式的数据，可以理解为在JSON基础上添加了一些新的数据类型，包括Date，正则表达式等。 BSON官网：http://bsonspec.org/ BSON是由一组组键值对组成，具有轻量性、可靠性和高效性3个特征。可遍历性是MongoDB将BSON作为数据存储的重要原因 使用文档时需要注意以下事项： MongoDB中写操作的原子性限制在文档级别； 单个文档占用的存储空间不能超过16MB； MongoDB会尽量保持文档被插入时键值对的顺序； 关于文档命名需要注意的事项： _id是系统保留的关键字，他是默认的主键，该值在集合中必须唯一，且不可更改； 键不能包含空字符或\0，这个字符用于表示键的结尾； 不能以$开头且不能包含点号. 键是区分大小写的且不能重复 集合：把一组相关的文档放到一起组成了集合，MongoDB的集合是模式自由的，一个集合里面的文档可以是各式各样的 MogoDB提供了一些特殊的集合：capped collection、system.indexes、system.namespaces等 集合命名需注意： 集合名不能是空字符串； 集合名不能包含空字符串或\0，该字符表示集合名的结尾 集合名不能以&quot;system.&quot;开头，此前缀是系统本身保留的 集合名不能包含$字符，但是可以包含点号. 数据库：多个文档组成集合，多个集合组成数据库。一个MongoDB实例可承载多个数据库，每个数据库有独立的权限，在磁盘上，不同的数据库也可放置到不通目录 数据库命名规则： 不能是空字符串；不能以$开头；不能包含空字符串和点号.;数据库名称区分大小写；建议数据库名全部使用小写；数据库名最长64字节；不要与系统保留数据库名相同 命名空间：把数据库名添加到集合名前面，中间用点号连接，得到集合的完全限定，就是命名空间 因为点号可以出现在集合名字中，如：jike.blog.posts 和 jike.blog.authors，可以将posts和authors看作是blog集合的子集合，blog集合甚至可以不存在 使用子集合的方式，可以是我们更好的组织数据，使数据结构更加清晰明了 MongoDB数据类型 基本数据类型 null：表示空值或者不存在的字段 布尔：true／false 数据类型：32-int,64-int,64-double,注意：JavaScript只支持64位浮点数 字符串类型：使用UTF-8对字符串进行编码 二进制数据：可以保存由任意字节组成的字符串，如：图片、视频等 正则表达式类型：主要用于查询，使用正则表达式作为限定条件 Date类型：是一个64位整数，它代表距Unix epoch：1970-1-1的毫秒数，MongoDB在存储时间是现转换为UTC时间，北京时间=UTC+8小时，MongoDB Shell会根据本地时间 设置显示日期时间 Timestap：32bit Unix epoch + 32bit自增序数，只供MongoDB数据库服务内部使用，用于记录操作的详细时间 ObjectId：由24个16精制字符组成，每个字节存储两位16精制数字，总共需12字节存储空间=4字节时间戳+3字节机器标识+2字节pid+3字节计数器，ObjectId(),getTimestamp(),valueOf() 数组：使用方括号来表示的一组值，数组中可以包含不通数据类型的元素，针对数组，MongoDB提供了许多操作符，如：pop,pop,pop,push,pull,pull,pull,slice,$addToSet等；MongoDB可自动为数组元素建立MultiKey索引 内嵌文档：文档可以作为键的值，这样的文档成为内嵌文档。内嵌文档可以使数据不用保存成扁平结果的键值对，从而使数据组织形式更加自然。 内嵌文档模式VS引用文档模式 子文档比较小或变化不频繁，则使用内嵌文档模式，否则使用引用文档模式 MongoDB自动将_id字段设置为主键 MongoDB Shell：是MongoDB自带的JavaScript Shell，随MongoDB一起发布 =JavaScript V8解释器+MongoDB客户端 help查看帮助 执行脚本 直接执行：mongo [–quiet] script.js 交互执行：load(“script.js”) 执行命令行程序：run(“ls”) .mongorc.js文件，默认会加载 编辑复合变量EDITOR：在.bashrc中添加后source生效 12#EDITOREDITOR=/usr/bin/vim 即可使用editor编辑文档 http://www.runoob.com/mongodb/mongodb-intro.html Mongodb中的Map/reduce主要是用来对数据进行批量处理和聚合操作。 GridFS是MongoDB中的一个内置功能，可以用于存放大量小文件。 MongoDB允许在服务端执行脚本，可以用Javascript编写某个函数，直接在服务端执行，也可以把函数的定义存储在服务端，下次直接调用即可。 MongoDB数据库安装： 下载安装文件解压缩并添加bin目录到环境变量 创建一个data目录，然后在data目录里创建db目录、logs目录 启动服务端 启动客户端：mongo windows下可以将MongoDB做成系统服务 mac 临时添加环境变量：export PATH=/usr/local/mongodb/bin:PATH编辑 /.bashprofile,添加：exportPATH=PATH 编辑~/.bash_profile,添加：export PATH=PATH编辑 /.bashp​rofile,添加：exportPATH=PATH:/usr/local/mongodb4/bin/:$PATH 即可永久添加环境变量 连接MongoDB数据库：./mongo + 服务器IP:端口号/数据库名 关闭MongoDB服务在 ./mongo 进入控制台后，输入 use admin,然后输入 db.shutdownServer() Mongodb可以通过命令行方式和配置文件的方式来启动： 这两种方式都是在前台启动Mongodb进程，如果Session窗口关闭，Mongodb进程也随之停止。 不过Mongodb同时还提供了一种后台Daemon方式启动，只需要加上一个&quot;–fork&quot;参数即可，用到了&quot;–fork&quot;参数就必须启用&quot;–logpath&quot;参数 通过命令行： ./bin/mongod --dbpath=/data/db --fork --logpath=/data/logs/mongodb.log 配置文件方式：./bin/mongod -f mongodb.conf 或 ./bin/mongod --config mongodb.conf //-f 后面写要使用的配置文件 ./bin/mongod --shutdown -f mongod.conf 1234port=27017dbpath=/usr/local/mongodb/data/logpath=/usr/local/mongodb/log/mongodb.log fork = true 命令行操作： use mytetDB //数据库如果不存在则创建 save时如果给定了_ObjectId则更新创建整条记录；如果要更新部分字段则使用update方法使用$set db.dropDatabase() db//显示当前数据库 show dbs show collections 有一些数据库名是保留的，可以直接访问这些有特殊作用的数据库。 admin： 从权限的角度来看，这是&quot;root&quot;数据库。要是将一个用户添加到这个数据库，这个用户自动继承所有数据库的权限。一些特定的服务器端命令也只能从这个数据库运行，比如列出所有的数据库或者关闭服务器。 local: 这个数据永远不会被复制，可以用来存储限于本地单台服务器的任意集合 config: 当Mongo用于分片设置时，config数据库在内部使用，用于保存分片的相关信息。 MongoDB GridFS文件系统 分布式文件系统：将固定存储于单台机器上的文件系统，扩展到多台机器上，每个节点负责存储部分数据，众多的存储节点组成一个文件系统网络，各个节点通过网络进行通信和数据传输 当存储文档大于16M时，可以考虑使用GridFS GridFS：是MongoDB制定的如何在数据库中存储大文件的规范，MongoDB并没有实现GridFS，而是交由客户端驱动程序实现 GridFS使用两个集合（collection）存储文件。一个集合是chunks, 用于存储文件内容的二进制数据；一个集合是files，用于存储文件的元数据。 使用fs.files存储文件的元数据，包含字段如下： 使用fs.chunks存储以255K进行分割的文件块，包含字段如下： GridFS适用于如下场景： 存储用户产生的文件且文件数量比较大；需要文件的自动备份和分布式存储；需要访问文件的部分内容；存储16MB以上的文件 mongofiles是MongoDB安装包中提供的一个工具，专门用来存取文件，包括查询所有文件、查看文件、上传一个文件、获取一个文件、按照_id来获取文件、按文件名删除文件、按_id删除文件。 mongofiles --help其实有四个主要命令，分别为： put —存储命令 get —获取命令 list —列表命令 delete —删除命令 MongoDB聚合管道：聚合操作主要用户批量数据处理，往往将记录按条件分组，然后在每组上分别进行一系列操作，如：求和、求最大小值等 聚合操作能够对记录进行复杂处理，主要为数理统计和数据挖掘。 MongoDB提供了3种聚合操作方式： 聚合管道（Aggregation Pipeline）:MongoDB Shell使用db.collection.aggregate([{…}])来构建和使用聚合管道 $project:用于修改文档的结构，可以重命名、增加或删除文档字段 match:用于过滤文档，在match:用于过滤文档，在match:用于过滤文档，在match中不能使用$where,尽量出现在管道的前面，方便借助索引加快查询 $group:将集合中的文档进行分组，此分组在内存中进行，最大100M，可通过allowDiskUse启用磁盘交换处理 $sort:将集合中的文档进行排序，此分组在内存中进行，最大100M，可通过allowDiskUse启用磁盘交换处理 $skip:跳过指定数量的文档 $unwind:将文档按照数组字段拆分成多条文档，每条文档包含数组的一个元素 $geoNear:按照由近到远顺序输出接近某一地理位置的文档 out:将聚合结果存储到集合中，参数为集合名称。。。聚合管道表达式：阶段操作符可以看作是&quot;键&quot;，所对应的&quot;值&quot;称为管道表达式，管道表达式可以看作是管道操作符的操作数，管道表达式是一个文档结构，由字段名、字段值和表达式操作符组成。聚合管道使用优化：1将out:将聚合结果存储到集合中，参数为集合名称 。。。 聚合管道表达式：阶段操作符可以看作是&quot;键&quot;，所对应的&quot;值&quot;称为管道表达式，管道表达式可以看作是管道操作符的操作数，管道表达式是一个文档结构，由字段名、字段值和表达式操作符组成。 聚合管道使用优化： 1将out:将聚合结果存储到集合中，参数为集合名称。。。聚合管道表达式：阶段操作符可以看作是&quot;键&quot;，所对应的&quot;值&quot;称为管道表达式，管道表达式可以看作是管道操作符的操作数，管道表达式是一个文档结构，由字段名、字段值和表达式操作符组成。聚合管道使用优化：1将match、$sort放到管道开始阶段，有利于利用索引提高文档处理效率 2提交过滤可减少流经后续阶段的文档数量 聚合管道的限制： 1返回文档结果不能超过16M，可通过返回一个游标或存储到集合中跳过此限制 单目的聚合操作 count distinct group MapReduce编程模型 mongoimport可以导入集合 MongoDB数据更新 文档插入和删除：insert、update、delete Bulk函数：Bulk可将多个数据更新操作放到一个待执行的列表中批量来执行，顺序执行的Bulk（按添加顺序执行，一个有问题则退出）和并执行的Bulk（随机方式并行） 1初始化Bulk： 并行：db.集合名.initializeUnorderedBulkOp() 顺序：db.集合名.initializeOrderedBulkOp() 2 bulk.inset({…}) 3 bulk.execute() MMAPv1的内存分配策略：如果一个更新操作超过了文档在磁盘上预分配的空间，MongoDB会重新在磁盘上为其分配一块更大的连续空间。使用&quot;2的N次方&quot;的方式分配内存，如：32，64，128，256…2M，4M… 优点：1有利用内存的重用，降低系统碎片的数量；2减少数据移动频率，提高系统数据写效率 文档修改 WriteResult = db.集合名.update(query,obj,upsert,multi) query:查询条件，相当于where obj：更改的内容，相当于SQL中的set语句 upsert：当query的文档不存在时是否插入一条新文档 multi：当query返回多个文档时是否一次更新满足条件的所有文档，默认只更新一条 内嵌文档的修改： 修改整个内嵌文档：{$set:{field1:新内嵌文档}} 修改内嵌文档的某个字段：{$某个修改操作符:{field1.field2:value}} 数组元素：MongoDB提供了大量的特定操作符，使得数组既可以作为栈、队列等有序对象使用，也可当作集合等无序对象来使用 MongoDB的写安全机制 写过程：使用update、save等操作数据集合中数据时，只是修改了数据再内存中的映像，数据更新并没有同步地保存到磁盘上，而且更新内存中数据之前，更新操作会被记录到journal日志文件中， 每隔100ms将内存journal中的日志写到磁盘journal日志文件中 ，每隔60s将内存中修改的数据写会到磁盘上 写入安全级别：写入安全Write Concern是一种客户端设置的，用于控制写入安全级别的机制，通过写入安全机制可提高数据的可靠性。 分为四个级别，分别是： 非确认式写入Unacknowledged：写操作不会返回结果，所以无法知道是否写入成功；但速度快、效率高、无阻塞 确认式写入Acknowledged：写操作必须得到MongoDB服务器的写入确认，如果失败，会返回异常 日志写入Journaled：写操作要等到操作记录存储到Journal日志文件后才返回结果 复制集确认写入Replica Acknowledged：写操作不仅要得到主节点的写入确认，还要得到从节点的写入确认，可以设置写入节点的个数（包含主节点） journal日志相当于oracle中的redo日志文件，用户故障恢复和持久。Journal默认100ms刷新一次，所以最多丢失100ms数据 文件位于journal目录中，只能以追加方式添加数据，文件名以&quot;j._&quot;开头，超过1G会自动创建新的；数据库正常关闭时，数据库服务会自动清空journal目录下所有文件 设置写安全操作级别，其实就是在写操作的性能和可靠性间取一个权衡；使用的写操作级别越高，时间越长，可靠性越高 使用writeConcern函数作为更新函数的一个参数来设置写安全级别,如：db.集合名称.insert({name:“joe”},{writeConcern:{j:true}}),writeConcern函数参数如下： w选项，可选择0，1，2等整数值及&quot;majority&quot;，0-非确认式写入 1-确认式写入（未启用复制集）／主节点确认式写入（启用了复制集），&gt;1只能用于复制集，2-数据至少写到1个从节点后返回，majority 只能用于复制集，表示更新操作用到大多数从节点 j选项，设置为true来使用journaled日志安全级别 wtimeout选项，用于设置超时单位为毫秒 以上选项可组合使用 数据MongoDB数据查询 Cursor = db.集合名称.find(query,fields,limit,skip) query:查询条件，相当于where fields:用于字段映射，语法格式：{field:0}（0表示返回结果不包含此字段）或{field:1}（1表示返回结果不包含此字段），默认包含_id字段,相当于select中后面需要的字段 limit：限制查询结果集的数量，指定查询返回结果的数量上限，也可通过limit()实现 skip:跳过一定数据量的结果，设置第一条返回文档的偏移量，也可通过skip()实现 find查询只能正对一个集合；返回的集合默认是无序的 db.集合名称.findOne()只返回第一条数据 查询操作符 比较查询操作符 逻辑查询操作符 元素查询操作符 $where查询操作符：可以将JavaScript表达式的字符串或JavaScript函数作为查询语句的一部分，在js表达式和函数中，可使用this或obj来引用当前操作的文档，当js表达式或函数返回true时，才会返回当前文档 内嵌文档与数组查询 内嵌文档查询 1查询整个内嵌文档：当内嵌文档的键值对数量和键值对顺序都相同时，才会匹配 2查询文档的某个字段：需要使用.号操作符，如:db.user.find({“address.city”:“BeiJing”}) 数组查询 1查询整个数组：当数组元素内容和数组元素顺序都相同时，才会匹配 2查询数组中的元素（普通元素）： A与位置无关，查询数组中含有某个值的文档，如：db.user.find({score:80}) B与位置有关，按照指定的数组索引查询数组元素的值，如：db.user.find({‘scores.2’:80}) 3查询数组中的数组元素是文档时，查询数组元素有两种情况 A与位置无关，查询数组中满足条件的子文档元素，如：db.user.find(‘scores.成绩’：95) B与位置有关，按照指定的数组索引查询数组子文档，如： db.user.find(‘scores.2.成绩’：95) MongoDB查询结果返回过程：find函数查询结果是以多条文档的形式分批来返回查询结果的，返回的文档会缓存到内存中，Cursor在一批数据回来之后遍历，下一批没来时会自动发起下一批请求，然后继续遍历 MongoDB游标：用来遍历结果集中的数据。 游标的生命周期：创建、使用、销毁 游标可能会返回那些由于体积变大而被移动到集合末尾的文档而重复返回，可通过对查询快照的方式解决此问题，语法为：db.collection.find().snapshot(). 使用快照之后，查询就会在_id索引上来遍历执行，这样就可以保证每个文档只被返回一次，从而保证获取结果的一致性。 模糊查询：查询条件可以使用正则表达式实现模糊查询，支持正则表达式操作符和正则表达式对象两种。 正则表达式操作符：$regex findAndModify函数使用执行分为find和update两步，但可以保证操作的原子性 MongoDB是为分布式存储而设计，_id主键默认使用ObjectId类型的值，比自增方式更适合分布式环境，所以MongoDB默认不支持字段自增长功能 MongoDB索引：数据库索引是对数据表中一列或多列的值进行排序的一种数据结构，使用索引可快速访问数据表中的特定信息。MogonDB索引不仅提高文档查询速度，还有利于排序时节省内存资源。 MongoDB所有的索引信息被保存在system.indexes集合中，且默认总为_id创建单字段升序具有唯一属性的索引，可通过db.system.indexes.find()查看所有索引 MongoDB可在单个字段上建立索引，字段可以是普通字段、整个文档以及子文档的某个字段 对于复合索引，MongoDB支持前缀匹配 为确保查询只使用复合索引，可以使用映射来指定不要返回_id字段（除非它是复合索引的一部分） 多键索引：是对数组类型建立的索引，实际上是对数组的每个元素建立索引，而不是数组本身建立索引；当数组元素是文档时，可为文档的某个字段建立多键索引 哈希索引：只支持等值查询，不支持范围查询，主要用于分片的集合上，可以作为片键来使用，能将数据比较均匀的分散存储在各个分片上，如：db.集合名.createIndex({name:“hashed”}) MongoDB索引的属性 唯一索引:可以确保集合的每一个文档的索引字段都有唯一的值，不会出现重复值，如：db.集合名.createIndex({name:1},{unique:true})，在非空集合创建唯一索引可能会因为已有重复值而失败，可添加dropBups:true删除重复文档 稀疏索引：只会为索引字段存在的文档建立索引，即使索引字段的值为null，但不会为索引字段不存在的文档建立索引 TTL(Time To Live)索引：为文档设置一个超时时间，当达到预设置的时间后，该文档会被数据库自动删除，但删除可能有延迟。这种类型的索引对缓存问题非常有用。只能建立在单独非_id字段 创建了TTL索引后，MongoDB会有一个后台线程来管理文档；在复制集上建立的TTL索引，TTL后台线程只会运行在主节点上 MongoDB索引的管理 索引的默认命名规则：keyname1_dir1_keyname2_dir2…，其中keynameX是索引字段的名称，dirX是索引方向，1升序-1降序，也可自定义命名 创建索引：db.集合名.createIndex(keys,options),返回值为一个文档类型。索引一旦创建就不能修改，创建后可通过db.集合名.getIndexes()查看集合所拥有的索引，创建索引有两种方式： 1foreground:阻塞所有对数据库的读写请求，直到索引创建完成，为默认方式 2background：创建索引时，如果有新的数据库请求，创建过程会暂停 删除索引：db.集合.dropIndex(index) 查询优化器：用来优化查询过程，通过比较返回100条文档速度得到最佳查询计划 explain函数：能够提供大量与查询有关的信息，可以很好的评估索引性能，帮助优化索引的使用策略。db.集合.find().explain(mode),支持3种模式： 1queryPlanner：查询计划，默认 2executionStatus：查询性能统计 3allPlansExecution：所有计划统计信息（最优与被拒绝的计划） explain返回结果使用由多个阶段（Stage）组成的树形结构来表示查询计划，查询计划自下而上执行，树的叶节点用来访问文档或索引，内部节点处理下层节点返回文档或索引，根节点输出查询结果 hint函数：强制MongoDB使用特定索引 MongoDB特殊索引 地理空间索引：对地理位置数据建立索引，MongoDB支持两种2dsphere球面索引和平面2d索引 2dSphere球面索引 2d平面索引 全文索引：又称为倒排索引，用于在大量文本中对每一个词组建立索引，指出该词在整段文本中出现的位置和次数，此技术主要用于搜索引擎和站内搜索等。 一个集合只能有一个全文索引 java对mongodb的使用 集群搭建：mongodb分布式集群搭建手记]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis]]></title>
    <url>%2F2018%2F12%2F10%2FMyBatis%2F</url>
    <content type="text"><![CDATA[Java持久化框架 瞬态+持久态 iBatis-MyBatis apache-google-github SQL语句与代码分离；面向配置编程；良好支持复杂数据映射；动态SQL https://github.com/mybatis/mybatis-3 http://www.mybatis.org/mybatis-3/zh/index.html 日志配置 https://www.cnblogs.com/zhaozihan/p/6371133.html MyBatisg工作流程 读取配置文件 生成SqlSessionFactory,表示和数据库的连接，一般是程序级的生命周期 简历SqlSession 调用MyBatist提供的API 查询Map配置 返回结果 关闭SqlSession 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=&quot;org/mybatis/example/BlogMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; map文件引用 1.相对路径 2.绝对路径 3.包路径 MyBatis配置文件：基本配置文件+映射配置文件 typeAliases标记定义别名，需要environments标记之前 map文件方式+注解方式（接口方式） mappers里面3种写法：resource／class／package Select配置属性说明 两者只能有一个成立 resultType resultMap解决复杂查询时的映射问题，如属性为对象 parameterType封装hashmap，key既是key也是sql形参 parameterType封装对象如User，对象参数自动匹配属性，如果对象属性和列名不一样用别名 返回多上记录时MyBatis自动封装成List 事务处理： MyBatis事务处理由两种方式处理：JDBC+MANAGED 每张表单独的一个配置文件，方便管理 MyBatis自动id返回， 123one.setUserName(&quot;123&quot;);session.insert(&quot;insertOne&quot;,one);System.out.println(one.id); //可以正常获取id 高级查询 关联查询 联合查询：association 构造查询：POJO添加构造函数，同时确保要有默认构造函数，防止构造函数重新后找不到默认构造函数 子查询：所有联合查询，都可以通过子查询替换，但是他让查询成了N+1次的查询 子查询和联合查询的区别： 联合查询一次查询占用资源大，子查询N+1次查询占用资源可大可小，MyBatis中子查询可能速度比联合查询速度高如果开启了懒加载的话 懒加载的使用：配置要在配置别名之前 集合查询：Collection标记，适用于查询的对象还有一个集合引用的事后 鉴别器：discriminator标记 javaType属性： Column属性： Case子标记： MyBatis动态SQL：动态生成SQL https://www.aliyun.com/jiaocheng/811373.html https://www.jikexueyuan.com/course/oracledb/1-0-0-0/]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin]]></title>
    <url>%2F2018%2F11%2F26%2FKotlin%2F</url>
    <content type="text"><![CDATA[http://kotlinlang.org/ https://try.kotlinlang.org/#/Examples/Hello, world!/Simplest version/Simplest version.kt Kotlin作者Andrey Kotlin是一种在 Java 虚拟机上运行的静态类型编程语言,被称之为 Android 世界的Swift,由 JetBrains 设计开发并开源 Kotlin是一种运行在Java虚拟机、Android、浏览器上的静态语言 Kotlin可以编译成Java字节码，也可以编译成 JavaScript，方便在没有 JVM 的设备上运行。 Android官方语言；100%兼容Java；Kotlin-js前端开发；Kotlin-jvm服务端开发；Kotlin-native本地执行程序；Kotlin是一门全栈语言 千里之行，始于Hello World Kotlin不存在拆箱装箱问题;Kotlin不可隐式转换类型 var tmp:[类型]=[变量值] Boolean类型 Number数据类型：Byte，Short，Int，Long，Float，Double Char数据类型：Char String数据类型：String 字符串a==b 比较内容；a===b比较应用 字符串模版$args1 args1+args2,引号中{args1+args2},引号中args1+args2,引号中引用变量 ，多行 var a:String … a1 a2 … Kotlin中 Any 等于 Java中 Object，是顶级类 空类型：任意类型都有可空和不可空两种状态，？表示可为空，!!表示强制认定nullable不可为空 fun main(args:Array){ var name:String = getName() ?: return println(name) var tmp:String? = &quot;Hello Kotlin&quot; println(tmp) println(tmp!!.length) } fun getName():String?{ return null } 智能类型转换 Java方式的：var sub:Subclass = parent as Subclass //类似于Java方式，转换异常则会抛异常 安全类型转换：var sub:Subclass? = parent as? Subclass //如果转换失败，则返回null，不抛异常 if(parent is Subclass) import com.test as test 区间Range:一个数学上的概念，表示范围；是ClosedRange的子类，IntRange最常用；i in 0…1024 判断i是否在区间内 var range:IntRange = 0…1024 //[0,1024] var range:IntRange = 0 until 1024 //[0,1024) == [0,1023] className::java.class.name className::java.class.simpleName 数组: val array:Array&lt;&gt; = arrayOf(…) 为了避免不必要的拆箱和装箱，基本类型的数组是定制的 val arrayOfInt:IntArray = intArrayOf(1,2,4) val arrayOfChar:CharArray = charArrayOf(‘H’,‘e’,‘y’) val arrayOfString: Array = arrayOf(“Hello”,“Kotlin”) val arrayOfOther:Array = arrayOf(Other(1),Other(2)) 常量：val，常量因为赋值了，编译器可以推导出来类型，所以类型可以不用写，变量：var External Tools Tools-&gt;Kotlin-&gt;Show Kotlin Bytecode 函数：Kotlin中没有申明返回值的默认返回值是Unit kotlinc安装，使用和javac一样 变量函数 var int2Long = fun(x:Int):Long{ return x.toLong() } int2Long(123) fun sum(arg1:Int,arg2:Int) = arg1+arg2 Lambda表达式调用使用()或者invoke(),如：sum(1,2) 或 sum.invoke(1,2) Lambda表达式–匿名函数 var = {arg1:Int,arg2:Int -&gt; arg1+arg2} arrayOfString.forEach { println(it) } //如果字面函数只有一个参数,可以省略该参数声明,并用“it”代替 arrayOfString.forEach(::println) Lambda表达式中的return https://www.jianshu.com/p/92cd94cba709?utm_source=oschina-app public inline fun Array.forEach(action: (T) -&gt; Unit): Unit { for (element in this) action(element) } indexes.forEach { if (it &gt; 5) { return@forEach } println(it) } indexes.forEach label@ { if (it &gt; 5) { return @label } println(it) } 函数参数调用时最后一个Lambda可以移出去 函数参数只有一个Lambda，调用时小括号可以省略 Lambda有一个参数，可默认为it 入参、返回值与形参一致的函数可以用函数引用的方式作为实参传入 类成员方法和成员变量 class B class A{ var b=0; lateinit var c:String val d:B by lazy{ B() } } 属性初始化 尽量在构造方法中完成 无法在构造方法中完成的，尝试降级为局部变量 var用lateinit延迟初始化，val用lazy 可空类型慎用null直接初始化 中缀表达式：只有一个参数，且用infix修饰的函数 class Book {infix fun on(placeString:String){…}} Book() on “My Desk” //使用方式 分支表达式： val mode=if(args.isNotEmpty() &amp;&amp; args[0] ==1){ 0 }else{ 1 } 异常捕捉 try …catch …finally中的执行完之后，再返回结果，可通过var获取返回值 具名参数：sum(arg1=2,arg0=3) //参数就可以不按照顺序传递了 变长参数：如main方法中的args fun test(vararg args:String){} 默认参数：给出参数默认值 导出可执行程序 kotlin应用场景： kotlin-android]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot]]></title>
    <url>%2F2018%2F11%2F26%2FSpringBoot%2F</url>
    <content type="text"><![CDATA[http://spring.io/ https://www.imooc.com/video/16358 英文文档：https://docs.spring.io/spring-boot/docs/current/reference/ Spring Framework是一种JavaEE的框架 Spring Boot是一种快速构建的Spring应用 Spring Cloud是构建SpringBoot的分布式应用 SpringBoot2.0 编程语言：Java 8+，Kotlin，底层框架：SpringFramework 5.0.X,支持Web Flux Web Flux 支持函数编程，Java 8 Lambda 响应式编程,Reactive Streams 异步编程，Servlet3.1和Asyc NIO InteliJ中配置Java和Maven 构建项目： 图形化方式 1 http://start.spring.io/ ，输入选择Reactive Web 2 导入项目 命令行方式（Maven） mvn archetype:generate -DinteractiveMode=false -DgroupId=com.test -DartifactId=first-app-by-maven -Dversion=1.0.0-SNAPSHOT 添加 org.springframework.boot spring-boot-starter-parent 1.5.9.RELEASE org.springframework.boot spring-boot-starter-web 取消Junit的版本，需要4.1.2以上，取掉之后spring-boot-starter-parent继承版本 父Module的packaging设置为pom 打包方式 Jar包方式 War包方式 指定Main-class方式 org.springframework.boot spring-boot-maven-plugin 1.5.4.RELEASE ${start-class} ZIP repackage https://docs.spring.io/spring-boot/docs/current/reference/html/build-tool-plugins-maven-plugin.html jar包形式 mvn -Dmaven.test.skip -U clean package java -jar [jar名称.jar] war包形式，需要有webapp-&gt;WEB-INF-&gt;web.xml java -jar [war名称.war] 运行模式 IDEA方式 Jar／War方式 Maven插件方式： mvn srping-boot:run//需要在Main方法module，使用前，需要在父Module mvn -Dmaven.test.skip -U clean install https://blog.csdn.net/taiyangdao/article/details/75303181 ConcurrentHashMap http://www.importnew.com/28263.html https://www.cnblogs.com/heyonggang/p/9112731.html AtomicInteger https://www.cnblogs.com/sharkli/p/5623524.html 好的习惯，实体都实现toString()方法 Flux &amp; Mono Flux：0到N个对象的集合 Mono：0到1个对象的集合 Reactive中的Flux和Mono是异步处理的，都是Publisher https://www.imooc.com/learn/1058 组件自动装配：规约大于配置，专注核心业务 外部化部署：一次构建、按需调配，到处运行 嵌入式容器：内置容器、无需部署、独立运行 SpringBoot Starter:简化依赖、按需装配、自我包含 Production-Ready：一站式运维、生态无缝整合 Java 能长盛不衰，主要是命好。每当人们觉得 Java 不行了的时候，总会有英雄横刀救美。 最初 Java 开发出来不知道有什么用的时候，发现可以用 Applet 在网页上做动画。后来企业级软件开发时代 JavaEE 大行其道，开源社区 Spring 桃李满天下。 等到了移动时代，人们觉得 Java 要完蛋了，Google 拍马救市，收购并开放了 Android 平台，当家语言就是 Java，于是 Java 再次焕发勃勃生机。 目前大数据领域，Java 同样是当仁不让的好手。 现在 Spring Framework 那套东西使用了十几年，正当大家被长达几千行的 ApplicationContext 配置文件折磨的死去活来的时候，Spring Boot 诞生了。什么是 Spring Boot？用来简化 Spring 应用程序开发的。 换句话说就是，当你觉得 Java 不好用的时候，我做了个轻量级的 S，让你好好用 Java。等你觉的 S 也不够轻了，我做了个 SB，让你觉得 S 还是挺轻的。 https://www.imooc.com/video/16783 SrpingBoot为微服务框架，与Spring4一起诞生 https://docs.spring.io/spring-boot/docs/2.1.2.RELEASE/reference/htmlsingle/]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Spring Boot</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NuGet]]></title>
    <url>%2F2018%2F11%2F02%2FNuGet%2F</url>
    <content type="text"><![CDATA[https://www.cnblogs.com/nizhenghua/p/6422078.html]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ECMAScript规范]]></title>
    <url>%2F2018%2F10%2F26%2FECMAScript%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[ECMAScript 6（简称ES6）是JavaScript语言的下一代标准，于2015年6月正式发布，也称ECMAScript 2015。 12参考资料《ECMAScript 6 入门》： http://es6.ruanyifeng.com/ ECMA是标准，js是实现 [toc] 历史 1996 ES1.0 js稳定，Netscapte将js提交给ECMA组织，ES正式出现 1998 ES2.0 ES2.0正式发布 1999 ES3.0 ES3被浏览器广泛支持 2007 ES4.0 ES4过于激进，被废除了 2008 ES3.1 4.0退化为严重缩水版3.1，代号Harmony（和谐） 2009 ES5.0 ES5正式发布了，公布了JS.next，即后来的ES6.0 2011 ES5.1 ES5.1成为了ISO国际标准 2013.3 ES6.0 制定草案 2013.12 ES6.0 ES6.0草案发布 2015.6 ES6.0 ES6.0预计发布正式版，同时JS.next指向ES7.0 兼容性 目前ES5、ES6支持还可以，凑合；ES5、ES6逐渐沦为后台语言 在浏览器中使用需要用到编译工具，babel／traceur（由google出的编译器，把ES6语法编译成ES5） 使用的三种方式 网页内直接使用 12345&lt;script src=&quot;traceur.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;bootstrap.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;module&quot;&gt; //此出写ES6代码&lt;/script&gt; 直接在线编译（主要用于测试） http://babeljs.io/repl/ https://google.github.io/traceur-compiler/demo/repl.html 直接在node中使用 直接用，需添加‘use strict’ 1234//test.js&apos;use strict&apos;let a=2;console.log(a); node test.js node --harmony_desctructuring test.js 新增功能 定义变量 let let定义的变量只能在代码块中使用，具备块级作用域；var具备函数级作用域； 块级作用域其实就是匿名函数立即调用 变量不能重复定义 可用于封闭空间;封闭空间可解决i问题 以前： (function(i){ var a=12; })(i); 现在： { let a=12; } 定义常量 const 定义后则不能修改 字符串连接 ==反单引号==：==``==,内容模版,==${变量名}填充模版== 解构赋值 var [a,b,c]=[12,5,101];解析结构，给a、b、c都赋值； json格式（通过名称匹配，与顺序无关）也支持 ==模式匹配==：var [a,[b,c],d] =[12,[3,2],101],左侧的样子需要和右侧一样 可==以给默认值==。var {time=12,date} ={data=123} 复制数组 数组赋值为引用赋值，复制以前用for循环🔥 Array.from()函数，现在使用==超引用’…’==, var arr2 = […arr1]; 在函数中通过 …args 接收多个参数 循环 以前是for或for in，现在：for of，支持数组、json、map 1234//i表示数组或者json的值，for in中i是下标，for of中表示key+value，实质是jsonObj.entrys(),类似的还有jsonObj.keys()、jsonObj.values()for(var i of arr)&#123; console.log(i);&#125; map操作 get()\set()\delete() 箭头函数 =&gt; 注意事项 this问题 //this指向了window对象 arguments不能使用，箭头函数没有自己的 arguments 123456function foo() &#123; var f = (...args) =&gt; args[0]; return f(2); &#125;foo(1); // 2 更多：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions 对象语法简洁化 12345678910111213141516171819//以前var person=&#123; name:&apos;abc&apos;, age:100, showName:function()&#123; alert(this.name); //this有问题 &#125;&#125;//ES6var name=&apos;abc&apos;;var age =100;var person=&#123; name, age, showName()&#123; alert(this.name); &#125;&#125; 面向对象 12345678910//以前面向对象function Person(name,age)&#123; //类和构造函数一体 this.name = name; this.age = age;&#125;Person.prototype.showName=function()&#123; return this.name;&#125;var p1 = new Person(&apos;abc&apos;,100);alert(p1.name); 1234567891011121314//ES6面向对象class Person&#123; constructor(name=&apos;defalut&apos;,age=0)&#123; //此处可以设置默认值，这是函数的功能，即：函数参数可以给默认值 this.name = name; this.age = age; &#125; showName()&#123; return this.name; &#125;&#125;var p1 = new Person(&apos;abc&apos;,100);alert(p1.name); alert(p1.showName()); 继承 123456789101112//以前 子类.prototype = new 父类();function Worker(name,age)&#123; Person.apply(this,arguments);&#125;Worker.prototype=new Person();//ES6class Woker extends Person&#123; constructor()&#123; super(); //调用父级构造 &#125;&#125; ES5: this.bind(); 模块化 当前使用模块化必须引入traceur和bootstrap，type必须写成module 123456//定义export default &#123;a,b&#125;//引用import modA from &apos;./a.js&apos;;//使用var sum = modA.a + modA.b Promise 本身为一个对象，用来传递异步操作的数据 整体是链式操作 12pending(等待、处理中) ---&gt; Resolve（完成） ---&gt; Reject (拒绝) 使用 123456var p1 = new Promise(function(resolve,reject)&#123; if(异步处理成功了) resolve(成功数据) else reject(失败原因)&#125;); 包含方法如下： 1234567所有方法都支持链式编程* then(成功(resolve数据),失败（reject数据）) //此方法可以防止异步编程括号深度太多的的问题* catch（function（e）&#123;&#125;）； // 用来捕获错误* all[p1,p2,p3....] //用于将多个promise对象组合／包装成一个全新的promise对象,数组中的Promise又一个错误则按错误流程走，所有都成功则按成功流程走* Promise.race([p1,p2....]).then(function(value)&#123;&#125;); //返回最先执行的Promise的结果* Promise.reject() //生成错误的Promise* Promise.resolve() //生成成功的Promise Generator+yield Generator:生成器，是一个函数，可以遍历 Generator函数名字前有* Generator函数内部使用yield语句 12345678910111213141516171819202122232425//普通函数function show()&#123; &#125;//generator函数function* show()&#123; yield “Hello”； yield &quot;World&quot;;&#125;//generator函数*show()&#123; yield “Hello”； yield &quot;World&quot;;&#125;var res=show();console.log(res.next()); //&#123;value:&quot;Hello&quot;,done:false&#125;console.log(res.next()); //&#123;value:&quot;World&quot;,done:false&#125;console.log(res.next()); //&#123;value:&quot;undefined&quot;,done:true&#125;~~~ * Generator函数调用后的对象有next方法* next方法每次返回一个value和done结果，value位yield后面的值，done代表是否遍历结束* yield语句本身没有返回值或每次返回undefined* next可以带参数，所带参数给了上一个yield* for ...of循环支持Generator函数 for (let v of show()){ document.write(v); } 1234#### 展开运算符 扩展语法允许一个表达式在期望多个参数（用于函数调用）或多个元素（用于数组文本）或多个变量（用于解构赋值）的位置扩展1. 用于函数调用 myFunction(…iterableObj); 12. 用于数组字面量 […iterableObj, 4, 5, 6] ECMA-262文档下载：https://chetaofeng.github.io/pub-images/Ecma-262.pdf]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CommonJS规范&AMD&CMD]]></title>
    <url>%2F2018%2F10%2F26%2FCommonJS%E8%A7%84%E8%8C%83-AMD-CMD%2F</url>
    <content type="text"><![CDATA[浏览器端的js和服务器端js都主要做了哪些事 服务器端JS 浏览器端JS 相同的代码需要多次执行 代码需要从一个服务器端分发到多个客户端执行 CPU和内存资源是瓶颈 带宽是瓶颈 加载时从磁盘中加载 加载时需要通过网络加载 CommonJS是主要为了JS在==后端的表现制定==的，他是不适合前端的;AMD(异步模块定义)出现了，它就主要==为前端JS的表现制定规范== CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。 AMD规范则是非同步加载模块，允许指定回调函数。 由于Node.js主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以CommonJS规范比较适用。但是，如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用AMD规范 [toc] CommonJS CommonJS规范: http://javascript.ruanyifeng.com/nodejs/module.html CommonJS模块的特点如下: 123所有代码都运行在模块作用域，不会污染全局作用域。模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。模块加载的顺序，按照其在代码中出现的顺序 CommonJS是一种规范，NodeJS是这种规范的实现 JavaScript是一个强大面向对象语言，它有很多快速高效的解释器。官方JavaScript标准定义的API是为了构建基于浏览器的应用程序。然而，并没有定于一个用于更广泛的应用程序的标准库。 CommonJS API定义很多普通应用程序（主要指非浏览器的应用）使用的API，从而填补了这个空白。它的终极目标是提供一个类似Python，Ruby和Java标准库。这样的话，开发者可以使用CommonJS API编写==应用程序==，然后这些应用可以运行在不同的JavaScript解释器和不同的主机环境中。 CommonJS定义的模块分为:模块引用(require)；模块定义(exports)；模块标识(module) require require命令用于加载文件，后缀名默认为.js 每个模块中有一个自由变量require，它是一个方法，这个方法接受一个参数，即模块的唯一ID。 CommonJS模块的加载机制是，输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值 require根据外部模块ID，返回该模块输出的API。如果外部模块被required的时候还没有执行完，require至少应改返回该模块的exports（另一个自由变量）。如果必需的模块不存在，require方法应该抛出一个异常。 require可以有一个main属性，属性值要么为undefined，要么等于module（另一个自由变量）;可以用来判断模块是直接执行，还是被调用执行。直接执行的时候（node module.js），require.main属性指向模块本身;调用执行的时候（通过require加载该脚本执行），==require.main === module== 返回false require可以有一个paths属性，属性值为由路径字符串组成的数组，路径按优先级从高到低的顺序排列 根据参数的不同格式，require命令去不同路径寻找模块文件 123456* 如果参数字符串以“/”开头，则表示加载的是一个位于绝对路径的模块文* 如果参数字符串以“./”开头，则表示加载的是一个位于相对路径的模块文件* 如果参数字符串不以“./“或”/“开头，则表示加载的是一个默认提供的核心模块或者一个位于各级node_modules目录的已安装模块* 如果参数字符串不以“./“或”/“开头，而且是一个路径如果参数字符串不以“./“或”/“开头，而且是一个路径，比如require(&apos;example-module/path/to/file&apos;)，则将先找到example-module的位置，然后再以它为参数，找到后续路径。* 如果指定的模块文件没有发现，Node会尝试为文件名添加.js、.json、.node后，再去搜索* 如果想得到require命令加载的确切文件名，使用require.resolve()方法 exports 每个模块中还有一个自由变量exports，它是一个对象，==模块对外输出的API就绑定在这个对象上==。而且==exports是模块对外输出API的唯一途径==。Node为每个模块提供一个exports变量，指向module.exports 不能直接将exports变量指向一个值，因为这样等于切断了exports与module.exports的联系 module CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。==加载某个模块，其实是加载该模块的module.exports属性== 每个模块中必须有一个自由变量module，它是对象。这个对象有一个id属性，表示该模块的id，同时应该是只读属性。 module对象可以有一个uri属性，表示这个模块被加载的来源。 每个模块内部，都有一个module对象，代表当前模块。它有以下属性: 123456module.id 模块的识别符，通常是带有绝对路径的模块文件名。module.filename 模块的文件名，带有绝对路径。module.loaded 返回一个布尔值，表示模块是否已经完成加载。module.parent 返回一个对象，表示调用该模块的模块。module.children 返回一个数组，表示该模块要用到的其他模块。module.exports 表示模块对外输出的值 目录的加载规则 通常，我们会把相关的文件会放在一个目录里面，便于组织。这时，最好为该目录设置一个入口文件，让require方法可以通过这个入口文件，加载整个目录 在目录中放置一个package.json文件，并且将入口文件写入main字段 如果package.json文件没有main字段，或者根本就没有package.json文件，则会加载该目录下的index.js文件或index.node文件 模块的缓存 第一次加载某个模块时，Node会缓存该模块。以后再加载该模块，就直接从缓存取出该模块的module.exports属性 所有缓存的模块保存在require.cache之中，如果想删除模块的缓存，可以像下面这样写 1234567// 删除指定模块的缓存delete require.cache[moduleName];// 删除所有模块的缓存Object.keys(require.cache).forEach(function(key) &#123; delete require.cache[key];&#125;) AMD AMD就只有一个接口：define(id?,dependencies?,factory); RequireJS就是实现了AMD规范 CMD 大名远扬的玉伯写了seajs，就是遵循他提出的CMD规范，与AMD蛮相近的，不过用起来感觉更加方便些，最重要的是中文版]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[middleware]]></title>
    <url>%2F2018%2F10%2F26%2Fmiddleware%2F</url>
    <content type="text"><![CDATA[https://zhuanlan.zhihu.com/p/20597452 简介 middleware 提供了一个分类处理 action 的机会，在 middleware 中你可以检阅每一个流过的 action，挑选出特定类型的 action 进行相应操作，给你一次改变 action 的机会 redux 的 middleware 是为了增强 dispatch 而出现的 redux 提供了 applyMiddleware 这个 api 来加载 middleware 四步理解 middleware 机制 12345var middlewareAPI = &#123; getState: store.getState, dispatch: (action) =&gt; dispatch(action)&#125;;chain = middlewares.map(middleware =&gt; middleware(middlewareAPI)); 函数式编程思想设计 middleware middleware 的设计有点特殊，是一个层层包裹的匿名函数，这其实是函数式编程中的柯里化 curry，一种使用匿名单参数函数来实现多参数函数的方法。applyMiddleware 会对 logger 这个 middleware 进行层层调用，动态地对 store 和 next 参数赋值 柯里化的 middleware 结构好处在于： 易串联，柯里化函数具有延迟执行的特性，通过不断柯里化形成的 middleware 可以累积参数，配合组合（ compose，函数式编程的概念，Step. 2 中会介绍）的方式，很容易形成 pipeline 来处理数据流 共享store，在 applyMiddleware 执行过程中，store 还是旧的，但是因为闭包的存在，applyMiddleware 完成后，所有的 middlewares 内部拿到的 store 是最新且相同的 给 middleware 分发 store 创建一个普通的 store 通过如下方式： 12345//applyMiddleware 函数陆续获得了三个参数//第一个是 middlewares 数组，[mid1, mid2, mid3, ...]//第二个 next 是 Redux 原生的 createStore//最后一个是 reducerlet newStore = applyMiddleware(mid1, mid2, mid3, ...)(createStore)(reducer, null); 组合串联 middlewares 1dispatch = compose(...chain)(store.dispatch); compose 是函数式编程中的组合，compose 将 chain 中的所有匿名函数，[f1, f2, … , fx, …, fn]，组装成一个新的函数，即新的 dispatch，当新 dispatch 执行时，[f1, f2, … , fx, …, fn]，从右到左依次执行（ 所以顺序很重要） 在 middleware 中调用 dispatch 在middleware 中调用 store.dispatch() 和在其他任何地方调用效果是一样的，而在 middleware 中调用 next()，效果是进入下一个 middleware]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redux-thunk]]></title>
    <url>%2F2018%2F10%2F26%2Fredux-thunk%2F</url>
    <content type="text"><![CDATA[简介 redux-thunk 是一个比较流行的 redux 异步 action 中间件，比如 action 中有 setTimeout 或者通过 fetch 通用远程 API 这些场景，那么久应该使用 redux-thunk 了 redux-thunk 帮助你统一了异步和同步 action 的调用方式，把异步过程放在 action 级别解决，对 component 没有影响 redux-thunk中间件可以让action创建函数先不返回一个action对象，而是返回一个函数，函数传递两个参数(dispatch,getState),在函数体内进行业务逻辑的封装 12345678910111213141516function add() &#123; return &#123; type: &apos;ADD&apos;, &#125;&#125;function addIfOdd() &#123; return (dispatch, getState) =&gt; &#123; const currentValue = getState(); if (currentValue % 2 == 0) &#123; return false; &#125; //分发一个任务 dispatch(add()) &#125;&#125; 使用方式 安装:npm install redux-thunk --save-dev 导入thunk： import thunk from ‘redux-thunk’ 导入中间件: import {createStore,applyMiddleware} from ‘redux’ 创建store：let store = createStore(reducer函数，applyMiddleware(thunk)) 激活redux-thunk中间件，只需要在createStore中加入applyMiddleware(thunk)就可以]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>redux组件库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React相关需学习]]></title>
    <url>%2F2018%2F10%2F26%2FReact%E7%9B%B8%E5%85%B3%E9%9C%80%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[ImmutableJS简介 ImmutableJS是FaceBook开发的一个JS库，能够在JS种实现不可变对象 不可变对象可以大大提高对象的比较性能，用于状态和属性判断非常有效 实际上，提高比较性能的代价是降低修改性能，只不过收益更大 Flux简介 Flux不是一个具体的框架，而是Facebook提出的一种代码架构 React只是一个视图库，Fulx是在React基础上对于前端整体的组织方案 Fulx目的是保证逻辑清晰、数据流向清晰、依赖关系清晰]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jest]]></title>
    <url>%2F2018%2F10%2F26%2FJest%2F</url>
    <content type="text"><![CDATA[简介 Jest是一个JS的单元测试工具 单元测试可以保证函数或者模块完成我们想要的功能，测试具体功能是否正常 使用Jest需要配置NodeJS环境 入门 npm install jest-cli sum.js 1234function sum(a,b)&#123; return a+b;&#125;module.exports=sum; test.js 12345678jest.dontMock(&apos;../sum&apos;);describe(&apos;sum&apos;,function()&#123; it(&apos;adds 1 + 2 to equal 3&apos;,function()&#123; var sum = require(&apos;../sum&apos;); expect(sum(1,2)).toBe(3); &#125;);&#125;);]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>React组件库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-router-redux]]></title>
    <url>%2F2018%2F10%2F26%2Freact-router-redux%2F</url>
    <content type="text"><![CDATA[概述 用Redux去管理你的应用状态（state），使用React Router去管理路由，但是，这两个库不能协同工作，react-router-redux库可以协调这两个库 react-router-redux允许你使用React Router库中的api，使用Redux库像平常一样去管理应用的状态state。 本库只是简单的加强了React Router库中history这个实例，以允许将history中接受到的变化反应到stae中去。 原理示例 现在，你进行的所有页面导航和App导航，加强版的history会首先将新的路径通过Redux store传递，然后再通过React Router去更新组件树]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>React组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redux入门]]></title>
    <url>%2F2018%2F10%2F26%2FRedux%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[123http://redux.js.org/http://www.redux.org.cn/http://www.imooc.com/learn/744 视频教程 简介 Redux 由 Flux 演变而来，但受 Elm 的启发，避开了 Flux 的复杂性 1234567891011121314151617181920212223242526272829303132333435363738394041import &#123; createStore &#125; from &apos;redux&apos;;/** * 这是一个 reducer，形式为 (state, action) =&gt; state 的纯函数。 * 描述了 action 如何把 state 转变成下一个 state。 * * state 的形式取决于你，可以是基本类型、数组、对象、 * 甚至是 Immutable.js 生成的数据结构。惟一的要点是 * 当 state 变化时需要返回全新的对象，而不是修改传入的参数。 * * 下面例子使用 `switch` 语句和字符串来做判断，但你可以写帮助类(helper) * 根据不同的约定（如方法映射）来判断，只要适用你的项目即可。 */function counter(state = 0, action) &#123; switch (action.type) &#123; case &apos;INCREMENT&apos;: return state + 1; case &apos;DECREMENT&apos;: return state - 1; default: return state; &#125;&#125;// 创建 Redux store 来存放应用的状态。// API 是 &#123; subscribe, dispatch, getState &#125;。let store = createStore(counter);// 可以手动订阅更新，也可以事件绑定到视图层。store.subscribe(() =&gt; console.log(store.getState()));// 改变内部 state 惟一方法是 dispatch 一个 action。// action 可以被序列化，用日记记录和储存下来，后期还可以以回放的方式执行store.dispatch(&#123; type: &apos;INCREMENT&apos; &#125;);// 1store.dispatch(&#123; type: &apos;INCREMENT&apos; &#125;);// 2store.dispatch(&#123; type: &apos;DECREMENT&apos; &#125;);// 1 Redux 没有 Dispatcher 且不支持多个 store。相反，只有一个单一的 store 和一个根级的 reduce 函数（reducer） 中间件 12345678910111213redux-thunk — 用最简单的方式搭建异步 action 构造器redux-promise — 遵从 FSA 标准的 promise 中间件redux-axios-middleware — 使用 axios HTTP 客户端获取数据的 Redux 中间件redux-observable — Redux 的 RxJS 中间件redux-rx — 给 Redux 用的 RxJS 工具，包括观察变量的中间件redux-logger — 记录所有 Redux action 和下一次 state 的日志redux-immutable-state-invariant — 开发中的状态变更提醒redux-unhandled-action — 开发过程中，若 Action 未使 State 发生变化则发出警告redux-analytics — Redux middleware 分析redux-gen — Redux middleware 生成器redux-saga — Redux 应用的另一种副作用 modelredux-action-tree — Redux 的可组合性 Cerebral-style 信号apollo-client — 针对 GraphQL 服务器及基于 Redux 的 UI 框架的缓存客户端 三大原则 Redux 可以用这三个基本原则来描述： 单一数据源 整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中 State 是只读的 惟一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象 使用纯函数来执行修改 为了描述 action 如何改变 state tree ，你需要编写 reducers；Reducer 只是一些纯函数，它接收先前的 state 和 action，并返回新的 state 总结 应用中所有的 state 都以一个对象树的形式储存在一个单一的 store 中 惟一改变 state 的办法是触发 action，一个描述发生什么的对象 为了描述 action 如何改变 state 树，你需要编写 reducers 编写专门的函数来决定每个 action 如何改变应用的 state，这个函数被叫做 reducer 安装 安装redux：npm install redux --save 使用 React 绑定库和开发者工具：npm install react-redux --save；npm install redux-devtools --save-dev 原理 Action Action 是把数据从应用传到 store 的有效载荷,它是 store 数据的唯一来源。一般来说会通过 store.dispatch() 将 action 传到 store。 action 内必须使用一个字符串类型的 type 字段来表示将要执行的动作.多数情况下，type 会被定义成字符串常量,建议使用单独的模块或文件来存放 action。除了 type 字段外，action 对象的结构完全由自己决定 1import &#123; ADD_TODO, REMOVE_TODO &#125; from &apos;../actionTypes&apos; Action 创建函数 Action 创建函数 就是生成 action 的方法 123456function addTodo(text) &#123; return &#123; type: ADD_TODO, text &#125;&#125; bindActionCreators() 可以自动把多个 action 创建函数 绑定到 dispatch() 方法上。 Reducer 永远不要在 reducer 里做这些操作： 修改传入参数； 执行有副作用的操作，如 API 请求和路由跳转； 调用非纯函数，如 Date.now() 或 Math.random() 1234567891011121314151617181920function todoApp(state = initialState, action) &#123; switch (action.type) &#123; case SET_VISIBILITY_FILTER: return Object.assign(&#123;&#125;, state, &#123; visibilityFilter: action.filter &#125;) case ADD_TODO: return Object.assign(&#123;&#125;, state, &#123; todos: [ ...state.todos, &#123; text: action.text, completed: false &#125; ] &#125;) default: return state &#125;&#125; 不要修改 state。 使用 Object.assign() 新建了一个副本。不能这样使用 Object.assign(state, { visibilityFilter: action.filter })，因为它会改变第一个参数的值。你必须把第一个参数设置为空对象。你也可以开启对ES7提案对象展开运算符的支持, 从而使用 { …state, …newState } 达到相同的目的。 在 default 情况下返回旧的 state Object.assign() 是 ES6 特性，但多数浏览器并不支持。你要么使用 polyfill，Babel 插件，或者使用其它库如 _.assign() 提供的帮助方法。 新的 todos 对象就相当于旧的 todos 在末尾加上新建的 todo。而这个新的 todo 又是基于 action 中的数据创建的 Store Store 有以下职责： 维持应用的 state； 提供 getState() 方法获取 state； 提供 dispatch(action) 方法更新 state； 通过 subscribe(listener) 注册监听器; 通过 subscribe(listener) 返回的函数注销监听器 搭配react Redux 和 React 之间没有关系。Redux 支持 React、Angular、Ember、jQuery 甚至纯 JavaScript。 连接到 Redux：我们需要做出两个变化，将 App 组件连接到 Redux 并且让它能够 dispatch actions 以及从 Redux store 读取到 state 获取从之前安装好的 react-redux 提供的 Provider，并且在渲染之前将根组件包装进 1234567891011121314151617//index.jsimport React from &apos;react&apos;import &#123; render &#125; from &apos;react-dom&apos;import &#123; createStore &#125; from &apos;redux&apos;import &#123; Provider &#125; from &apos;react-redux&apos;import App from &apos;./containers/App&apos;import todoApp from &apos;./reducers&apos;let store = createStore(todoApp);let rootElement = document.getElementById(&apos;root&apos;)render( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt;, rootElement) 通过 react-redux 提供的 connect() 方法将包装好的组件连接到Redux 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import React, &#123; Component, PropTypes &#125; from &apos;react&apos;;import &#123; connect &#125; from &apos;react-redux&apos;;import &#123; addTodo, completeTodo, setVisibilityFilter, VisibilityFilters &#125; from &apos;../actions&apos;;import AddTodo from &apos;../components/AddTodo&apos;;import TodoList from &apos;../components/TodoList&apos;;import Footer from &apos;../components/Footer&apos;;class App extends Component &#123; render() &#123; // 通过调用 connect() 注入: const &#123; dispatch, visibleTodos, visibilityFilter &#125; = this.props return ( &lt;div&gt; &lt;AddTodo onAddClick=&#123;text =&gt; dispatch(addTodo(text)) &#125; /&gt; &lt;TodoList todos=&#123;this.props.visibleTodos&#125; onTodoClick=&#123;index =&gt; dispatch(completeTodo(index)) &#125; /&gt; &lt;Footer filter=&#123;visibilityFilter&#125; onFilterChange=&#123;nextFilter =&gt; dispatch(setVisibilityFilter(nextFilter)) &#125; /&gt; &lt;/div&gt; ) &#125;&#125;App.propTypes = &#123; visibleTodos: PropTypes.arrayOf(PropTypes.shape(&#123; text: PropTypes.string.isRequired, completed: PropTypes.bool.isRequired &#125;)), visibilityFilter: PropTypes.oneOf([ &apos;SHOW_ALL&apos;, &apos;SHOW_COMPLETED&apos;, &apos;SHOW_ACTIVE&apos; ]).isRequired&#125;function selectTodos(todos, filter) &#123; switch (filter) &#123; case VisibilityFilters.SHOW_ALL: return todos; case VisibilityFilters.SHOW_COMPLETED: return todos.filter(todo =&gt; todo.completed); case VisibilityFilters.SHOW_ACTIVE: return todos.filter(todo =&gt; !todo.completed); &#125;&#125;// 基于全局 state ，哪些是我们想注入的 props ?// 注意：使用 https://github.com/reactjs/reselect 效果更佳。function select(state) &#123; return &#123; visibleTodos: selectTodos(state.todos, state.visibilityFilter), visibilityFilter: state.visibilityFilter &#125;;&#125;// 包装 component ，注入 dispatch 和 state 到其默认的 connect(select)(App) 中；export default connect(select)(App);]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Router]]></title>
    <url>%2F2018%2F10%2F26%2FReact-Router%2F</url>
    <content type="text"><![CDATA[https://reacttraining.com/react-router/ 概述 React Router 4.0 （以下简称 RR4） RR4 本次采用单代码仓库模型架构（monorepo），这意味者这个仓库里面有若干相互独立的包，分别是： 12345react-router React Router 核心react-router-dom 用于 DOM 绑定的 React Routerreact-router-native 用于 React Native 的 React Routerreact-router-redux React Router 和 Redux 的集成react-router-config 静态路由配置的小助手 它是官方维护的，事实上也是唯一可选的路由库。 react-router 还是 react-router-dom 在 React 的使用中，我们一般要引入两个包，react 和 react-dom react-router 和 react-router-dom 两个只要引用一个就行了，不同之处就是后者比前者多出了 这样的 DOM 类组件 学习 （阮一峰）http://www.ruanyifeng.com/blog/2016/05/react_router.html （gitbook）http://react-guide.github.io/react-router-cn/docs/API.html]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>React-Router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React入门]]></title>
    <url>%2F2018%2F10%2F26%2FReact%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[简介 React 是一个用于构建用户界面的 JAVASCRIPT 库 React主要用于构建UI，很多人认为 React 是 MVC 中的 V（视图） React 起源于 Facebook 的内部项目，用来架设 Instagram 的网站，并于 2013 年 5 月开源 React 拥有较高的性能，代码逻辑非常简单，越来越多的人已开始关注和使用它 React 拥有一个强大的组合模型，我们建议使用组合而不是继承以实现代码的重用 react有 函数式组件和类组件，现在的使用都以类组件为主，函数式组件不考虑 angualr霸道，用了之后原生定时器、jquery等都不能用，而react没有这个限制 react中对事件的大小写敏感，因为有一个编译过程 相关有用网址 123官网：https://facebook.github.io/react/中文网站：http://www.css88.com/react/中文论坛:http://react-china.org/ react特点 声明式设计 −React采用声明范式，可以轻松描述应用。 高效 −虚拟DOM,React通过对DOM的模拟，最大限度地减少与DOM的交互。React DOM 会将元素及其子元素与之前版本逐一对比, 并只对有必要更新的 DOM 进行更新, 以达到 DOM 所需的状态 灵活 −React可以与已知的库或框架很好地配合。 JSX − JSX 是 JavaScript 语法的扩展。React 开发不一定使用 JSX ，但我们建议使用它。 组件 − 通过 React 构建组件，使得代码更加容易得到复用，能够很好的应用在大项目的开发中。 单向响应的数据流 − React 实现了单向响应的数据流，从而减少了重复代码，这也是它为什么比传统数据绑定更简单 react全家桶（技术栈） 如果一个技术你不知道，那说明你还用不上 react：主体 webpack、grunt、gulp自动化构建工具 Flex：布局 react-route：路由 redux：view层 Mocha：测试 Istanbul：覆盖率 安装 网页使用 网页中用babel会页面加载会有编译过程，比较缓慢，babel也可以后台编译 123456789&lt;script src=&quot;https://cdn.bootcss.com/react/15.4.2/react.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.bootcss.com/react/15.4.2/react-dom.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.bootcss.com/babel-standalone/6.22.1/babel.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/babel&quot;&gt; ReactDOM.render( &lt;h1&gt;Hello, world!&lt;/h1&gt;, document.getElementById(&apos;example&apos;) );&lt;/script&gt; 引入了三个库： react.min.js 、react-dom.min.js 和 babel.min.js： react.min.js - React 的核心库 react-dom.min.js - 提供与 DOM 相关的功能 babel.min.js - Babel 可以将 ES6 代码转为 ES5 代码，这样我们就能在目前不支持 ES6 浏览器上执行 React 代码。Babel 内嵌了对 JSX 的支持。通过将 Babel 和 babel-sublime 包（package）一同使用可以让源码的语法渲染上升到一个全新的水平 使用 create-react-app 快速构建 create-react-app 是来自于 Facebook，通过该命令我们无需配置就能快速构建 React 开发环境。 create-react-app 自动创建的项目是基于 Webpack + ES6 create-react-app网址：https://github.com/facebookincubator/create-react-app create-react-app说明：https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#updating-to-new-releases 1234$ cnpm install -g create-react-app$ create-react-app my-app$ cd my-app/$ npm start 在浏览器中打开 http://localhost:3000/,查看结果 JSX JSX是可选的，对于使用 React而言不需要 React 使用 JSX 来替代常规的 JavaScript，JSX 是一个看起来很像 XML 的 JavaScript 语法扩展。 优点： JSX 执行更快，因为它在编译为 JavaScript 代码后进行了优化，需babel编译后才能运行，bower babel install,官网：http://babeljs.io/ 它是类型安全的，在编译过程中就能发现错误 使用 JSX 编写模板更加简单快速 使用过程中的注意事项： 组件必须返回一个单独的根元素。render的内容必须有且仅有一个父元 网页中使用： 123456789101112131415&lt;script src=&quot;js/react.js&quot; charset=&quot;utf-8&quot;/&gt;&lt;/script&gt;&lt;script src=&quot;js/react-dom.js&quot; charset=&quot;utf-8&quot;/&gt;&lt;/script&gt;&lt;script src=&quot;js/browser.js&quot; charset=&quot;utf-8&quot;/&gt;&lt;/script&gt;&lt;script type=&quot;text/babel&quot;&gt; window.onload=function()&#123; var oDiv = document.getElementById(&quot;div1&quot;); ReactDom.render( &lt;span&gt;111&lt;/span&gt;,//内容 oDiv//到哪 ); &#125;;&lt;/script&gt;&lt;body&gt; &lt;div id=&quot;div1&gt;&lt;/div&gt;&lt;/body&gt; 添加自定义属性需要使用 data- 前缀，因为jsx对html标签有识别，如果符合则不显示，而在自定义属性前面加data-可以保证显示显示 自定义组件可以单独文件存储 可以在 JSX 中使用 JavaScript 表达式。表达式写在花括号 {} 中；在 JSX 中不能使用 if else 语句，但可以使用 conditional (三元运算) 表达式来替代 React 推荐使用内联样式。我们可以使用 camelCase 语法来设置内联样式. React 会在指定元素数字后自动添加 px JSX 允许在模板中插入数组，数组会自动展开所有成员 注释:在标签内部的注释需要花括号;在标签外的的注释不能使用花括号 可以使用双引号来指定字符串字面量作为属性值 class 在JSX中变为className，tabindex 变为 tabIndex React DOM 使用驼峰(camelCase)属性命名约定, 而不是HTML属性名称 12345ReactDOM.render( /*注释 */ &lt;h1&gt;孙朝阳 &#123;/*注释*/&#125;&lt;/h1&gt;, document.getElementById(&apos;example&apos;)); 如果你有一个单一模块(module) ，但却 导出(exports) 多个 React 组件时十分有用 1234567891011import React from &apos;react&apos;;const MyComponents = &#123; DatePicker: function DatePicker(props) &#123; return &lt;div&gt;Imagine a &#123;props.color&#125; datepicker here.&lt;/div&gt;; &#125;&#125;function BlueDatePicker() &#123; return &lt;MyComponents.DatePicker color=&quot;blue&quot; /&gt;;&#125; JSX 中的 Children：在 JSX 表达式中可以包含开放标签和闭合标签，标签中的内容会被传递一个特殊的 props(属性) ： props.children 组件 组件名称总是以大写字母开始 组件有构造函数，构造函数的第一行应该是调用super函数，其参数为…args参数，在constructor方法中进行一些初始 绑定事件的方式：onChange={this.函数名称.bind(this)} 有狗那年，定时器中的this就不合适，在使用前通过_this=this保存一份，然后在定时中用_this代替 react处理了this，原生中如果要用this，最好也处理一下 react中阻止事件冒泡：ev.nativeEvent.stopImmediatePropergation 父级属性传递给子级直接通过属性，子级属性传递给父级需要通过在父级绑定回调函数如cb()，在子级中通过this.props.cb(传递的参数)的方式把参数传递到父级 react中设置样式style需要通过双大括号}}来设置 键(Keys) 帮助 React 标识哪个项被修改、添加或者移除了。数组中的每一个元素都应该有一个唯一不变的键(Keys)来标识。keys 只在数组的上下文中存在意义； keys 必须在它们的同辈之间唯一。然而它们并不需要全局唯一 自定义组件的方式如下： 12345class 组件名称 extends React.Component&#123; render()&#123; retrun &lt;span&gt;我的年龄是：&#123;this.props.age&#125;&lt;/span&gt; &#125; &#125; 123456//定义class Comp extends React.Component&#123; render()&#123; return &lt;span&gt;111&lt;/span&gt;; &#125;&#125; 组件使用：类似于标签的使用 1234ReactDom.render( &lt;Comp age=&quot;18&quot;/&gt;,//内容,类名 document.body//到哪); 123456789101112131415161718192021window.onload=function()&#123; ReactDom.render( &lt;Comp/&gt;,//内容,类名 document.body//到哪 ); &#125;;~~~ # 状态state* React 把组件看成是一个状态机（State Machines）。通过与用户的交互，实现不同状态，然后渲染 UI，让用户界面和数据保持一致。* React 里，只需更新组件的 state，然后根据新的 state 重新渲染用户界面（不要操作 DOM）。* this.setState(&#123;属性：&apos;值&apos;&#125;); * state(状态) 更新可能是异步的。React 为了优化性能，有可能会将多个 setState() 调用合并为一次更新。因为 this.props 和 this.state 可能是异步更新的，你不能依赖他们的值计算下一个state(状态)。# 属性propsstate 和 props 主要的区别在于 props 是不可变的，而 state 可以根据与用户交互来改变。这就是为什么有些容器组件需要定义 state 来更新和修改数据。 而子组件只能通过 props 来传递数据* 如果你没给 prop(属性) 传值，那么他默认为 true* 控制表单的value，如果用props设置了默认值，由于props是死的，不能修改，修改为defaultValue即可* 控制checkbox的默认值，修改为defalultChecked* 属性扩展:如果你已经有一个 object 类型的 props，并且希望在 JSX 中传入，你可以使用扩展操作符 ... 传入整个 props 对象。以上两种方法等效： function App1() { return ; } function App2() { const props = {firstName: ‘Ben’, lastName: ‘Hector’}; return &lt;Greeting {…props} /&gt;; } # 组件生命周期 组件的生命周期可分成三个状态： 1. Mounting：已插入真实 DOM 2. Updating：正在被重新渲染 3. Unmounting：已移出真实 DOM 生命周期的方法有： * componentWillMount 在渲染前调用,在客户端也在服务端 * componentDidMount : 在第一次渲染后调用，只在客户端。之后组件已经生成了对应的DOM结构，可以通过this.getDOMNode()来进行访问。 如果你想和其他JavaScript框架一起使用，可以在这个方法中调用setTimeout, setInterval或者发送AJAX请求等操作(防止异部操作阻塞UI) * componentWillReceiveProps 在组件接收到一个新的prop时被调用。这个方法在初始化render时不会被调用 * shouldComponentUpdate 返回一个布尔值。在组件接收到新的props或者state时被调用。在初始化时或者使用forceUpdate时不被调用 * componentWillUpdate在组件接收到新的props或者state但还没有render时被调用。在初始化时不会被调用 * componentDidUpdate 在组件完成更新后立即调用。在初始化时不会被调用 * componentWillUnmount在组件从 DOM 中移除的时候立刻被调用。==当使用异步加载数据时，在组件卸载前使用 componentWillUnmount 来取消未完成的请求== # React Refs * React 支持一种非常特殊的属性 Ref ，可以用来绑定到 render() 输出的任何组件上。 这个特殊的属性允许你引用 render() 返回的相应的支撑实例（ backing instance ）。这样就可以确保在任何时间总是拿到正确的实例 * 可以通过使用 this 来获取当前 React 组件，或使用 ref 来获取组件的引用 * ref 标示组件内的node，可以原生操作节点，在this.refs['ref名字']=原生 * React 支持给任何组件添加特殊属性。ref 属性接受回调函数，并且当组件 装载(mounted) 或者 卸载(unmounted) 之后，回调函数会立即执行 * 不能在函数式组件上使用 ref 属性，因为它们没有实例 # 使用 Chrome Timeline 分析组件性能 在 开发模式 中，你可以在支持相关功能的浏览器中使用性能工具来可视化组件 装载(mount) ，更新(update) 和 卸载(unmount) 的各个过程。在 Chrome 中具体操作如下： 1. 通过添加 ?react_perf 查询字段加载你的应用(例如：http://localhost:3000/?react_perf) 2. 打开 Chrome DevTools Timeline 并点击 Record 3. 执行你想要分析的操作，不要超过20秒，否则 Chrome 可能会挂起 4. 停止记录 5. 在 User Timing 标签下，React事件将会分组列出 注意：上述数字是相对的，组件会在生产环境中会更快 # route react-router + react-router-redux: 前者是业界标准，后者可以同步 route 信息到 state，这样你可以在 view 根据 route 信息调整展现，以及通过 action 来修改 route 。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker]]></title>
    <url>%2F2018%2F10%2F18%2FC-%E5%BC%80%E5%8F%91-2018-10-18-docker%2F</url>
    <content type="text"><![CDATA[阿里云服务器购买 http://www.runoob.com/docker/docker-tutorial.html 官网：https://www.docker.com/ 中文社区：http://www.docker.org.cn/ http://www.cnblogs.com/SzeCheng/p/6822905.html Docker是基于CS架构，系统有两个程序：docker服务端和docker客户端，是一种Linux容器管理技术 其中docker服务端是一个服务进程，管理着所有的容器。 docker客户端则扮演着docker服务端的远程控制器，可以用来控制docker的服务端进程。 大部分情况下，docker服务端和客户端运行在一台机器上。 Docker为容器引入了镜像，使得容器可以从预先定义好的模版（images）创建出来，并且这个模版还是分层的 Docker容器通过镜像启动，是镜像的启动和执行阶段，采用写时复制（copy on write） Docker容器的能力 1文件系统隔离：每个容器都有自己的root文件系统 2进程隔离：每个容器都运行在自己的进程环境中 3网络隔离：容器间的虚拟网络接口和IP地址都是分开的 4资源隔离和分组：使用cgroups将CPU和内存之类的资源独立分配给每个Docker容器 docker Client客户端————&gt;向docker服务器进程发起请求，如:创建、停止、销毁容器等操作 docker Server服务器进程—–&gt;处理所有docker的请求，管理所有容器 docker Registry镜像仓库——&gt;镜像存放的中央仓库，可看作是存放二进制的软件配置管理（scm） https://www.cnblogs.com/atuotuo/p/6668233.html 安装：下载安装完成之后docker version查看 Kitematic， Vagrant+virtualbox https://www.vagrantup.com/ https://www.virtualbox.org/ https://app.vagrantup.com/boxes/search mkdir centos7 ls vagrant init centos/7 vagrant up vagrant ssh sudo yum update exit vagrant status vagrant halt vagrant destroy Docker Machine docker-machine ls docker-machine ssh demo 远程登录管理deocker和本地管理远程docker https://labs.play-with-docker.com/ docker提供了一个开发，打包，运行app的平台，把app和底层infratructure隔离开来 docker底层技术支持,依赖于Linux内核特性Namespaces和Cgroups Namespaces：做隔离pid，net，ipc，mnt，uts Control Groups：做资源限制 Union file Systems：Container和image的分层 namespace，容器隔离的基础，保证A容器看不到B容器. 6个名空间：User,Mnt,Network,UTS,IPC,Pid cgroups，容器资源统计和隔离。主要用到的cgroups子系统：cpu,blkio,device,freezer,memory unionfs，典型：aufs/overlayfs，分层镜像实现的基础 docker image：是容器的基石，本身为层叠的只读文件系统， docker通过联合加载技术一次加载多个文件系统，从外部看，只能看到一个文件系统，包含所有文件系统的文件和目录。bootfs-rootfs(如：ubuntu)-apache。。。，rootfs称为基础镜像 文件和meta data的集合（root filesystem） 分层的，并且每一层都可以添加改变删除文件，成为一个新的image 不同的image可以共享x相同的layer image本身是read-only的 sudo docker image ls docker history [imageID] image的获取 通过Dockerfile 从Registry获取，如：docker pull ubuntu:14.04，https://hub.docker.com/ 命令行的格式为：docker search 镜像名字 DIY一个Base Image Container docker容器可以理解为在沙盒中运行的进程。这个沙盒包含了该进程运行所必须的资源，包括文件系统、系统类库、shell 环境等等。但这个沙盒默认是不会运行任何程序的。你需要在沙盒中运行一个进程来启动某一个容器。这个进程是该容器的唯一进程，所以当该进程结束的时候，容器也会完全的停止。 通过Image创建 在Image Layer之上建立一个container layer（可读写） 类比面向对象：类和实例 Image负责app的存储和分发，Container负责运行app container id只要能够区分出来就行，不用全部输入 docker container ls //运行的 docker container ls -a //所有的，包括退出的和正在运行的 docker run命令有两个参数，一个是镜像名，一个是要在镜像中运行的命令。 docker run [name] //运行container docker run -it [name] //交互式运行container 命令简写 docker container ls -a == docker ps -a docker container rm [conatinerID] == docker rm [conatinerID] docker image ls == docker images docker image rm [imageID] == docker rmi [imageID] docker container ls -aq //列出所有conatinerID 构建自己的docker镜像 docker commit [containerName] [dockerhubID/imageNewName] 通过Dockerfile创建 新建空文件夹 创建Dockerfile文件 12FROM [BaseImageName] //如果没有则值为scratchRUN yum install -y vim docker build -t [dockerhubID/imageNewName] . //.表示当前目录中查找Dockerfile docker image ls查看 Dockerfile语法梳理及最佳实践 FROM:尽量使用官方的iamge作为base image LABEL:Metadata不可少，让大家了解到image的信息，相当于image的注释 RUN:为了美观，复杂的RUN请用反斜线换行，避免无用分层，合并多条命令成一行 WORKDIR:设定当前工作目录，如果没有则会自动创建目录；用WORKDIR，不要用RUN cd，尽量使用绝对目录 ADD和COPY：把本地文件（构建目录中的相对地址 ）添加到image里面，同时ADD添加的文件如果是压缩文件的话，会自动解压缩，大部分情况COPY优于ADD，添加远程文件／目录请使用crul或wget；目标路径需指定docker中的绝对路径 ENV：设置环境变量，尽量使用ENV增加可维护性 https://github.com/docker-library/ MAINTAINER：指定容器的相关维护信息，维护人、邮箱等 RUN：执行命令并创建新的Image Layer，是在容器构建时执行 CMD：设置容器启动后默认执行的命令和参数，是在容器运行时运行的.如果docker run指定了其他命令，CMD命令被忽略；如果定义了多个CMD，只会执行最后一个；也可以只提供参数，作为ENTRYPOINT的默认参数 ENTRYPOINT：设置容器启动时运行的命令，让容器以应用程序或者服务的形式执行；不会被忽略，一定会执行；最佳实践是写一个shell脚本作为entrypoint EXPOSE：指定运行该镜像的容器使用的端口，但此端口并未自动打开，在使用的时候需要映射／设置端口 VOLUME：用来向基于镜像创建的容器，一个卷是可以存在于一个或多个容器的特定目录，这个目录可以绕过联合文件系统提供共享数据、数据持久化功能 WORKDIR：用于在容器内部设置工作目录，一般使用绝对路径，如果使用相对路径，路径会一致传递下去 USER：用来指定镜像被什么用户去运行，如果不设置，默认为root用户 ONBUILD：用来为镜像添加触发器，当一个镜像被其他镜像作为基础镜像执行时，此触发器会被执行 使用中间层镜像进行调试，查找错误 docker build命令只删除了中间层常见的容器，但是没有删除中间层创建的镜像 构建缓存：构建过程中会产生缓存，下次构建直接使用缓存镜像，如果不想使用构建缓存，则可通过：docker build --no-cache,或者通过dockerfile文件的ENV REFRESH_DATE修改日期，则本条语句后就不使用缓存了 docker history 镜像，用来查看镜像的构建过程 12COPY docker-entrypoint.sh /usr/local/bin/ENTRYPOINT [&quot;docker-entrypoint.sh &quot;] shell格式和EXEC格式 123RUN apt-get install -y vimCMD echo &quot;Hello Docker&quot;ENTRYPOINT echo &quot;Hello Docker&quot; 123RUN [&quot;apt-get&quot;,&quot;install&quot;,&quot;-y&quot;,&quot;vim&quot;]CMD [&quot;/bin/echo&quot;, &quot;Hello Docker&quot;]ENTRYPOINT [&quot;/bin/echo&quot;, &quot;Hello Docker&quot;] 登录dockerhub docker login: 用户名（非邮箱）／密码 本地push上去，其他人就可以pull 关联github，github管理Dockerfile，有修改后自动build。Create-Create Automated build 通过docker的registry本地自己搭建。https://hub.docker.com/_/registry/,后期学习 Dockerfile实战 Dockerfile是docker构建镜像的基础，也是docker区别于其他容器的重要特征，正是有了Dockerfile，docker的自动化和可移植性才成为可能。 不论是开发还是运维，学会编写Dockerfile几乎是必备的 容器的操作 //对容器执行命令 docker exec docker exec -it [containerID] /bin/bash docker inspect [imageName] //查看 docker logs [containerID] 前3章 Docker常见命令 容器相关操作 docker create # 创建一个容器但是不启动它 docker run # 创建并启动一个容器 docker stop # 停止容器运行，发送信号SIGTERM docker start # 启动一个停止状态的容器 docker restart # 重启一个容器 docker rm # 删除一个容器 docker kill # 发送信号给容器，默认SIGKILL docker attach # 连接(进入)到一个正在运行的容器 docker wait # 阻塞到一个容器，直到容器停止运行 获取容器相关信息 docker ps # 显示状态为运行（Up）的容器 docker ps -a # 显示所有容器,包括运行中（Up）的和退出的(Exited) docker inspect # 深入容器内部获取容器所有信息 docker logs # 查看容器的日志(stdout/stderr) docker events # 得到docker服务器的实时的事件 docker port # 显示容器的端口映射 docker top # 显示容器的进程信息 docker diff # 显示容器文件系统的前后变化 导出容器 docker cp # 从容器里向外拷贝文件或目录 docker export # 将容器整个文件系统导出为一个tar包，不带layers、tag等信息 执行 docker exec # 在容器里执行一个命令，可以执行bash进入交互式 镜像操作 docker images # 显示本地所有的镜像列表 docker import # 从一个tar包创建一个镜像，往往和export结合使用 docker build # 使用Dockerfile创建镜像（推荐） docker commit # 从容器创建镜像 docker rmi # 删除一个镜像 docker load # 从一个tar包创建一个镜像，和save配合使用 docker save # 将一个镜像保存为一个tar包，带layers和tag信息 docker history # 显示生成一个镜像的历史命令 docker tag # 为镜像起一个别名 镜像仓库(registry)操作 docker login # 登录到一个registry docker search # 从registry仓库搜索镜像 docker pull # 从仓库下载镜像到本地 docker push # 将一个镜像push到registry仓库中 docker system df //查看镜像、容器、数据卷所占用的空间 docker commit -m “ubuntu with vim” -a “sgy” aa97ba3292ce sgy/ubuntu:vim 前后端分离部署及运维 高性能高负载高可用 https://www.renren.io renren-fast Swagger: JWT: https://www.ghostcloud.cn/ 服务器虚拟化 （vsphere cas ZStack不通厂家命名）：裸机虚拟化、半裸机虚拟化 网络虚拟化 SDN 存储虚拟化 VSAN 服务器做raid保证系统安全，然后做存储虚拟化 Mac 上的 Docker 背后应该是一个 Linux 虚机，和 Windows 版本的 Docker 是一样的原理 容器一旦被直接推出，之前安装的gcc啊vim啊啥的就会全部gg掉。如果要保存修改，就需要将当前容器封装成一个新的镜像，这样下次启动这个新的镜像后之前作出的修改还都在。 容器不适合构建那种发布周期以周或月为单位的大型单一架构企业软件，容器适合采用微服务的方式，以及探索诸如持续部署这样的技术，使得我们能安全地在一天内多次更新生产环境。 https://blog.csdn.net/xdy3008/article/details/74531125 https://www.missshi.cn/api/view/blog/5a6327c00a745f6335000004 想看到docker容器的ip地址，只需要安装net-tools就可以了：yum install net-tools -y 如果你仅仅是想管理虚拟机，那么你应该使用vagrant。如果你想快速开发和部署应用，那么应该使用docker。 vagrant是一款管理虚拟机的工具，而docker是一款通过将应用打包到轻量级容器，而实现构建和部署的工具。两者适用范围不同。一个容器就是一个包含了应用执行所依赖的数据(包括lib，配置文件等等)。它可以保证应用在一个可重复的环境中随时执行。 数据卷：是经过特殊设计的目录，可以绕过联合文件系统ufs，为一个或多个容其提供访问。让你可以不受容器生命周期影响进行数据持久化。它们表现为容器内的空间，但实际保存在容器之外，从而允许你在不影响数据的情况下销毁、重建、修改、丢弃容器。 Docker允许你定义应用部分和数据部分，并提供工具让你将他们分开。容器是短暂和一次性的。 docker run -v ~/container_data:/data:ro -it centos,映射本地~/container_data到容器/data下,且/data的权限为ro只读，登录进去后ls查看，发现会有data目录 数据卷容器：命名的容器挂载数据卷，其他容器通过挂载这个容器实现数据共享，挂载数据卷的容器，就叫做数据卷容器。 docker run --volumes-from 数据卷容器名称 即使删除了数据卷容器，挂载了数据卷容器的容器，仍然可以访问数据卷容器的目录，数据卷容器起的作用仅仅是将挂载配置传递到待挂载容器 Docker数据卷的备份与还原：通过挂载目录压缩后放到挂载目录 Docker For Mac的Docker Daemon是运行于虚拟机(xhyve)中的, 而不是像Linux上那样作为进程运行于宿主机，因此Docker For Mac没有docker0网桥，不能实现host网络模式，host模式会使Container复用Daemon的网络栈(在xhyve虚拟机中)，而不是与Host主机网络栈，这样虽然其它容器仍然可通过xhyve网络栈进行交互，但却不是用的Host上的端口(在Host上无法访问)。bridge网络模式 -p 参数不受此影响，它能正常打开Host上的端口并映射到Container的对应Port。 docker容器的网络连接 docker0：是Linux的虚拟网桥（网桥是数据链路层的一种设备），Linux的虚拟网桥可以设置IP地址，相当于拥有一个隐藏的虚拟网卡 docker0地址划分：IP127.17.42.1,掩码255.255.0.0,总共提供了65534个地址 网桥操作需安装bridge-utils工具，安装之后brctl show查看网桥信息，可以添加网桥或者配置网桥信息 docker容器的IP地址在重启容器之后会变化，是不可靠的 容器互联：在同一宿主机下，docker容器是通过虚拟网桥互相连接的，默认在同一宿主机下docker允许所有容器互联。让容器之间可以相互连接主要借用了一个link的功能。 在使用纯Docker时，被连接的容器必须在同一个Docker宿主机中。不同宿主机之间的容器如果想要连接，则需要借助Swarm或Kubernetes等编排工具。 –link:链接容器，docker run -it --name cct3 --link=cct1:webtest bitchofgod/testnet （webtest为cct1的别名），然后在cct3中ping webtest即可互联 Docker在父容器中的以下两个地方写入了连接信息： /etc/hosts文件中，–link在此文件中写入了映射信息，当docker重新启动的时候，docker会自动维护此文件中的映射 包含连接信息的环境变量中 如果拒绝所有容器互联，则修改docker配置，在/ect/default/docker文件中添加DOCKER_OPTS=&quot; --icc=false&quot;后重启docker服务即可 如果需要特定容器互联，则通过–link、–icc=false、–iptables=true来实现 docker容器与外部网络的连接 ipforward iptables Ctrl+p，Ctrl+q退出交互界面 docker attach containerName重新打开交互界面 CaaS(Container as a Service):镜像容器托管 从Docker到Caas 容器集群管理工具 容器调度 配置管理 服务发现 日志／监控／报警 LaaS（基础设施） 出租计算、存储、网络、DNS等基础IT服务 PaaS（基础设施+系统平台—应用服务器应用框架 编程语言） 提供应用运行和开发环境 提供应用开发组件（邮件、消息、计费、支付） SaaS （基础设施+系统平台+软件应用）互联网Web2.0应用 企业应用（ERP/CRM等） 通俗点讲 SaaS：软件即服务，简单来说就是把企业想要的功能开发好成应用软件，然后直接卖给用户使用。通俗点讲就是去饭店吃饭一样，什么都是店家的。 PaaS：平台即服务，简单来说就是云计算平台提供硬件、编程语言、开发库等帮助用户更好更快的开发软件。通俗来说就是点外卖，使用时店家的，但是餐桌是自己的。 IaaS：基础设施即服务，简单来说就是云服务商提供企业所需要的服务器、存储、网络给企业用。通俗来说就是买菜买面，回家自己做饭。 https://blog.csdn.net/weixin_38003389/article/details/84025762 Docker Machine：目的是简化 Docker 的安装和远程管理,是官方提供的一个工具。 先创建Docker Machine机器 Docker Compose：Docker Compose 是 Docker 官方编排（Orchestration）项目之一，负责快速在集群中部署分布式应用。 Docker Compose允许用户通过一个单独的 docker-compose.yml 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project） Compose 中有两个重要的概念： 项目 ( project )：由一组关联的应用容器组成的一个完整业务单元，在 dockercompose.yml 文件中定义。 服务 ( service )：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例 运行 compose 项目：docker-compose up Docker Compose命令集 管理镜像：build/pull 管理服务：up/start/stop/kill/rm/scale 服务状态：ps/logs/port 一次性服务：run Docker Swarm:Docker集群管理工具，支持标准的Docker API,其主要作用是把若干台Docker主机抽象为一个整体，并且通过一个入口统一管理这些Docker主机上的各种Docker资源。 Swarm和Kubernetes比较类似，但是更加轻，具有的功能也较kubernetes更少一些。 Docker Compose 是一个在单个服务器或主机上创建多个容器的工具，而 Docker Swarm 则可以在多个服务器或主机上创建容器集群服务，对于微服务的部署，显然 Docker Swarm 会更加适合。 三大主流调度框架：Swarm、Kubernetes和Mesos Kubernetes：交互工具kubectl pods：创建、调度及管理的最小单元，共存的一组容器的集合，同一pods中的容器共享pid、网络、ipc及utf命名空间和共享存储卷]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#]]></title>
    <url>%2F2018%2F10%2F17%2FC%2F</url>
    <content type="text"><![CDATA[双问号操作符意思是取所赋值??左边的，如果左边为null，取所赋值??右边的，双问号操作符意思是取所赋值??左边的，如果左边为null，取所赋值??右边的， https://blog.csdn.net/zmh458/article/details/78935172 https://www.cnblogs.com/lanpingwang/p/6596758.html https://www.cnblogs.com/Inspire-Yi/p/6230567.html https://www.jianshu.com/p/c82ef6babf8e https://www.cnblogs.com/caofangsheng/p/5715876.html https://blog.csdn.net/beglorious/article/details/39637475 https://www.cnblogs.com/servicehot/p/6510199.html 首先我觉得action的跳转大致可以这样归一下类，跳转到同一控制器内的action和不同控制器内的action、带有参数的action跳转和不带参数的action跳转。 一、RedirectToAction(“Index”);//一个参数时在本Controller下，不传入参数。 二、RedirectToAction(ActionName,ControllerName) //可以直接跳到别的Controller. 三、RedirectToRoute(new {controller=“Home”,action=“Index”});//可跳到其他controller 四、RedirectToRoute(new {controller=“Home”,action=“Index”， id=param});//可跳到其他controller,带参数。 五、Response.Redirect(“Index?id=1”);//适用于本controller下的方法名称,可带参数。 六、return Redirect(“Index”);//适用于本controller下的方法名称。 七、return View(“Index”); //直接显示对应的页面 不经过执行Controller的方法。 八、return View(&quot;~/Views/Home/Index.aspx&quot;);//这种方法是写全路径,直接显示页面,不经过Controller方法 九、return View();//直接显示页面,不经过Controller方法 https://blog.csdn.net/zhensoft163/article/details/7174661?utm_source=blogxgwz1 一般情况下我们返回的都是本页面，所以使用return View()就可以解决问题了， https://www.cnblogs.com/Cwj-XFH/p/5956142.html Model验证是ASP.NET MVC中的重要部分，它主要用于判断输入的数据类型及值是否符合我们设定的规则，这篇文章就介绍下ASP.NET MVC中Model验证的几种方式。 后台验证 DataAnnotation ValidationAttribute IValidatableObject IDataErrorInfo 前端验证 ViewData和ViewBag https://blog.csdn.net/pasic/article/details/7093802 https://www.cnblogs.com/webapi/p/9505400.html 系列文章： https://blog.csdn.net/ydm19891101/article/details/43338999 WebForm与MVC的本质区别：请求的url不同 https://blog.csdn.net/liupantao/article/details/78582078?locationNum=3&amp;fps=1 MVC action 返回javascriptResult 需要引入的文件是 需要引用这个文件 ： jquery.unobtrusive-ajax.min.js 同时 用javascrptResult 作为action的返回结果 的话 ，前台必须用ajax.BeginForm https://www.cnblogs.com/zjf1987/p/ActionResult.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[React全家桶]]></title>
    <url>%2F2018%2F10%2F15%2FReact%E5%85%A8%E5%AE%B6%E6%A1%B6%2F</url>
    <content type="text"><![CDATA[React全家桶+Antd共享单车后台管理系统 react基础知识 Vue生态：Vue+Vue-Router+Vuex+Axios+Babel+Webpack React生态：React+React-Router+Redux+Axios+Babel+Webpack 编程式实现：需要以具体代码表达在哪里做什么，如何实现 声明式实现：只需声明在哪里做什么，无需关心如何实现 https://react.docschina.org/ https://reactjs.org.cn/ http://facebook.github.io/react/ yarn： https://yarnpkg.com/zh-Hans/ yarn init yarn add yarn remove yarn install react生命周期 react-router ／react-router-dom 按需加载： Antd中less样式 yarn eject:暴露webpack配置， less-loader安装 webpack.config.xxx.js 修改完之后，重启项目 https://ant.design/docs/react/use-with-create-react-app-cn babel-plugin-import css3 calc属性 height:calc(100vh) jsonp：https://www.npmjs.com/package/jsonp 浏览器添加debugger 伪类方式 项目中前端路由用的是 React-Router V4。 官方文档：https://reacttraining.com/react-router/web/guides/quick-start 中文文档：http://reacttraining.cn/ React-Router 4.0 React-Router：基础包 React-Router-DOM：浏览器端实现 https://segmentfault.com/a/1190000011399153 箭头函数不加{}表示直接返回结果 this.props.match.params.XXX 处理404则不设置path，只设置component即可 路由外面添加Switch 详情页面、登录页面、主页面是同层级页面，还有其他自页面嵌套路由 App.js设置为{this.props.children}代表可以接受任何组件，APP组件作为HashRouter的根组件 子路由、子组件模式 传参数需要箭头函数 Modal.confirm() 等价于 Modal[‘confirm’] {}里面必须是一个根对象 https://blog.csdn.net/little_blue_ljy/article/details/80281803 https://www.cnblogs.com/guolintao/p/9019504.html https://www.cnblogs.com/xuyuntao/articles/6391728.html https://github.com/fomenyesu/egg-restapi-module-tool/blob/master/README.cn.md ES6模版语法:]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>Antd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows git]]></title>
    <url>%2F2018%2F10%2F08%2Fwindows-git%2F</url>
    <content type="text"><![CDATA[https://git-scm.com/ https://www.cnblogs.com/vitah/p/3612473.html]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gitblit搭建git服务器]]></title>
    <url>%2F2018%2F10%2F08%2FGitblit%E6%90%AD%E5%BB%BAgit%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[http://www.gitblit.com/ https://www.cnblogs.com/ucos/p/3924720.html https://blog.csdn.net/llengnuo/article/details/73477355 http://gitblit.com/setup_go.html https://blog.csdn.net/zhangwenjie1105/article/details/81482238 https://www.cnblogs.com/royi123/p/7754235.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[微信公众平台使用]]></title>
    <url>%2F2018%2F10%2F06%2F%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%B9%B3%E5%8F%B0%2F</url>
    <content type="text"><![CDATA[官方文档 https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1445241432 接口整体介绍 微信接口请求返回格式介绍： 微信接口是通过GET方式请求 返回数据格式为JSON 测试号配置 无需公众账号，可直接体验和测试公众平台所有高级接口。 配置： 登录公众账号 开发&gt;开发者工具&gt;公众平台测试账号 微信扫一扫登录 配置URL、TOKEN、JS接口安全域名 注意事项 接口频率限制说明 全局返回码说明 网页授权登录： 如果用户在微信客户端中访问第三方网页，公众号可以通过微信网页授权机制，来获取用户基本信息。 两种scope模式： snsapi_base时只能获取到openid，静默授权， snsapi_userinfo时可获取到其他信息，需要用户手动同意授权的 微信公众平台（互斥） 编辑模式 开发者模式-openid 接入开发者模式步骤 为了识别用户，每个用户针对每个公众号会产生一个安全的OpenID 如果需要在多公众号、移动应用之间做用户共通，则需前往微信开放平台，将这些公众号和应用绑定到一个开放平台账号下，绑定后，一个用户虽然对多个公众号和应用有多个不同的OpenID，但他对所有这些同一开放平台账号下的公众号和应用，只有一个UnionID 公众平台以access_token为接口调用凭据，来调用接口，所有接口的调用需要先获取access_token，access_token在2小时内有效，过期需要重新获取，但1天内获取次数有限，开发者需自行存储 公众平台接口调用仅支持80端口。 网页授权获取用户基本信息：通过该接口，可以获取用户的基本信息（获取用户的OpenID是无需用户同意的，获取用户的基本信息则需用户同意） 微信JS-SDK：是开发者在网页上通过JavaScript代码使用微信原生功能的工具包，开发者可以使用它在网页上录制和播放微信语音、监听微信分享、上传手机本地图片、拍照等许多能力。 调试接口可能需要取消关注之后才能看到最新的效果 https://blog.csdn.net/z496007165/article/details/73239971 http://www.php.cn/xiaochengxu-405121.html 网页授权接口： 授权回调页面域名：没有http，如：http://89495c4f.ngrok.io是错误的，应该是： 89495c4f.ngrok.io http://www.106jiekou.com/ https://blog.csdn.net/kingmax54212008/article/details/50811885 https://www.cnblogs.com/hoobey/p/6078584.html https://blog.csdn.net/qianxing111/article/details/79884527 http://www.it165.net/pro/html/201606/70831.html]]></content>
      <categories>
        <category>微信</category>
      </categories>
      <tags>
        <tag>微信公众平台</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ngrok的使用]]></title>
    <url>%2F2018%2F10%2F06%2Fngrok%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[https://ngrok.com/ https://blog.csdn.net/liu_005/article/details/79557818]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>ngrok</tag>
        <tag>网络工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信第三方登录]]></title>
    <url>%2F2018%2F10%2F06%2F%E5%BE%AE%E4%BF%A1%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95%2F</url>
    <content type="text"><![CDATA[https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421140842 用户在微信客户端中访问第三方网页，公众号可以通过微信网页授权机制，来获取用户基本信息，进而实现业务逻辑。 open id：在关注者与公众号产生消息交互后，公众号可获得关注者的open id， 同一个用户，在不同公众号或移动应用下对应有不同open id标识； union id：同一个用户，在不同公众号或移动应用下unionID相同；前提是，如若需要做多个公众号以及移动应用账户互通，得到唯一身份标识union id，则需要将多个公众号或移动应用在微信开放平台进行绑定，然后我们才能给拿到union id； 微信联合登录；也就是我们常用的微信移动端/PC端之间的扫码登录，PC端用微信扫码登录，微信移动端确认授权登录后，应用可以从微信拿到用户的open id或union id，将微信获取的用户信息与自己账户体系中的用户身份进行关联； 授权登录：需要用户确认登录，这样可以通过用户的个人确认，获取用户全面的信息，无论是否关注相关微信公众号等都可以获取。]]></content>
      <categories>
        <category>微信</category>
      </categories>
      <tags>
        <tag>微信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ASP.NET HTML表单元素]]></title>
    <url>%2F2018%2F10%2F06%2FC-%E5%BC%80%E5%8F%91-2018-10-06-ASP-NET-HTML%E8%A1%A8%E5%8D%95%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[BeginForm https://www.cnblogs.com/sheng-jie/p/6305385.html]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>ASP.NET</tag>
        <tag>HTML表单元素</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ASP.NET WebForms学习笔记]]></title>
    <url>%2F2018%2F10%2F05%2FC-%E5%BC%80%E5%8F%91-2018-10-05-ASP-NET-WebForms%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[申明 文章内容记录自：http://www.w3school.com.cn/aspnet/aspnet_intro.asp， 为个人学习笔记记录。 说明 WebForms可类比WinForm开发，通过可视化拖动的方式快速完成Web页面开发.]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>ASP.NET</tag>
        <tag>WebForms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ASP.NET MVC学习笔记]]></title>
    <url>%2F2018%2F10%2F05%2FC-%E5%BC%80%E5%8F%91-2018-10-05-ASP-NET-MVC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[申明 文章内容记录自：http://www.w3school.com.cn/aspnet/mvc_intro.asp， 为个人学习笔记记录。 MVC项目文件夹 典型的 ASP.NET MVC web 应用程序拥有如下文件夹内容： 123456789101112131415161718192021222324应用程序信息* Properties* 引用应用程序文件夹* App_Data 文件夹 //用于存储应用程序数据* App_Start 文件夹 //含应用程序的配置逻辑文件 ** BundleConfig.cs: 注册所使用的捆绑的CSS 和 JS文件。 ** FilterConfig.cs: 注册外部/全局过滤器，这些过滤器可以被应用到每个Action和Controller中去. ** RouteConfig.cs: 配置MVC应用程序的系统路由路径。 ** Startup.Auth.cs: 配置MVC应用程序的安全信息，包括Authentication和Authorization配置 * Content 文件夹 //用于静态文件，比如样式表（CSS 文件）、图表和图像* Controllers 文件夹 //包含负责处理用户输入和响应的控制器类,名称必须以 &quot;Controller&quot; 结尾* Models 文件夹 //包含表示应用程序模型的类。模型存有并操作应用程序的数据* Scripts 文件夹 //存储应用程序的 JavaScript 文件* Views 文件夹 //存有与应用程序的显示相关的 HTML 文件 ** Shared //用于存储控制器间分享的视图 ** [名称] //每个控制器对应的一个文件夹 ** _ViewStart.cshtml //其内代码被自动添加到由应用程序显示的所有视图。配置文件* Global.asax //主要是web应用程序的全局设置文件，该文件包含响应 ASP.NET 或HTTP模块所引发的应用程序级别和会话级别事件的代码。Global.asax 文件驻留在 ASP.NET 应用程序的根目录中。运行时，分析 Global.asax 并将其编译到一个动态生成的 .NET Framework 类，该类是从HttpApplication基类派生的。配置 ASP.NET，以便自动拒绝对 Global.asax 文件的任何直接的 URL 请求；外部用户不能下载或查看其中的代码。Global.asax 文件是可选的。只在希望处理应用程序事件或会话事件时，才应创建它.* packages.config //NuGet管理用的* Web.config 控制器位于 Controllers 文件夹，视图位于 Views 文件夹，模型位于 Models 文件夹。您不必在应用程序代码中使用文件夹名称 控制器Controllers web 服务器通常会将进入的 URL 请求直接映射到服务器上的磁盘文件.某个 URL 请求（比如 “http://www.abc.cn/index.asp”）将映射到服务器根目录上的文件 “index.asp”。 MVC 框架的映射方式有所不同。 MVC 将 URL 映射到方法。这些方法在类中被称为“控制器”。控制器负责处理进入的请求、处理输入、保存数据、并把响应发送回客户端。 在mvc中所有的controller类都必须使用&quot;Controller&quot;后缀来命名,并且对Action也有一定的要求： 必须是一个public方法 必须是实例方法 没有标志NonActionAttribute特性的(NoAction) 不能被重载 必须返回ActionResult类型 具体可返回数据类型请参考：https://blog.csdn.net/pasic/article/details/7110134 模型Models 模型包含所有应用程序逻辑（业务逻辑、验证逻辑、数据访问逻辑），除了纯视图和控制器逻辑。 HTML帮助器 HTML 帮助器用于修改 HTML 输出。 HTML 链接 通过 MVC，Html.ActionLink() 不连接到视图。它创建控制器操作（controller action）的连接。 HTML 表单元素 BeginForm() EndForm() TextArea() TextBox() CheckBox() RadioButton() ListBox() DropDownList() Hidden() Password() 1234567891011121314151617181920212223242526272829303132333435&lt;%= Html.ValidationSummary(&quot;Create was unsuccessful. Please correct the errors and try again.&quot;) %&gt;&lt;% using (Html.BeginForm())&#123;%&gt;&lt;p&gt;&lt;label for=&quot;FirstName&quot;&gt;First Name:&lt;/label&gt;&lt;%= Html.TextBox(&quot;FirstName&quot;) %&gt;&lt;%= Html.ValidationMessage(&quot;FirstName&quot;, &quot;*&quot;) %&gt;&lt;/p&gt;&lt;p&gt;&lt;label for=&quot;LastName&quot;&gt;Last Name:&lt;/label&gt;&lt;%= Html.TextBox(&quot;LastName&quot;) %&gt;&lt;%= Html.ValidationMessage(&quot;LastName&quot;, &quot;*&quot;) %&gt;&lt;/p&gt;&lt;p&gt;&lt;label for=&quot;Password&quot;&gt;Password:&lt;/label&gt;&lt;%= Html.Password(&quot;Password&quot;) %&gt;&lt;%= Html.ValidationMessage(&quot;Password&quot;, &quot;*&quot;) %&gt;&lt;/p&gt;&lt;p&gt;&lt;label for=&quot;Password&quot;&gt;Confirm Password:&lt;/label&gt;&lt;%= Html.Password(&quot;ConfirmPassword&quot;) %&gt;&lt;%= Html.ValidationMessage(&quot;ConfirmPassword&quot;, &quot;*&quot;) %&gt;&lt;/p&gt;&lt;p&gt;&lt;label for=&quot;Profile&quot;&gt;Profile:&lt;/label&gt;&lt;%= Html.TextArea(&quot;Profile&quot;, new &#123;cols=60, rows=10&#125;)%&gt;&lt;/p&gt;&lt;p&gt;&lt;%= Html.CheckBox(&quot;ReceiveNewsletter&quot;) %&gt;&lt;label for=&quot;ReceiveNewsletter&quot; style=&quot;display:inline&quot;&gt;Receive Newsletter?&lt;/label&gt;&lt;/p&gt;&lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;Register&quot; /&gt;&lt;/p&gt;&lt;%&#125;%&gt; MVC参考手册 http://www.w3school.com.cn/aspnet/mvc_reference.asp]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>ASP.NET</tag>
        <tag>MVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Razor使用]]></title>
    <url>%2F2018%2F10%2F05%2FC-%E5%BC%80%E5%8F%91-2018-10-05-Razor%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[申明 文章内容记录自：http://www.w3school.com.cn/aspnet/razor_intro.asp， 为个人学习笔记记录。 说明 Razor 是一种允许您向网页中嵌入基于服务器的代码的标记语法。Razor 基于 ASP.NET，它为 web 应用程序的创建而设计。 当网页被写入浏览器时，基于服务器的代码能够创建动态内容。在网页加载时，服务器在向浏览器返回页面之前，会执行页面内的基于服务器代码。由于是在服务器上运行，这种代码能执行复杂的任务，比如访问数据库。 C# 的主要 Razor 语法规则 Razor 代码块由 @{ … } 包围 行内表达式（变量和函数）以 @ 开始 代码语句以分号结束 变量通过 var 关键词进行声明 字符串用引用来包围 C# 代码对大小写敏感 C# 文件的扩展名是 .cshtml 编程 Razor编程支持变量、循环、逻辑。 变量 1234567var myString = &apos;103&apos;;int counter = 103; if (myString.IsInt())&#123; myInt=myString.AsInt();&#125; 循环 1234&lt;body&gt;@for(var i = 10; i &lt; 21; i++) &#123;&lt;p&gt;Line @i&lt;/p&gt;&#125;&lt;/body&gt; 123456&lt;body&gt;&lt;ul&gt;@foreach (var x in Request.ServerVariables) &#123;&lt;li&gt;@x&lt;/li&gt;&#125;&lt;/ul&gt;&lt;/body&gt; 12345678910&lt;body&gt;@&#123;var i = 0;while (i &lt; 5) &#123; i += 1; &lt;p&gt;Line #@i&lt;/p&gt; &#125;&#125;&lt;/body&gt; 1234567891011121314151617@&#123;var price=25;&#125;&lt;html&gt;&lt;body&gt;@if (price&gt;=30) &#123; &lt;p&gt;The price is high.&lt;/p&gt; &#125;else if (price&gt;20 &amp;&amp; price&lt;30) &#123; &lt;p&gt;The price is OK.&lt;/p&gt; &#125;else &#123; &lt;p&gt;The price is low.&lt;/p&gt; &#125; &lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425@&#123;var weekday=DateTime.Now.DayOfWeek;var day=weekday.ToString();var message=&quot;&quot;;&#125;&lt;html&gt;&lt;body&gt;@switch(day)&#123;case &quot;Monday&quot;: message=&quot;This is the first weekday.&quot;; break;case &quot;Thursday&quot;: message=&quot;Only one day before weekend.&quot;; break;case &quot;Friday&quot;: message=&quot;Tomorrow is weekend!&quot;; break;default: message=&quot;Today is &quot; + day; break;&#125;&lt;p&gt;@message&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>ASP.NET</tag>
        <tag>Razor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ASP.NET WebPages学习笔记]]></title>
    <url>%2F2018%2F10%2F05%2FC-%E5%BC%80%E5%8F%91-2018-10-05-WebPages%2F</url>
    <content type="text"><![CDATA[申明 文章内容记录自：http://www.w3school.com.cn/aspnet/webpages_intro.asp， 为个人学习笔记记录。 说明 Web Pages 是三种 ASP.NET 编程模型中的一种，用于创建 ASP.NET 网站和 web 应用程序。 布局 在因特网上，您会发现很多拥有统一外观的网站： 每页拥有相同的页眉 每页拥有相同的页脚 每页拥有相同的样式和布局 可以通过以下方式实现： 使用 @RenderPage() 方法从不同的文件导入内容 1234567&lt;html&gt;&lt;body&gt;@RenderPage("header.cshtml")&lt;h1&gt;Hello Web Pages&lt;/h1&gt; @RenderPage("footer.cshtml")&lt;/body&gt;&lt;/html&gt; 使用布局页面 布局网页包含网页的结构，而不是内容。当网页（内容页）链接到布局页时，它会根据布局页（模板）来显示。布局页类似普通的网页，但是会在引用内容页的位置调用 @RenderBody() 方法。每个内容页必须以 Layout 指令开头。 布局页面： 12345&lt;html&gt;&lt;body&gt; @RenderBody() &lt;/body&gt;&lt;/html&gt; 任意网页： 12@&#123;Layout="Layout.cshtml";&#125;&lt;h1&gt;Welcome to W3Schools&lt;/h1&gt; 防止代码泄露 在 ASP.NET 中，名称以下划线开头的文件无法通过 web 来浏览。如果您希望禁止用户查看内容块或布局文件，请对文件重新命名,如：_Layout.cshtml ~ 操作符 与 Href 方法 使用 ~ 操作符在编程代码中规定虚拟根目录,作为项目资源路径根路径，如：var myImagesFolder = “~/images”; Href 方法把代码中的路径转换为浏览器能够理解的路径（浏览器无法理解 ~ 操作符），如： 123@&#123;var myStyleSheet = &quot;~/Shared/Site.css&quot;;&#125;&lt;!-- 创建指向 CSS 文件的链接 --&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;@Href(myStyleSheet)&quot; /&gt; Page对象 Page对象为内置对象，类似与JSP中的Request等对象 方法 描述 href 使用指定的参数构建 URL。 RenderBody() 在布局页中，将呈现不在指定部分中的内容页部分。 RenderPage(page) 在其他页内呈现某一页的内容。 RenderSection(section) 在布局页中，将呈现指定部分的内容。 Write(object) 将指定的对象作为 HTML 编码的字符串写入。 WriteLiteral 无需先对指定的对象进行 HTML 编码，即可将其写入。 属性 描述 isPost 返回一个值（true 或 false），指示客户端用来请求网页的 HTTP 数据传输方法是否为 POST 请求。 Layout 获取或设置布局页的路径。 Page 提供对页面、布局页和分页之间共享的页数据的类似属性的访问。 Request 获得当前 HTTP 请求的 HttpRequest 对象。 Server 获取 HttpServerUtility 对象，该对象所提供的方法能够在网页处理过程中使用。 Web Pages帮助器 Web Helpers 极大地简化了 web 开发和常见的编程任务。其内部实现了表格、图表等内容显示的逻辑及样式，进行了特定封装。 Web Pages参考手册 http://www.w3school.com.cn/aspnet/webpages_ref_classes.asp]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>ASP.NET</tag>
        <tag>WebPages</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ASP.NET简介]]></title>
    <url>%2F2018%2F10%2F05%2FC-%E5%BC%80%E5%8F%91-2018-10-05-ASP-NET%2F</url>
    <content type="text"><![CDATA[申明 文章内容记录自：http://www.w3school.com.cn/aspnet/index.asp， 为个人学习笔记记录。 简介 ASP.NET 是一个开发框架，用于通过 HTML、CSS、JavaScript 以及服务器脚本来构建网页和网站。 ASP.NET 是新一代的 ASP。它无法兼容经典 ASP，但 ASP.NET 可以引用 ASP。 当浏览器请求 ASP.NET 文件时，ASP.NET 引擎读取该文件，编译并执行文件中的脚本，然后以纯 HTML 向浏览器返回结果。 ASP.NET 支持三种开发模式／服务器技术： Web Pages：单页面模型 MVC：模型视图控制器 Web Forms：事件驱动模型 ASP.NET 文件扩展名 ASP 文件的文件扩展名是 .asp ASP.NET 文件的文件扩展名是 .aspx ASP.NET 文件使用 C# 语法的文件扩展名是 .cshtml ASP.NET 文件使用 Razor VB 语法的文件扩展名是 .vbhtml 版本区别 2009年发行ASP.NET MVC 1.0版 2010年发行ASP.NET MVC 2.0版，VS2010 2011年发行ASP.NET MVC 3.0版+EF4，需要.Net4.0支持，VS2011 2012年发行ASP.NET MVC 4.0版+EF5，需要.Net4.0支持，VS2012 2013年发行ASP.NET MVC 5.0版+EF6，需要.Net4.5支持，VS2013 2015年发行ASP.NET MVC 6.0版+EF7，需要.Net5.0支持，VS2015 ASP.NET 5.0 将改名为 ASP.NET Core 1.0 ASP.NET MVC 6 将改名为 ASP.NET MVC Core 1.0 Entity Framework 7.0 将改名为 Entity Framework Core 1.0 .NET新的跨平台版本将命名为.NET Core 1.0 推荐文章 WebForms vs. MVC： http://www.cnblogs.com/heyuquan/p/webForms-vs-mvc.html]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>ASP.NET</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows下SVN服务器搭建及VS2015插件安装联动]]></title>
    <url>%2F2018%2F10%2F05%2FC-%E5%BC%80%E5%8F%91-2018-10-05-Windows%E4%B8%8BSVN%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E5%8F%8AVS2015%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85%E8%81%94%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[SVN服务端软件下载：https://www.visualsvn.com/server/download/ VisualSVN-Server-3.9.1-x64以管理员权限（有的话）安装,一路默认，选择standard版本,其他都是默认 SVN客户端软件下载：https://www.visualsvn.com/visualsvn/download/tortoisesvn/ 默认安装 VS2015插件下载： https://www.visualsvn.com/visualsvn/download/]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>版本控制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL安装_Windows]]></title>
    <url>%2F2018%2F10%2F05%2FMySQL%E5%AE%89%E8%A3%85-Windows%2F</url>
    <content type="text"><![CDATA[下载页面：https://dev.mysql.com/downloads/mysql/ 选择&quot;Microsoft Windows&quot;,下载免安装版的zip文件; 将zip文件解压到本地 新建一个配置文件（my.ini）用于配置字符集、端口等信息，用以覆盖原始的配置文件（my-default.ini），当然也可以修改这个默认的配置文件 123456789101112131415161718[mysql] # 设置mysql客户端默认字符集 default-character-set=utf8 [mysqld] #设置3306端口 port = 3306 # 设置mysql的安装目录 basedir=D:\\softwares\\mysql-5.7.14-winx64 # 设置mysql数据库的数据的存放目录 datadir=D:\\softwares\\mysql-5.7.14-winx64\\data # 允许最大连接数 max_connections=200 # 服务端使用的字符集默认为UTF8 character-set-server=utf8 # 创建新表时将使用的默认存储引擎 default-storage-engine=INNODB 输入cmd，以管理员身份运行控制台 S C:\Windows\system32&gt; cd S C:\Windows\system32&gt; cd … S C:\Windows&gt; cd … S C:&gt; cd .\mysql-8.0.12-winx64 S C:\mysql-8.0.12-winx64&gt; cd .\bin\ S C:\mysql-8.0.12-winx64\bin&gt; .\mysqld.exe -install ervice successfully installed. S C:\mysql-8.0.12-winx64\bin&gt; net start mysql ySQL 服务正在启动 . ySQL 服务无法启动。 服务没有报告任何错误。 请键入 NET HELPMSG 3534 以获得更多的帮助。 S C:\mysql-8.0.12-winx64\bin&gt; .\mysqld.exe -remove ervice successfully removed. S C:\mysql-8.0.12-winx64\bin&gt; .\mysqld.exe --initialize S C:\mysql-8.0.12-winx64\bin&gt; .\mysqld.exe -install ervice successfully installed. S C:\mysql-8.0.12-winx64\bin&gt; net start mysql ySQL 服务正在启动 . ySQL 服务已经启动成功。 S C:\mysql-8.0.12-winx64\bin&gt; .\mysqladmin.exe -u root password “axn7Og=ve;+2” ysqladmin: connect to server at ‘localhost’ failed alter user user() identified by “root”; alter user user() identified by “新密码”; mysql -u root -p ysql&gt; use mysql atabase changed ysql&gt; ALTER USER ‘root’@‘localhost’ IDENTIFIED WITH mysql_native_password BY ‘root’; uery OK, 0 rows affected (0.04 sec) ysql&gt; flush privileges; uery OK, 0 rows affected (0.00 sec) use mysql 4.ALTER USER ‘root’@‘localhost’ IDENTIFIED WITH mysql_native_password BY ‘root’; 5.flush privileges; 6.可以用navicat登陆了 https://www.cnblogs.com/anstoner/p/6414440.html net stop mysql https://blog.csdn.net/czhilovely/article/details/80360146 https://blog.csdn.net/qq_42923798/article/details/81540122 https://blog.csdn.net/u012561176/article/details/78557320]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jenkins]]></title>
    <url>%2F2018%2F10%2F05%2FCI-Jekins%2F</url>
    <content type="text"><![CDATA[Jenkins 官网下载：https://jenkins.io/download/ ,注意下载的版本要与jdk的版本对应 Jenkins是基于Java开发的一种持续集成工具，用于监控持续重复的工作，功能包括：持续的软件版本发布/测试项目；监控外部调用执行的工作 持续集成：指开发者在代码的开发过程中，可以频繁的将代码部署集成到主干，并进程自动化测试 持续交付：指的是在持续集成的环境基础之上，将代码部署到预生产环境 持续部署：在持续交付的基础上，把部署到生产环境的过程自动化，持续部署和持续交付的区别就是最终部署到生产环境是自动化的]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>持续集成</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo使用速记]]></title>
    <url>%2F2018%2F10%2F04%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-10-hexo%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[说明 Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。详细学习请参考：https://hexo.io/zh-cn/docs 。 本文章只是个人使用过程中重点内容记录。 安装 前置安装：node，git 安装：npm install -g hexo-cli 初始化项目 mkdir [项目名称, 如：test] hexo init [项目名称, 如：test] //此处要求文件夹内为空 cd [项目名称, 如：test] npm install 常用命令 hexo new [layout] ‘【文章名称】’ //创建不通类型文章 1234laytou及路径如下：post source/_postspage sourcedraft source/_drafts hexo clean //清除hexo生成静态网站内容 hexo g //生成hexo静态网站 hexo s //启用hexo服务 hexo d //hexo网站部署，配合hexo-deployer-git插件使用 hexo version //hexo相关软件版本 hexo list [type] //type:post,page等 Front-matter和JSON Front-matter 用来设定文章的一些参数，如是否添加密码、版权、标签、分类等信息。 Front-matter 是文件最上方以 — 分隔的区域，用于指定个别文件的变量，基于YAML 123title: Hello Worlddate: 2013/7/13 20:46:25--- JSON Front-matter 使用 JSON 来编写 Front-matter，只要将 — 代换成 ;;; 即可 123&quot;title&quot;: &quot;Hello World&quot;,&quot;date&quot;: &quot;2013/7/13 20:46:25&quot;;;; 可配置参数如下： 参数 描述 默认值 layout 布局 title 标题 date 建立日期 文件建立日期 updated 更新日期 文件更新日期 comments 开启文章的评论功能 true tags 标签（不适用于分页） categories 分类（不适用于分页） permalink 覆盖文章网址 可以通过直接修改scaffolds内的模版来设定统一的文章额外信息，如： 123456789101112---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;tags: - - categories: password: copyright: truecomments: truetoc: true--- 部署 安装 hexo-deployer-git：npm install hexo-deployer-git --save 配置hexo的_config.yml文件 1234567# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://[XXX]@github.com/[XXX]/[XXX].github.io //库（Repository）地址,如：https://epaypad@github.com/epaypad/epaypad.github.io branch: master //分支名称 message: https://github.com/chetaofeng/MyHexoBlogSource 内容部署 &#123;&#123; now(&apos;YYYY-MM-DD HH:mm:ss&apos;) &#125;&#125; //自定义提交信息 hexo d //命令执行后，稍等一会查看部署结果 hexo主题 hexo默认主题为landscape，大家可以根据各自需要使用不通主题。 本人使用的是NexT主题，使用请参考：http://theme-next.iissnan.com ，NexT更多配置，请参考： https://www.jianshu.com/p/1f8107a8778c]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL安装配置]]></title>
    <url>%2F2018%2F10%2F04%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-11-MySQL%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[简介 下载地址：https://dev.mysql.com/downloads/mysql/ 官方数据客户端工具： https://dev.mysql.com/downloads/workbench/ 推荐客户端工具：Navicat Premium- https://www.navicat.com/en/download/navicat-premium 安装登陆 mac系统 安装dmg安装包，如：mysql-5.7.8-rc-osx10.9-x86_64.dmg，安装过程中会弹出临时的密码，务必截图保存方便后面更改密码，安装过程有时会卡顿，时间会比较长，需耐心等待一会。 在【系统偏好设置】中启动MySQL服务，如果启动不起来，可选择开机启动，然后重启macOS 在MySQLWorkBench中，创建连接信息,hostname-127.0.0.1或localhost，端口3307 点击&quot;Store in Keychain…&quot;输入安装时提示的临时密码后确定 如果临时密码输入正确，则会弹出修改密码界面，修改密码后重新登陆即可 Linux系统 Linux下安装有多种方式： 直接用软件仓库自动安装（如：ubuntu下，sudo apt-get install mysql-server） 通过下载deb或rmp安装包，直接双击安装 下载tar安装包，解压到硬盘，然后自己配置mysql 通过源码编译安装 以下以tar包安装记录:参考文章（http://www.pianshen.com/article/975954037/） sudo cp mysql-8.0.13-linux-glibc2.12-x86_64.tar.xz /usr cd /usr sudo tar xvJf mysql-8.0.13-linux-glibc2.12-x86_64.tar.xz 为MySQL创建专用用户，用户名为mysql，用户组为mysql； sudo groupadd mysql //创建组 sudo useradd -r -g mysql mysql //创建用户并划入mysql组下 为解压出来的所有文件更改用户和组 sudo chown -R mysql mysql-8.0.13-linux-glibc2.12-x86_64 //更改拥有者 sudo chgrp -R mysql mysql-8.0.13-linux-glibc2.12-x86_64 //更改组 sudo apt-get install libaio1 libaio-dev 初始化数据库: sudo ./bin/mysqld --initialize --user mysql 执行过程中会生成一个临时密码，一定要保存好，后面修改密码需要用到，如图： 开启服务: bin/mysqld_safe --user=mysql &amp; 使用用户root登录: bin/mysql -uroot -p 更改root用户密码: 12345ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;root&apos; PASSWORD EXPIRE NEVER; //修改root的密码与加密方式use mysql; #切换到mysql库 update user set host=&apos;%&apos; where user=&apos;root&apos;; //更改可以登录的IP为任意IPALTER user &apos;root&apos;@&apos;%&apos; IDENTIFIED WITH mysql_native_password BY &apos;root&apos;; //再次更改root用户密码，使其可以在任意IP访问flush privileges; #刷新权限 通过客户端测试登陆即可 Navicat安装 Linux 进入安装包所在目录下，如：navicat_premium12_cs_x64_for_linux.zip sudo cp navicat_premium12_cs_x64_for_linux.zip /usr/ cd /usr/ sudo unzip navicat_premium12_cs_x64_for_linux.zip cd navicat120_premium_cs_x64 命令行启动：sudo ./start_navicat，正常的话应该会出现一个Win Mono下载界面，可不下载，跳过即可 Windows &amp; macOS 直接下载安装就行，破解请自行查找]]></content>
      <tags>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL安装配置]]></title>
    <url>%2F2018%2F10%2F04%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-11-VirturalBox%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[https://jingyan.baidu.com/article/36d6ed1f821ca21bcf4883da.html]]></content>
      <tags>
        <tag>node</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Github Pages进行个人博客搭建]]></title>
    <url>%2F2018%2F10%2F02%2FGithubPages%2F</url>
    <content type="text"><![CDATA[Github Pages介绍 官网：https://pages.github.com/ GitHub Pages 是一个静态网站托管服务，使用github.io域名和HTTPS来提供服务。一个github账号只能有一个Github Pages网站。 GitHub Pages 网站是在网络上公开使用的，即使他们的库是私有的。如果你敏感的数据在你的Page库中，你可能需要在发布之前删除它。 Github Pages创建 申请邮箱 申请github账号 1前两步是为了准备没有进行Github Pages服务开通的github账号，如果已经有，可以跳过 创建repository。和普通创建一样，但是名称要以&quot;.github.io&quot;结尾，如：test.github.io，这样创建完之后才在这个项目的settings中有github pages选项 访问：https://test.github.io/,即可以看见Github Pages网站 Github Pages网站内容编辑 创建源码repository，用来存放Github Pages网站源码 此处选用Hexo作为网站模版，在本地初始化hexo项目，参考： 在hexo中安装配置hexo-deployer-git进行github项目管理 下载【1】中github代码到本地，本人是通过webstorm进行编辑操作的 拷贝【2】中代码到【1】中的repository中，在本地运行查看hexo效果 编辑.gitignore文件,忽略操作系统文件、编辑器临时文件、node临时文件等，提交 提交repository到github hexo部署本地代码到Github Pages，查看效果]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>github pages</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava从源码到应用移动端开发效率秒提速]]></title>
    <url>%2F2018%2F10%2F02%2Fandroid-RxJava%2F</url>
    <content type="text"><![CDATA[响应式编程思想概述 响应式编程：是一种面向数据流和变化传播的编程范式 数据流：只能以事先规定好的顺序被读取一次的数据的一个序列 变化传播：类似观察者模式，变化了要通知别人 RxJava源码分析 基本元素 RxJava是一个基于回调的异步的库，是一个基于事件分发和消息传递的库 Operator操作符变换原理 Scheduler线程变换原理 整体变换compose和transformer原理]]></content>
      <tags>
        <tag>andrioid</tag>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gradle3.0自动化项目构建技术]]></title>
    <url>%2F2018%2F10%2F02%2Fandroid-Gradle3-0%E8%87%AA%E5%8A%A8%E5%8C%96%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[Groovy快速入门 领域特定语言DSL（Domain Specific Language）：其核心思想为&quot;求专不求全，解决特定问题&quot;， Groovy： http://www.groovy-lang.org/ Groovy：是一种基于JVM的敏捷开发语言，结合了Python、Ruby等脚本语言的许多强大特性，可以与Java完美结合，使用Java的所有库； 语法上支持动态类型，闭包等新一代语言特性 无缝继承所有Java的库（可以完全用Java写，但是不推荐） 即支持面向对象编程，也支持面向过程编程 优势：一种更加敏捷的编程语言；入门非常容易，但是功能非常强大；既可以作为编程语言也可以作为脚本语言；熟练掌握Java的人会非常容易掌握Groovy Groovy开发环境搭建： java平台上有各种语言的翻版，例如kotlin对c#,scala对haskell,Clojure对lisp，groovy对ruby macOS/Linux 安装配置好JDK 下载Groovy SDK并解压到合适未知 配置bin目录到/.bash_profile中，如添加如下内容到/.bash_profile 1export PATH=$PATH:/usr/groovy-2.5.5/bin groovy -version InteliJ IDEA配置 确保已安装Groovy插件 配置Groovy SDK未知 编写Groovy版本HelloWorld，注意查看编译后文件 123456//Java版本class Test &#123; public static void main(String[] args)&#123; System.out.println(&quot;Hello world&quot;); &#125;&#125; 12//Groovy版本print &quot;Hello world&quot; Groovy基础语法 变量 变量的类型：基本类型+对象类型，Groovy中没有基本类型，所有的基本类型都会被编译器包装成对象类型，如：int-&gt;Integer 变量的定义：强类型定义方式+弱类型def定义方式，Groovy中如果变量的值可以推断除其类型，则可通过def声明为弱类型，区别于java中的强类型定义方式，如：int i=1； 推荐在自有使用模块使用def方式定义，如果有其他模块或其他类使用推荐强类型定义方式 字符串：String + GString String的使用和Java中一致，GString定义方式如下： def name = ‘Hello name’ //不支持可扩展字符串 def doubleName = “Hello doubleName” //可扩展字符串，如：def doubleName = “Hello doubleName and ${name}”,结果为： Hello doubleName and Hello name，此时doubleName是org.codehaus.groovy.runtime.GStringImpl的子类 def thupleName = ‘’‘Hello thupleName’’’ //支持多行方式 无可扩展字符串时以上3种方式的String都是java.lang.String的子类，编码过程中String和GString是可以通用的，更多从方便使用角度考虑即可 Groovy字符串方法介绍 java中String原有的方法 DefalutGroovyMethods StringGroovyMethods：普通类型的参数+闭包类型的参数 12345678910def str = &quot;Groovy&quot;，str2 = &quot;Hello&quot;,str3= &quot;Hello minus&quot;//字符串填充:center(),paddingLeft(),paddingRight()println str.center(8,&apos;a&apos;) //aGroovya//字符串比较：类似于数字比较；compareTo()println str &gt; str2 //false//获取字符串索引:类似于数组下标；charAt()println str[0..1] //Gr//减法运算:类似于数字减法；minus()println str3.minus(str2) // minus//其他方法自己摸索 逻辑控制：单步顺序执行|if／else|switch-case|while|for，基本和Java操作一致，针对Groovy扩展介绍如下： 123456789101112131415161718192021//switch-casedef x=1.23,resultswitch(x)&#123; //switch(x.class) case &quot;name&quot;: result = &quot;name&quot; break case Integer: result = &quot;Integer&quot; break case BigDecimal: result = &quot;BigDecimal&quot; break case [1,2,3]: //列表 result = &quot;list&quot; break case 1..10: //范围 result = &quot;range&quot; default: result=&quot;defalut&quot;&#125;println result //BigDecimal for循环控制 1234567891011121314//对范围的for循环def sum =0for(i in 0..9)&#123; sum += i&#125;println sum //45//对list的for循环for(i in [1,2,3,4,5])&#123; sum += i&#125;//对map的for循环for(i in [&quot;lili&quot;:1,&quot;lucy&quot;:2])&#123; println i.key + &quot;:&quot; +i.value&#125; 闭包 闭包就是一个代码块，所以需要通过{}括起来，def clouser = { println “Hello Groovy!”};clouser.call();clouser(); //推荐call()方式调用来区分是闭包 def clouser = {String name -&gt; println “Hello Groovy ${name}!”};clouser.call(“a”);clouser(“b”); 隐式参数it：def clouser = {println “Hello Groovy ${it}!”};clouser.call(“a”);clouser(“b”); 闭包返回值：总是有返回值的，当闭包体没有明确返回值的时候，返回结果就是null 如果最后一个参数是闭包，闭包可以写在外面 闭包的使用 与基本类型的结合使用 123456789101112131415161718192021int fab1(int number)&#123; int result = 1 1.upto(number,&#123;num -&gt; result *= num &#125;) return result&#125;int fab2(int number)&#123; int result = 1 number.downto(1) &#123; num -&gt; result *= num &#125; return result&#125;int cal(int number)&#123; int result = 0 number.times &#123; num -&gt; result += num &#125; return result&#125; 与String结合使用 123456def str = &quot;the 2 and 3 is 5&quot;str.each &#123;String tmp -&gt; print tmp.multiply(2)&#125; //tthhee 22 aanndd 33 iiss 55println str.find &#123;String tmp -&gt; tmp.isNumber()&#125; //2println str.any &#123;String tmp -&gt; tmp.isNumber()&#125; //trueprintln str.every &#123;String tmp -&gt; tmp.isNumber()&#125; //falsedef list = str.collect &#123;it.toUpperCase()&#125;;println list.toListString() //[T, H, E, , 2, , A, N, D, , 3, , I, S, , 5] 与数据结构结合使用 与文件等结合使用 闭包进阶：闭包关键字（this，owner，delegate）+闭包委托策略 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465def scriptClosure = &#123; println &quot;scriptClosure this:&quot;+this //代表闭包定义处的类 println &quot;scriptClosure owner:&quot;+owner //代表闭包定义处的类或对象 println &quot;scriptClosure delegate:&quot;+delegate //代表任意对象，默认值为owner&#125;scriptClosure.call()//scriptClosure this:Test@3c130745//scriptClosure owner:Test@3c130745//scriptClosure delegate:Test@3c130745class Person&#123; def static classClosure = &#123; println &quot;classClosure this:&quot;+this println &quot;classClosure owner:&quot;+owner println &quot;classClosure delegate:&quot;+delegate &#125; def static say()&#123; def methodClosure = &#123; println &quot;methodClosure this:&quot;+this println &quot;methodClosure owner:&quot;+owner println &quot;methodClosure delegate:&quot;+delegate &#125; methodClosure.call() &#125;&#125;//静态方法调用Person.classClosure()Person.say()//全部指向Person类,闭包指向离他最近的封闭类//classClosure this:class Person//classClosure owner:class Person//classClosure delegate:class Person//methodClosure this:class Person//methodClosure owner:class Person//methodClosure delegate:class Person//修改Person类中方法，取消static限定符调用Person p = new Person()p.classClosure()p.say()//全部指向Person类对象，闭包指向离他最近的封闭类对象classClosure this:Person@a9cd3b1classClosure owner:Person@a9cd3b1classClosure delegate:Person@a9cd3b1methodClosure this:Person@a9cd3b1methodClosure owner:Person@a9cd3b1methodClosure delegate:Person@a9cd3b1//嵌套闭包def outerClosure = &#123; def innerClosure = &#123; println &quot;innerClosure this:&quot;+this println &quot;innerClosure owner:&quot;+owner println &quot;innerClosure delegate:&quot;+delegate &#125; innerClosure.call()&#125;outerClosure.call()//innerClosure this:Test@3c130745//innerClosure owner:Test$_run_closure7@9353778 //指向outerClosure//innerClosure delegate:Test$_run_closure7@9353778 总结：this、owner、delegate的值在大多数情况都是一样的，在嵌套闭包中this的值和owner、delegate的值不一致，只有在给delegate赋值后owner和delegate的值才不一致 闭包的委托策略 123456789101112131415161718192021222324class Student&#123; String name def sayName = &#123; &quot;My name is $&#123;name&#125;&quot;&#125; String toString()&#123; sayName.call() &#125;&#125;class Teacher&#123; String name&#125;def stu = new Student(name: &quot;XingFeng&quot;)println stu.toString()def tea = new Teacher(name: &quot;Lily&quot;)stu.sayName.delegate = teaprintln stu.toString()stu.sayName.resolveStrategy = Closure.DELEGATE_FIRST //先从delegate中查找name属性，没有了再从owner中查找println stu.toString()//My name is XingFeng//My name is XingFeng//My name is Lily 数据结构 列表的定义：def list = [1,2,3,4] 此为一个ArrayList； 数组的定义：def list = [1,2,3,4] as int[]; int[] arr=[1,2,3] 列表的排序：def list = [1,12,3,444]; Collections.sort(list);list.sort() map的定义：def colors=[“red”:1,“blue”:2];def colors=[red:1,blue:2] 索引map：println colors.red;println colors[“red”]; 添加map：colors.yellow=3 //Groovy中map可以添加不同类型的数据：colors.complex =[a:1,b:2] 遍历map： list.each{def tmp,int index -&gt; …} list.eachWithIndex{ key,value,index -&gt; …} 查找map： any find findAll every 分组map： groupBy{} 排序map：sort 范围Range：定义 def range = 1…10;println range[0];range.contains(10);println range.from;println range.to Range继承自java.util.List 1234switch(number)&#123; case 0..&lt;60 ...&#125; 面向对象 类、接口等的定义和使用 Groovy中默认类、方法等都是public类型 Groovy中无论是直接调用属性还是通过get／set方法其实质都是通过getter／setter方法调用的属性，getter／setter方法默认自动继承 接口实现需实现接口的所有方法；trait中可以有默认方法实现，没有实现的方法需添加abstract关键字，实现时只需实现abstract的方法即可 元编程（Metaprogramming）是指某类计算机程序的编写，这类计算机程序编写或者操纵其他程序（或者自身）作为它们的数据，或者在运行时完成部分本应在编译时完成的工作。很多情况下与手工编写全部代码相比工作效率更高。编写元程序的语言称之为元语言，被操作的语言称之为目标语言。一门语言同时也是自身的元语言的能力称之为反射 元编程通常有两种方式起作用。一种方式是通过应用程序接口（API）来暴露运行时引擎的内部信息。另一种方法是动态执行包含编程命令的字符串。因此，“程序能编写程序”。虽然两种方法都能用，但大多数方法主要靠其中一种。 123456789101112class Baby &#123; def invokeMethod(String name,Object args)&#123; return &quot;the method is $&#123;name&#125;,the args is $&#123;args&#125;&quot; &#125; def methodMissing(String name,Object args)&#123; return &quot;the method $&#123;name&#125; is missing&#125;&quot; &#125;&#125;def baby = new Baby()println baby.cry() 结合上图理解：Java中对象方法的调用没有上图否流程分支，在Groovy中对象方法调用有否分支调用，上例中通过注释invokeMethod、methodMissing方法查看运行效果，通过以下代码可动态添加对象属性和方法： 123Baby.metaClass.sex = &quot;male&quot;Baby.metaClass.play = &#123; ... &#125;Baby.metaClass.static.play = &#123; ... &#125; //静态方法 通过ExpandoMetaClass.enableGlobally()设置让动态添加方法全局启用 Json操作 对象转换成JSON字符串：JsonOutput.toJson() Json格式化打印：JsonOutput.prettyPrint(jsonObject) Json字符串转对象：def jsonSlurper = new JsonSlurper();jsonSlurper.parse() xml操作 Java对xml的处理：DOM文档驱动处理方式+SAX事件驱动处理方式 Groovy解析xml数据：def xmlSlurper = new XmlSlurper();def response = xmlSlurper.parse(xml); ／／response对象可以逐级访问节点，节点的属性添加@符号，如：response.books.@id，也可以通过闭包过滤信息 Groovy深度遍历xml：可以通过逐级遍历解析后的response数据，也可通过response.depFirst().find{ …}遍历或 response.’’.find{ …}遍历（’'代表深度遍历） Groovy深度遍历xml：response.books.children().find{…}或response.books.’’.find{…}（’'代表深度遍历） Groovy创建xml数据： 12345678910111213141516171819202122&apos;&apos;&apos;&lt;langs type=&apos;current&apos; count=&apos;3&apos;&gt; &lt;language flavor=&apos;static&apos; version=&apos;1.5&apos; /&gt; &lt;language flavor=&apos;public&apos; version=&apos;2.5&apos; /&gt;&lt;/langs&gt;&apos;&apos;&apos;def sw = new StringWriter()def xmlBuilder = new MarkupBuilder(sw)xmlBuilder.langs(type:&apos;current&apos;,count:3)&#123; language(flavor:&apos;static&apos;,version:&apos;1.5&apos;) language(flavor:&apos;public&apos;,version:&apos;2.5&apos;)&#125;println swdef langs = new Langs()xmlBuilder.langs(type:langs.type,count:langs.count)&#123; langs.languages.each &#123; language(flavor:it.flavor,version:it.version) &#125;&#125;println sw 文件操作 Java文件处理：节点流（InputStream、OutputStream及其子类）+处理流（Reader、Writer及其子类），所有Java对文件的操作Groovy都支持 遍历文件内容：def file = new File(“Test.iml”);file.eachLine { println it } 或 def text = file.getText() 或 def text = file.readLines() … gradle Gradle是一款最新的，功能强大的构建工具，使用程序代替传统的xml配置，项目构建更加灵活，有丰富的第三方库 gradle组成：groovy核心语法+build script block+gradle api gradle生命周期 执行./gradlew clean 观察执行过程，其生命周期包括：初始化、配置、执行 gradle生命周期的监听 在项目的build.gradle中添加如下 12345678//在配置阶段开始之前的回调this.beforeEvaluate &#123;&#125;//配置阶段完成以后的回调this.afterEvaluate &#123;&#125;//gradle生命周期执行完以后的回调this.gradle.buildFinished &#123;&#125; Gradle Project ./gradlew projects //查看工程Project数量，学会区分Project与module及根Project与子Project，每个Project必须有一个build.gradle文件 Project API组成： Project相关API：如何管理父Project及如何操作子Project this.getAllProjects()，this.getSubProjects(),this.getParent()，在gradl文件中，对应allprojects、project、subprojects进行操作 ./gradlew projects可实现显示所有项目，自我实现如下： 12345678910111213141516def getProjects()&#123; println &quot;------------------------&quot; this.getAllprojects().eachWithIndex&#123; Project project, int index -&gt; if(index == 0)&#123; println &quot;Root project:$&#123;project.name&#125;&quot; &#125;else&#123; println &quot;+--- project:$&#123;project.name&#125;&quot; &#125; &#125;&#125;this.getProjects()//------------------------//Root project:MyApplication//+--- project:app task相关API 属性相关API 父Project的属性在子项目中会被继承，可直接使用 可以在项目中通过common.gradle文件来定义扩展属性ext，然后在根Project中通过apply from:this.file(‘common.gradle’)引入后，按rootProject.ext.定义属性的方式使用 在gradle.properties中定义key-value属性，如：isLoadTest=false，然后在settings.gradle中就可以编码控制是否加载Test项目 123if(hasProperty(&apos;isLoadTest&apos;)? isLoadTest.toBoolean() : false)&#123; include &apos;:Test&apos;&#125; 自定义属性的两种方式：ext方式+gradle.properties中定义 4. file相关API 路径获取API：getRootdir()、getBuildDir()、getProjectDir() 文件操作相关API：都是基于根工程操作的，不支持跨工程操作 123456789//文件／文件夹拷贝copy &#123; from file(&apos;test.txt&apos;) into getRootProject().getBuildDir()&#125;//文件树遍历fileTree(&apos;build/&apos;)&#123; FileTree fileTree -&gt; fileTree.visit&#123; FileTreeElement element -&gt; ... &#125;&#125; gradle生命周期API 其他API 依赖相关API 12345678910111213141516171819buildscript &#123; repositories &#123; google() jcenter() &#125; dependencies &#123; classpath &apos;com.android.tools.build:gradle:3.2.1&apos; &#125;&#125;//等价于以下操作：buildscript &#123; ScriptHandler scriptHandler -&gt; scriptHandler.repositories &#123; RepositoryHandler repositoryHandler -&gt; repositoryHandler.google() repositoryHandler.jcenter() &#125; scriptHandler.dependencies &#123; classpath &apos;com.android.tools.build:gradle:3.2.1&apos; &#125;&#125; 依赖传递：A模块依赖B模块，B模块依赖C模块，如果A模块也需要C模块功能，不需依赖使用，防止B修改后去掉C依赖而导致错误，可在A中引入C模块，通过exclude排除依赖，transitive禁止依赖传递 占位编译provided：A.类库只在编译阶段起作用 B.父项目已引入类库，子项目直接使用父项目类库，但为了子项目编译通过使用占位编译 外部命令执行 1234567891011121314task abc() &#123; doLast&#123; def command = &apos;ls&apos; exec&#123; try&#123; executable &apos;bash&apos; args &apos;-c&apos;,command println &apos;command is execute success.&apos; &#125;catch(GradleException ex)&#123; println &quot;Excepiotn....&quot; &#125; &#125; &#125;&#125; 执行：./gradlew abc Task Task定义及配置 直接通过task函数去创建 1234567891011121314task(&quot;abcd&quot;) &#123; doLast&#123; def command = &apos;ls -al&apos; exec&#123; try&#123; executable &apos;bash&apos; args &apos;-c&apos;,command println &apos;command is execute success.&apos; &#125;catch(GradleException ex)&#123; println &quot;Excepiotn....&quot; &#125; &#125; &#125;&#125; 通过TaskContainer创建 123this.tasks.create(&quot;aa&quot;)&#123; println &apos;Hello task&apos;&#125; Task创建之后可在开发工具的gradle插件重查找到task，如果没有设置group，则默认在other分组中，更多配置可通过task源码查看 2. Task执行详解 doFirst/doLast执行阶段执行，否则在配置阶段执行 1234567891011task aa&#123; doFirst&#123; println &apos;Hello 2&apos; &#125;&#125;task.doFirst&#123; println &apos;Hello 1&apos;&#125;//Hello 1//Hello 2 编写一个统计build时长的task app.gradle中编写： 12345678910111213def startBuilderTime,endBuilderTimethis.afterEvaluate &#123; Project project -&gt; def preBuildTask = this.tasks.getByName(&quot;preBuild&quot;) preBuildTask.doFirst &#123; startBuilderTime = System.currentTimeMillis() println &apos;------开始计时...&apos; &#125; def buildTask = this.tasks.getByName(&quot;build&quot;) buildTask.doLast &#123; endBuilderTime = System.currentTimeMillis() println &apos;------计时结束,耗时：&apos;+(endBuilderTime - startBuilderTime) &#125;&#125; ./gradlew build执行查看结果 3. Task的依赖及执行顺序 dependsOn强依赖方式 12345678910111213task t1() &#123; doLast&#123;println &apos;task t1&apos;&#125; &#125;task t2() &lt;&lt; &#123; println &apos;task t2&apos; &#125; //此处&quot;&lt;&lt;&quot;等同于doLasttask t3(dependsOn:[t1,t2]) &#123; doLast&#123;println &apos;task t3&apos;&#125; &#125;task t4() &#123; dependsOn this.tasks.findAll &#123; task -&gt; return task.name.equals(&quot;t2&quot;)&#125;;doLast&#123;println &apos;task t4&apos;&#125; &#125;//./gradlew t3: (t1和t2执行顺序是随机的)//task t1//task t2//task t3//./gradlew t4//task t2//task t4 通过Task输入输出指定 TaskInputs:参数为任意对象及文件、文件夹；TaskOutputs:只输出文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374ext&#123; println &apos;------配置中...&apos; versionCode = 100 versionName = &quot;V2.0.0&quot; versionInfo = &quot;第一个版本&quot; destFile = file(&quot;release.xml&quot;) if(destFile != null &amp;&amp; !destFile.exists())&#123; destFile.createNewFile() &#125;&#125;class VersionMsg&#123; Integer versionCode String versionName String versionInfo&#125;task writerTask&#123; //为task指定输入 inputs.property(&quot;versionCode&quot;,this.versionCode) inputs.property(&quot;versionName&quot;,this.versionName) inputs.property(&quot;versionInfo&quot;,this.versionInfo) //为task指定输出 outputs.file destFile doLast&#123; def data = inputs.getProperties() File file = outputs.getFiles().getSingleFile() def versionMsg = new VersionMsg(data) def sw = new StringWriter() def xmlBuilder = new groovy.xml.MarkupBuilder(sw) if(file.text != null &amp;&amp; file.text.size() &lt;=0)&#123; xmlBuilder.releases&#123; release&#123; versionCode(versionMsg.versionCode) versionName(versionMsg.versionName) versionInfo(versionMsg.versionInfo) &#125; &#125; file.withWriter &#123; writer -&gt; writer.append(sw.toString()) &#125; &#125;else&#123; def lines = file.readLines() def lengths = lines.size() - 1 file.withWriter &#123; writer -&gt; lines.eachWithIndex&#123; String line, int index -&gt; if(index != lengths)&#123; writer.append(line +&quot;\r\n&quot;) &#125;else if(index == lengths)&#123; writer.append(&quot;\r\n&quot; + sw.toString()+&quot;\r\n&quot;) writer.append(lines.get(lengths)) &#125; &#125; &#125; &#125; &#125;&#125;task readTask&#123; inputs.file destFile doLast&#123; def file = inputs.files.singleFile println file.text &#125;&#125;task taskTest&#123; dependsOn readTask,writerTask doLast&#123; println &quot;输入输出任务结束&quot; &#125;&#125; destFile作为writerTask输出结果输入到readTask 通过API指定执行顺序：mustRunAfter／shouldRunAfter 12task t1() &#123; doLast&#123;println &apos;task t1&apos;&#125; &#125;task t2() &#123; mustRunAfter t1 doLast &#123;println &apos;task t2&apos;&#125; &#125; 通过./gradlew t2 t1查看执行结果 4. Task类型 详见官方文档：https://docs.gradle.org/current/dsl/org.gradle.api.tasks.Delete.html#org.gradle.api.tasks.Delete 5. 构建到生命周期 12345678this.project.afterEvaluate &#123;project -&gt; println &quot;开始挂接...&quot; def buildTask = project.tasks.getByName(&quot;build&quot;) if(buildTask == null) throw GradleException(&quot;build Task not found&quot;) buildTask.doLast &#123; writerTask.execute() &#125;&#125; Gradle其他模块 Settings类：对应Settings.gradle 123if(hasProperty(&apos;isLoadTest&apos;)? isLoadTest.toBoolean() : false)&#123; include &apos;:Test&apos;&#125; SourceSet类:AndroidSourceSet/JavaSourceSet,决定了代码、资源、第三方库要存放的位置 123456789//修改.so等jnilibs的存放位置android&#123; sourceSets &#123; main&#123; jniLibs.srcDirs = [&apos;libs&apos;] res.srcDirs = [&apos;src/main/res&apos;,&apos;src/main/res-ad&apos;] //对res文件夹内容进行分类，但是只能在Project视图查看到效果 &#125; &#125;&#125; Gradle的Plugin Gradle没有提供创建自定义Gradle插件工程的模板，需要开发者手动创建Gradle插件工程 使用Groovy开发，其Gradle插件工程必须遵循如下的目录结构： groovy代码必须位于xxxProject/src/main/groovy/目录下 提供插件属性声明文件，该文件必须位于xxxProject/src/main/resources/META-INF/gradle-plugins/xxx.properties android插件对gradle的扩展 android具体能配置那些属性，可查看源码通过BaseExtension查看 gradle插件： https://avatarqing.gitbooks.io/gradlepluginuserguidechineseverision/content/introduction/README.html varints变体]]></content>
      <tags>
        <tag>andrioid</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于]]></title>
    <url>%2Fabout%2Findex.html</url>
    <content type="text"><![CDATA[关于我]]></content>
  </entry>
  <entry>
    <title><![CDATA[归档]]></title>
    <url>%2Farchives%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[schedule]]></title>
    <url>%2Fschedule%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[分类]]></title>
    <url>%2Fcategories%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[标签]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
</search>
