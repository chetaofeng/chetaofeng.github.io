<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">

<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<style>
    .pace .pace-progress {
        background: #1E92FB; /*进度条颜色*/
        height: 3px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #1E92FB, 0 0 5px     #1E92FB; /*阴影颜色*/
    }
    .pace .pace-activity {
        border-top-color: #1E92FB;    /*上边框颜色*/
        border-left-color: #1E92FB;    /*左边框颜色*/
    }
</style>

<script>
    (function(){
        if(''){
            if (prompt('请输入文章密码') !== ''){
                alert('密码错误！');
                history.back();
            }
        }
    })();
</script>








<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="行锋的技术博客">
<meta property="og:type" content="website">
<meta property="og:title" content="行锋">
<meta property="og:url" content="https://chetaofeng.github.io/page/8/index.html">
<meta property="og:site_name" content="行锋">
<meta property="og:description" content="行锋的技术博客">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="行锋">
<meta name="twitter:description" content="行锋的技术博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://chetaofeng.github.io/page/8/"/>





  <title>行锋</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <a href="https://github.com/chetaofeng"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_green_007200.png" alt="Fork me on GitHub"></a>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">行锋</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">低头走路，抬头思考</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://chetaofeng.github.io/2018/10/26/前端开发-异步编程及Async模块的使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="行锋">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/pub-images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="行锋">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/26/前端开发-异步编程及Async模块的使用/" itemprop="url">异步编程及Async模块的使用</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-26T16:04:30+08:00">
                2018-10-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[toc]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">汇智网-异步编程：http://cw.hubwiz.com/card/c/543e1a4f032c7816c0d5dfa1/1/3/6/</span><br></pre></td></tr></table></figure>
<h1 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h1>
<blockquote>
<p>github网址：<a href="https://github.com/caolan/async" target="_blank" rel="noopener">https://github.com/caolan/async</a></p>
</blockquote>
<ul>
<li>异步编程是指由于异步I/O等因素，无法同步获得执行结果时，在回调函数中进行下一步操作的代码编写风格,常见的如setTimeout函数、ajax请求等等</li>
<li>使用Asycn模块需要安装，它不是node自带的</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">安装：npm install async </span><br><span class="line">引用：var async = require(&apos;async&apos;);</span><br></pre></td></tr></table></figure>
<ul>
<li>异常捕获：异步I/O的实现主要有两个阶段，①提交请求；②处理结果； 这两个阶段彼此不关联，而异常并不一定发生在请求提交（即调用函数）时，平常的try/catch并不能有效的捕捉到程序的异常</li>
</ul>
<h1 id="函数式编程"><a class="markdownIt-Anchor" href="#函数式编程"></a> 函数式编程</h1>
<h2 id="高阶函数"><a class="markdownIt-Anchor" href="#高阶函数"></a> 高阶函数</h2>
<ul>
<li>高阶函数与普通函数不同的地方是高阶函数可以把函数作为参数，或者是将函数作为返回值</li>
<li>函数作为参数；函数作为返回值；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//高阶函数test的返回值是一个匿名函数</span><br><span class="line">function test(v)&#123;</span><br><span class="line">  return function()&#123;</span><br><span class="line">    return v;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="偏函数"><a class="markdownIt-Anchor" href="#偏函数"></a> 偏函数</h2>
<ul>
<li>一个创建函数的工厂函数；通过指定部分参数，定制新的函数</li>
<li>假设有一个参数或变量已经预置的函数A，我们通过调用A来产生一个新的函数B，函数B就是我们说的偏函数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//isType函数中预置了判断类型的方法，只指定部分参数来产生的新的定制的函数isString和isFunction就是偏函数</span><br><span class="line">var isType = function(type)&#123;</span><br><span class="line">  return function(obj)&#123;</span><br><span class="line">    return toString.call(obj)==&apos;[object &apos;+type+&apos;]&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var isString = isType(&apos;String&apos;);</span><br><span class="line">var isFunction = isType(&apos;Function&apos;);</span><br></pre></td></tr></table></figure>
<p>编写偏函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var say =function(name)&#123;</span><br><span class="line">    return function(text)&#123;</span><br><span class="line">        console.log(name+&apos; say &apos;+text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var tomSay = say(&apos;tom&apos;);</span><br><span class="line"></span><br><span class="line">tomSay (&apos;hello&apos;);</span><br></pre></td></tr></table></figure>
<h1 id="方法说明"><a class="markdownIt-Anchor" href="#方法说明"></a> 方法说明</h1>
<h2 id="series"><a class="markdownIt-Anchor" href="#series"></a> series</h2>
<blockquote>
<p>它是控制异步函数按照串行顺序执行，只有前一个执行完毕，才能执行下一个异步调用</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">async.series([function(cb)&#123;</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">        cb(null,1);</span><br><span class="line">    &#125;,1000)</span><br><span class="line">&#125;,function(cb)&#123;</span><br><span class="line">    setTimeout(cb,1000,null,2); </span><br><span class="line">&#125;],function(err,result)&#123;  //result是每个回调函数传进来的data参数，result=[1,2]</span><br><span class="line">    if (err) </span><br><span class="line">        console.error(err);</span><br><span class="line">    else </span><br><span class="line">        console.log(result);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="parallel"><a class="markdownIt-Anchor" href="#parallel"></a> parallel</h2>
<blockquote>
<p>parallel的用法和series类似。只是数组中的函数是并行执行，parallel的总时间取决于运行时间最长的函数。而最终的回调函数里result的值是按照数组中函数的顺序排列的</p>
</blockquote>
<h2 id="waterfall"><a class="markdownIt-Anchor" href="#waterfall"></a> waterfall</h2>
<blockquote>
<p>和series函数有很多相似之处，都是按照顺序执行。<br>
不同之处是waterfall每个函数产生的值，都将传给下一个函数，而series则没有这个功能</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">async.waterfall([function(cb)&#123;</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">        cb(null,1);</span><br><span class="line">    &#125;,1000)</span><br><span class="line">&#125;,function(data,cb)&#123;</span><br><span class="line">    setTimeout(cb,1000,null,data+&quot;+&quot;+&quot;2&quot;);</span><br><span class="line">&#125;],function(err,result)&#123;  //result = &quot;1+2&quot;</span><br><span class="line">    if (err) </span><br><span class="line">        console.error(err);</span><br><span class="line">    else </span><br><span class="line">        console.log(result);</span><br><span class="line">&#125;)</span><br><span class="line">~~~ </span><br><span class="line"></span><br><span class="line">## parallelLimit(tasks, limit, [callback])</span><br><span class="line">parallelLimit函数和parallel类似，但是它多了一个参数limit。 limit参数限制任务只能同时并发一定数量，而不是无限制并发</span><br><span class="line"></span><br><span class="line">## whilst(test, fn, callback)</span><br><span class="line">相当于while，但其中的异步调用将在完成后才会进行下一次循环;test参数是一个返回布尔值结果的函数，通过返回值来决定循环是否继续，作用等同于while循环停止的条件</span><br></pre></td></tr></table></figure>
<p>var count = 0;<br>
async.whilst(<br>
function () { return count &lt; 5; },<br>
function (callback) {<br>
count++;<br>
setTimeout(callback, 1000);<br>
},<br>
function (err) {</p>
<pre><code>}
</code></pre>
<p>);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## doWhilst(fn, test, callback)</span><br><span class="line">相当于do…while,较whilst而言，doWhilst交换了fn,test的参数位置，先执行一次循环，再做test判断</span><br><span class="line"></span><br><span class="line">## until(test, fn, callback)</span><br><span class="line">until与whilst正好相反，当test条件函数返回值为false时继续循环，与true时跳出。其它特性一致</span><br></pre></td></tr></table></figure>
<p>var count = 5;<br>
async.until(<br>
function () { return count &lt; 0; },<br>
function (callback) {<br>
count–;<br>
setTimeout(callback, 1000);<br>
},<br>
function (err) {</p>
<pre><code>}
</code></pre>
<p>);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## doUntil(fn, test, callback)</span><br><span class="line">doUntil与doWhilst正好相反，当test为false时循环，与true时跳出。其它特性一致</span><br><span class="line"></span><br><span class="line">## forever(fn, errback)</span><br><span class="line">forever函数比较特殊，它的功能是无论条件如何，函数都一直循环执行，只有出现程序执行的过程中出现错误时循环才会停止，callback才会被调用</span><br><span class="line"></span><br><span class="line">## compose(fn1, fn2...)</span><br><span class="line">使用compose可以创建一个异步函数的集合函数，将传入的多个异步函数包含在其中，当我们执行这个集合函数时，会依次执行每一个异步函数，每个函数会消费上一次函数的返回值</span><br><span class="line"></span><br><span class="line">==注意==：从内层到外层的执行的顺序；从右往左执行</span><br></pre></td></tr></table></figure>
<p>var async = require(‘async’);<br>
function fn1(n, callback) {<br>
setTimeout(function () {<br>
callback(null, n + 1);<br>
}, 1000);<br>
}<br>
function fn2(n, callback) {<br>
setTimeout(function () {<br>
callback(null, n * 3);<br>
}, 1000);<br>
}<br>
var demo = async.compose(fn2, fn1);<br>
demo(4, function (err, result) {<br>
console.log(result);            //结果15<br>
});<br>
demo = async.compose(fn1, fn2);<br>
demo(4, function (err, result) {<br>
console.log(result);            //结果13<br>
});</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## auto(tasks, [callback])</span><br><span class="line">* 用来处理有依赖关系的多个任务的执行</span><br><span class="line">* async.auto的强大是在于，你定义好相互之间的dependencies，他来帮你决定用parallel还是waterfull</span><br></pre></td></tr></table></figure>
<p>async.auto({<br>
getData: function(callback){<br>
callback(null, ‘data’, ‘converted to array’);<br>
},<br>
makeFolder: function(callback){<br>
callback(null, ‘folder’);<br>
},<br>
writeFile: [‘getData’, ‘makeFolder’, function(callback, results){<br>
callback(null, ‘filename’);<br>
}],<br>
emailLink: [‘writeFile’, function(callback, results){<br>
callback(null, {‘file’:results.writeFile, ‘email’:‘user@example.com’});<br>
}]<br>
}, function(err, results) {<br>
console.log('err = ', err);<br>
console.log('results = ', results);<br>
});</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## queue(worker, concurrency)</span><br><span class="line">queue相当于一个加强版的parallel，主要是限制了worker数量，不再一次性全部执行。当worker数量不够用时，新加入的任务将会排队等候，直到有新的worker可用</span><br><span class="line"></span><br><span class="line">## apply(function, arguments..)</span><br><span class="line">apply是一个非常好用的函数，可以让我们给一个函数预绑定多个参数并生成一个可直接调用的新函数，简化代码</span><br></pre></td></tr></table></figure>
<p>function(callback) {<br>
test(3, callback);<br>
};<br>
用apply改写：<br>
async.apply(test, 3);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## iterator(tasks)</span><br><span class="line">* 将一组函数包装成为一个iterator，可通过next()得到以下一个函数为起点的新的iterator。该函数通常由async在内部使用，但如果需要时，也可在我们的代码中使用它</span><br><span class="line">* 直接调用()，会执行当前函数，并返回一个由下个函数为起点的新的iterator。调用next()，不会执行当前函数，直接返回由下个函数为起点的新iterator</span><br><span class="line">* 对于同一个iterator，多次调用next()，不会影响自己。如果只剩下一个元素，调用next()会返回null</span><br></pre></td></tr></table></figure>
<p>var iter = async.iterator([<br>
function() { console.log(‘111’) },<br>
function() { console.log(‘222’) },<br>
function() { console.log(‘333’) }<br>
]);<br>
iter();</p>
<pre class="highlight"><code class=""></code></pre>

          
        
      
    </div>
    
    
    

    <div>
          
    </div>

    

    <div>
      
    </div>


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://chetaofeng.github.io/2018/10/26/node-Node-API学习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="行锋">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/pub-images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="行锋">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/26/node-Node-API学习/" itemprop="url">Node API学习</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-26T16:04:30+08:00">
                2018-10-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。<br>
Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。<br>
Node.js 的包管理器 npm，是全球最大的开源库生态系统。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">中文网址：http://nodejs.cn/</span><br><span class="line">英文网址：https://nodejs.org/en/</span><br><span class="line"></span><br><span class="line">其他相关网址：</span><br><span class="line">https://www.npmjs.com/</span><br><span class="line">https://github.com/</span><br></pre></td></tr></table></figure>
<p><a href="http://nodejs.cn/api/" target="_blank" rel="noopener">http://nodejs.cn/api/</a></p>
<hr>
<p>[toc]</p>
<h2 id="node命令用法"><a class="markdownIt-Anchor" href="#node命令用法"></a> node命令用法</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node [options] [v8 options] [script.js | -e &quot;script&quot;] [arguments]</span><br></pre></td></tr></table></figure>
<h2 id="assert-断言"><a class="markdownIt-Anchor" href="#assert-断言"></a> assert (断言)</h2>
<blockquote>
<p>assert 模块提供了一组简单的断言测试集合，可被用于测试不变量。 该模块在代码中可通过 require(‘assert’) 使用。 assert 不是一个测试框架，也无意成为通用的断言库。</p>
</blockquote>
<h2 id="buffer"><a class="markdownIt-Anchor" href="#buffer"></a> Buffer</h2>
<blockquote>
<p>在 ECMAScript 2015 (ES6) 引入 TypedArray 之前，JavaScript 语言没有读取或操作二进制数据流的机制。 Buffer 类被引入作为 Node.js API 的一部分，使其可以在 TCP 流和文件系统操作等场景中处理二进制数据流。</p>
</blockquote>
<blockquote>
<p>现在 TypedArray 已经被添加进 ES6 中，Buffer 类以一种更优与更适合 Node.js 用例的方式实现了 Uint8Array API。</p>
</blockquote>
<blockquote>
<p>Buffer 类的实例类似于整数数组，除了其是大小固定的、且在 V8 堆外分配物理内存。 ==Buffer 的大小在其创建时就已确定，且不能调整大小==。</p>
</blockquote>
<blockquote>
<p>Buffer 类在 Node.js 中是一个全局变量，因此无需 require(‘buffer’).Buffer。</p>
</blockquote>
<h2 id="cc-插件"><a class="markdownIt-Anchor" href="#cc-插件"></a> C/C++ 插件</h2>
<blockquote>
<p>Node.js 插件是用 C 或 C++ 编写的动态链接共享对象，可以使用 require() 函数加载到 Node.js 中，且像普通的 Node.js 模块一样被使用。 它们主要用于为运行于 Node.js 的 JavaScript 和 C/C++ 库之间提供接口。</p>
</blockquote>
<ul>
<li>V8：Node.js 当前用于提供 JavaScript 实现的 C++ 库。 V8 提供了用于创建对象、调用函数等机制。 V8 的 API 文档主要在 v8.h 头文件中（Node.js 源代码中的 deps/v8/include/v8.h）==(V8在线文档) <a href="https://v8docs.nodesource.com/==" target="_blank" rel="noopener">https://v8docs.nodesource.com/==</a></li>
<li>libuv：实现了 Node.js 的事件循环、工作线程、与平台所有的的异步操作的 C 库。 它也是一个跨平台的抽象库，使所有主流操作系统中可以像 POSIX 一样访问常用的系统任务，比如与文件系统、socket、定时器和系统事件的交互。 libuv 还提供了一个类似 POSIX 多线程的线程抽象，可被用于强化更复杂的需要超越标准事件循环的异步插件。 鼓励插件开发者多思考如何通过在 libuv 的非阻塞系统操作、工作线程、或自定义的 libuv 线程中降低工作负载来避免在 I/O 或其他时间密集型任务中阻塞事件循环。</li>
<li>内置的 Node.js 库。Node.js 自身开放了一些插件可以使用的 C/C++ API。 其中最重要的是 node::ObjectWrap 类。</li>
<li>Node.js 包含一些其他的静态链接库，如 OpenSSL。 这些库位于 Node.js 源代码中的 deps/ 目录。 只有 V8 和 OpenSSL 符号是被 Node.js 有目的地再导出，并且通过插件被用于不同的场景</li>
</ul>
<h2 id="child_process-子进程"><a class="markdownIt-Anchor" href="#child_process-子进程"></a> child_process (子进程)</h2>
<blockquote>
<p>child_process 模块提供了衍生子进程的能力</p>
</blockquote>
<h2 id="cluster"><a class="markdownIt-Anchor" href="#cluster"></a> Cluster</h2>
<h2 id="cli命令行选项"><a class="markdownIt-Anchor" href="#cli命令行选项"></a> CLI(命令行选项)</h2>
<blockquote>
<p>Node.js 自带了各种命令行选项。 这些选项对外暴露了内置调试、多种执行脚本的方式、以及其他有用的运行时选项。</p>
</blockquote>
<blockquote>
<p>要在终端中查看本文档作为操作手册，运行 man node</p>
</blockquote>
<h2 id="console-控制台"><a class="markdownIt-Anchor" href="#console-控制台"></a> console (控制台)</h2>
<blockquote>
<p>console 模块提供了一个简单的调试控制台，它与 Web 浏览器提供的 JavaScript 控制台的机制类似。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.time(label) //启动一个定时器，用以计算一个操作的持续时间。 定时器由一个唯一的 label 标识。 当调用 console.timeEnd() 时，可以使用相同的 label 来停止定时器，并以毫秒为单位将持续时间输出到 stdout。 定时器持续时间精确到亚毫秒。</span><br><span class="line">console.timeEnd(label)  //停止之前通过调用 console.time() 启动的定时器，并打印结果到 stdout</span><br><span class="line">console.trace(message[, ...args])   //打印字符串 &apos;Trace :&apos; 到 stderr ，并通过 util.format() 格式化消息与堆栈跟踪在代码中的当前位置。</span><br></pre></td></tr></table></figure>
<h2 id="crypto-加密"><a class="markdownIt-Anchor" href="#crypto-加密"></a> Crypto (加密)</h2>
<h2 id="debugger-调试器"><a class="markdownIt-Anchor" href="#debugger-调试器"></a> debugger (调试器)</h2>
<blockquote>
<p>Node.js 包含一个进程外的调试工具，可以通过基于 TCP 的协议和内置调试客户端访问。 要使用它，可以带上 debug 参数启动 Node.js，并带上需要调试的脚本的路径；然后会显示一个提示，表明成功启动调试器</p>
</blockquote>
<h2 id="dns-域名服务器"><a class="markdownIt-Anchor" href="#dns-域名服务器"></a> DNS (域名服务器)</h2>
<h2 id="error-错误"><a class="markdownIt-Anchor" href="#error-错误"></a> Error 错误</h2>
<p>Node.js 中运行的应用程序一般会遇到以下四类错误：</p>
<ul>
<li>标准的 JavaScript 错误：
<ol>
<li><evalerror> : 当调用 eval() 失败时抛出。</evalerror></li>
<li><syntaxerror> : 当 JavaScript 语法错误时抛出。</syntaxerror></li>
<li><rangeerror> : 当一个值不在预期范围内时抛出。</rangeerror></li>
<li><referenceerror> : 当使用未定义的变量时抛出。</referenceerror></li>
<li><typeerror> : 当传入错误类型的参数时抛出。</typeerror></li>
<li><urierror> : 当一个全局的 URI 处理函数被误用时抛出。</urierror></li>
</ol>
</li>
<li>由底层操作系的触发的系统错误，例如试图打开一个不存在的文件、试图向一个已关闭的 socket 发送数据等</li>
<li>由应用程序代码触发的用户自定义的错误。</li>
<li>断言错误是错误的一个特殊的类，每当 Node.js 检测到一个不应该发生的异常逻辑时会触发。 这类错误通常由 assert 模块触发。</li>
</ul>
<blockquote>
<p>JavaScript 的 throw 机制的任何使用都会引起异常，异常必须使用 try / catch 处理，否则 Node.js 进程会立即退出。</p>
</blockquote>
<blockquote>
<p>==开发者必须查阅各个方法的文档以明确在错误发生时这些方法是如何冒泡的。==</p>
</blockquote>
<h2 id="events-事件"><a class="markdownIt-Anchor" href="#events-事件"></a> events (事件)</h2>
<blockquote>
<p>大多数 Node.js 核心 API 都是采用惯用的异步事件驱动架构，其中某些类型的对象（称为触发器）会周期性地触发命名事件来调用函数对象（监听器）。</p>
</blockquote>
<blockquote>
<p>==所有能触发事件的对象都是 EventEmitter 类的实例==。 这些对象开放了一个 eventEmitter.on() 函数，允许将一个或多个函数附加到会被对象触发的命名事件上。==当 EventEmitter 对象触发一个事件时，所有附加在特定事件上的函数都被同步地调用。==</p>
</blockquote>
<blockquote>
<p>当新的监听器被添加时，所有的 EventEmitter 会触发 ‘newListener’ 事件；当移除已存在的监听器时，则触发 ‘removeListener’。</p>
</blockquote>
<blockquote>
<p>每个事件默认可以注册最多 10 个监听器。可以通过一定方法设置。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此方法可用来自定义事件</span></span><br><span class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyEmitter</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> myEmitter = <span class="keyword">new</span> MyEmitter();</span><br><span class="line">myEmitter.on(<span class="string">'event'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'发生了一个事件！'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">myEmitter.emit(<span class="string">'event'</span>);</span><br></pre></td></tr></table></figure>
<h4 id="异步与同步"><a class="markdownIt-Anchor" href="#异步与同步"></a> 异步与同步</h4>
<blockquote>
<p>EventListener 会按照监听器注册的顺序同步地调用所有监听器。 所以需要确保事件的正确排序且避免竞争条件或逻辑错误。监听器函数可以使用 setImmediate() 或 process.nextTick() 方法切换到异步操作模式.</p>
</blockquote>
<ul>
<li>eventEmitter.on() //监听器会在==每次==触发命名事件时被调用</li>
<li>eventEmitter.once() //注册一个对于特定事件被调用==最多一次==的监听器</li>
</ul>
<h4 id="错误事件"><a class="markdownIt-Anchor" href="#错误事件"></a> 错误事件</h4>
<blockquote>
<p>当 EventEmitter 实例中发生错误时，会触发一个 ‘error’ 事件.为了防止 Node.js 进程崩溃，可以在 process 对象的 uncaughtException 事件上注册监听器</p>
</blockquote>
<h2 id="fs-文件系统"><a class="markdownIt-Anchor" href="#fs-文件系统"></a> fs (文件系统)</h2>
<blockquote>
<p>文件 I/O 是由简单封装的标准 POSIX 函数提供的。 通过 require(‘fs’) 使用该模块。 ==所有的方法都有异步和同步的形式==</p>
</blockquote>
<blockquote>
<p>异步形式始终以完成==回调作为它最后一个参数==。 传给完成回调的参数取决于具体方法，但==第一个参数总是留给异常==。 如果操作成功完成，则第一个参数会是 null 或 undefined。</p>
</blockquote>
<blockquote>
<p>当使用同步形式时，任何异常都会被立即抛出。 可以使用 try/catch 来处理异常，或让它们往上冒泡。</p>
</blockquote>
<h4 id="同步和异步的比较"><a class="markdownIt-Anchor" href="#同步和异步的比较"></a> 同步和异步的比较</h4>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//同步的方式</span><br><span class="line">const fs = require(&apos;fs&apos;); </span><br><span class="line">fs.unlinkSync(&apos;/tmp/hello&apos;);</span><br><span class="line">console.log(&apos;successfully deleted /tmp/hello&apos;);</span><br><span class="line"></span><br><span class="line">//异步方式</span><br><span class="line">const fs = require(&apos;fs&apos;); </span><br><span class="line">fs.unlink(&apos;/tmp/hello&apos;, (err) =&gt; &#123;</span><br><span class="line">  if (err) throw err;</span><br><span class="line">  console.log(&apos;successfully deleted /tmp/hello&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>异步方法不保证执行顺序</li>
<li>异步方法之间如果有执行顺序，则正确的方法是把回调链起来</li>
<li>强烈推荐开发者使用这些函数的异步版本。 同步版本会阻塞整个进程，直到它们完成</li>
</ul>
<h2 id="全局变量"><a class="markdownIt-Anchor" href="#全局变量"></a> 全局变量</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* __dirname     //当前模块的目录名。 等同于 __filename 的 path.dirname()</span><br><span class="line">* __filename    //当前模块的文件名。 这是当前模块文件的解析后的绝对路径</span><br><span class="line">* exports       //module.exports 的一个简短的引用</span><br><span class="line">* module        //当前模块的引用。 具体地说，module.exports 用于定义一个模块导出什么，且通过 require() 引入</span><br><span class="line">* require.resolve() //使用内部的 require() 机制来查找模块的位置，但不会加载模块，只返回解析后的文件名</span><br></pre></td></tr></table></figure>
<h2 id="http"><a class="markdownIt-Anchor" href="#http"></a> http</h2>
<blockquote>
<p>Node.js 中的 HTTP 接口被设计为支持以往较难使用的协议的许多特性。 比如，大块编码的消息。 该接口从不缓存整个请求或响应，所以用户能够流化数据。</p>
</blockquote>
<h2 id="https"><a class="markdownIt-Anchor" href="#https"></a> https</h2>
<blockquote>
<p>HTTPS 是 HTTP 基于 TLS/SSL 的版本。在 Node.js 中，它被实现为一个独立的模块。</p>
</blockquote>
<h2 id="module-模块"><a class="markdownIt-Anchor" href="#module-模块"></a> module (模块)</h2>
<blockquote>
<p>Node.js 有一个简单的模块加载系统。 在 Node.js 中，文件和模块是一一对应的（每个文件被视为一个独立的模块）</p>
</blockquote>

          
        
      
    </div>
    
    
    

    <div>
          
    </div>

    

    <div>
      
    </div>


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://chetaofeng.github.io/2018/10/26/node-NodeJS快速入门/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="行锋">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/pub-images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="行锋">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/26/node-NodeJS快速入门/" itemprop="url">NodeJS快速入门</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-26T16:04:30+08:00">
                2018-10-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://cw.hubwiz.com/card/c/5359f6f6ec7452081a7873d8/1/1/2/" target="_blank" rel="noopener">http://cw.hubwiz.com/card/c/5359f6f6ec7452081a7873d8/1/1/2/</a></p>
<p>[toc]</p>
<h2 id="node中标准回调函数"><a class="markdownIt-Anchor" href="#node中标准回调函数"></a> Node中标准回调函数</h2>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">第一个参数为err是错误信息</span><br><span class="line">第二个参数为data是返回的数据</span><br></pre></td></tr></table></figure>
<h2 id="进程管理"><a class="markdownIt-Anchor" href="#进程管理"></a> 进程管理</h2>
<blockquote>
<p>process是一个全局内置对象，可以在代码中的任何位置访问此对象，这个对象代表我们的node.js代码宿主的操作系统进程对象。</p>
</blockquote>
<blockquote>
<p>使用process对象可以截获进程的异常、退出等事件，也可以获取进程的当前目录、环境变量、内存占用等信息，还可以执行进程退出、工作目录切换等操作。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">* process.cwd();            //查看应用程序当前目录</span><br><span class="line">* process.chdir(&quot;目录&quot;);    //改变应用程序目录</span><br><span class="line">* stdout是标准输出流,作用就是将内容打印到输出设备上</span><br><span class="line">    console.log = function(d)&#123;</span><br><span class="line">        process.stdout.write(d+&apos;\n&apos;);</span><br><span class="line">    &#125; </span><br><span class="line">* stderr是标准错误流,用来打印错误信息,可以通过它来捕获错误信息     //process.stderr.write(输入内容);</span><br><span class="line">* stdin是进程的输入流,我们可以通过注册事件的方式来获取输入的内容</span><br><span class="line">    process.stdin.on(&apos;readable&apos;, function() &#123;</span><br><span class="line">      var chunk = process.stdin.read();</span><br><span class="line">      if (chunk !== null) &#123;</span><br><span class="line">        process.stdout.write(&apos;data: &apos; + chunk);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">* process.exit(code);   //需要在程序内杀死进程，退出程序时使用，参数code为退出后返回的代码，如果省略则默认返回0；</span><br><span class="line">* process.on()；        //此方法可监听进程事件</span><br><span class="line">  exit事件：//当进程要退出之前，会触发exit事件。通过监听exit事件，我们可就以在进程退出前进行一些清理工作： </span><br><span class="line">        process.on(&quot;exit&quot;,function(code)&#123;//参数code表示退出码 </span><br><span class="line">          console.log(&quot;I am tired...&quot;)//进行一些清理工作</span><br><span class="line">        &#125;); </span><br><span class="line">    uncaughtException事件:  //如果进程发生了未捕捉的异常，会触发uncaughtException事件。通过监听这个事件，可以 让进程优雅的退出</span><br><span class="line">        process.on(&quot;uncaughtException&quot;,function(err)&#123;</span><br><span class="line">            console.log(err);</span><br><span class="line">        &#125;);</span><br><span class="line">        throw new Error(&quot;我故意的...&quot;); //故意抛出一个异常</span><br><span class="line">* 设置编码</span><br><span class="line">  process.stdin.setEncoding(编码);</span><br><span class="line">  process.stdout.setEncoding(编码);</span><br><span class="line">  process.stderr.setEncoding(编码);</span><br></pre></td></tr></table></figure>
<h2 id="子进程"><a class="markdownIt-Anchor" href="#子进程"></a> 子进程</h2>
<blockquote>
<p>==node.js是基于单线程模型架构==，这样的设计可以带来高效的CPU利用率，但是无法却利用多个核心的CPU，为了解决这个问题，node.js提供了==child_process模块，通过多进程来实现对多核CPU的利用==</p>
</blockquote>
<blockquote>
<p>child_process模块提供了四个创建子进程的函数，分别是spawn，exec，execFile和fork。</p>
</blockquote>
<ol>
<li>spawn函数用给定的命令发布一个子进程，只能运行指定的程序，参数需要在列表中给出</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var child_process = require(&apos;child_process&apos;);</span><br><span class="line">var child = child_process.spawn( command );</span><br><span class="line">child.stdout.on(&apos;data&apos;, function(data) &#123;</span><br><span class="line">  console.log(data);</span><br><span class="line">&#125;);</span><br><span class="line">通过执行命令得到返回结果</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>exec也是一个创建子进程的函数，与spawn函数不同它可以直接接受一个回调函数作为参数</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var child_process = require(&apos;child_process&apos;);</span><br><span class="line">child_process.exec( command , function(err, stdout , stderr ) &#123;</span><br><span class="line">  console.log( stdout );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>execFile函数与exec函数类似，但execFile函数更显得精简，因为它可以直接执行所指定的文件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var child_process = require(&apos;child_process&apos;);</span><br><span class="line">child_process.execFile( file , function(err, stdout , stderr ) &#123;</span><br><span class="line">  console.log( stdout );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>==fork函数可直接运行Node.js模块==，所以我们可以直接通过指定模块路径而直接进行操作.==该方法是spawn()的特殊情景，用于派生Node进程==</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var child_process = require(&apos;child_process&apos;);</span><br><span class="line">child_process.fork( modulePath );</span><br></pre></td></tr></table></figure>
<h2 id="文件io"><a class="markdownIt-Anchor" href="#文件io"></a> 文件I/O</h2>
<blockquote>
<p>node.js中提供一个名为fs的模块来支持I/O操作，fs模块的文件I/O是对标准POSIX函数的简单封装。</p>
</blockquote>
<blockquote>
<p>fs模块不但提供异步的文件操作，还提供相应的同步操作方法，需要指出的是，nodejs采用异步I/O正是为了避免I/O时的等待时间，提高CPU的利用率，所以在选择使用异步或同步方法的时候需要权衡取舍。</p>
</blockquote>
<hr>
<ul>
<li>fs.writeFile(filename, data, callback)</li>
</ul>
<blockquote>
<p>异步的将数据写入一个文件<br>
如果文件已经存在则会被替换;数据参数可以是string或者是Buffer,编码格式参数可选，默认为&quot;utf8&quot;</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var fs= require(&quot;fs&quot;); </span><br><span class="line">fs.writeFile(&apos;test.txt&apos;, &apos;Hello Node&apos;, function (err) &#123;</span><br><span class="line">   if (err) throw err;</span><br><span class="line">   console.log(&apos;Saved successfully&apos;); //文件被保存</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>fs.appendFile(文件名,数据,编码,回调函数(err));</li>
</ul>
<blockquote>
<p>将新的内容追加到已有的文件中，如果文件不存在，则会创建一个新的文件;编码格式默认为&quot;utf8&quot;</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var fs= require(&quot;fs&quot;); </span><br><span class="line">fs.appendFile(&apos;test.txt&apos;, &apos;data to append&apos;, function (err) &#123;</span><br><span class="line">   if (err) throw err;  </span><br><span class="line">    console.log(&apos;The &quot;data to append&quot; was appended to file!&apos;); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>fs.exists(文件，回调函数(exists));    //exists的回调函数只有一个参数，类型为布尔型，通过它来表示文件是否存在</li>
<li>fs.rename(旧文件，新文件，回调函数(err)); ==//修改文件名称==</li>
<li>fs.rename(oldPath,newPath,function (err); ==//移动文件==</li>
<li>fs.readFile(文件,[编码],回调函数);    //读取文件内容</li>
<li>fs.unlink(文件,回调函数(err)); ==//删除文件==</li>
<li>fs.mkdir(路径，权限，回调函数(err)); //创建目录；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">权限：默认为0777，表示文件所有者、文件所有者所在的组的用户、所有用户，都有权限进行读、写、执行的操作</span><br></pre></td></tr></table></figure>
<ul>
<li>fs.rmdir(路径，回调函数(err)); //删除目录</li>
<li>fs.readdir(目录,回调函数(err,files));//读取目录下所有的文件</li>
</ul>
<h2 id="url处理"><a class="markdownIt-Anchor" href="#url处理"></a> url处理</h2>
<blockquote>
<p>node.js为互联网而生，和url打交道是无法避免的了，url模块提供一些基础的url处理。</p>
</blockquote>
<ul>
<li>url.parse(‘<a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a>’);    //解析url，返回一个json格式的数组</li>
<li>url.parse(‘<a href="http://www.baidu.com?page=1" target="_blank" rel="noopener">http://www.baidu.com?page=1</a>’,true);//当==第二个==参数为true时，会将查询条件也解析成json格式的对象。</li>
<li>url.parse(‘<a href="http://www.baidu.com/news" target="_blank" rel="noopener">http://www.baidu.com/news</a>’,false,true);当==第三个==参数为true，解析时会将url的&quot;//“和第一个”/&quot;之间的部分解析为主机名</li>
<li>url.format({<br>
protocol: ‘http:’,<br>
hostname:‘<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a>’,<br>
port:‘80’,<br>
pathname :’/news’,<br>
query:{page:1}<br>
}<br>
);<br>
==<strong>作用与parse相反，它的参数是一个JSON对象，返回一个组装好的url地址</strong>==</li>
<li>url.resolve(‘<a href="http://example.com/two" target="_blank" rel="noopener">http://example.com/two</a>’, ‘/one’)；//组装路径，第一个路径是开始的路径或者说当前路径，第二个则是想要去往的路径。==结果：==‘<a href="http://example.com/one" target="_blank" rel="noopener">http://example.com/one</a>’</li>
</ul>
<h2 id="path优化"><a class="markdownIt-Anchor" href="#path优化"></a> path优化</h2>
<blockquote>
<p>本模块包含一套用于处理和转换文件路径的工具集,用于处理目录的对象，提高用户开发效率</p>
</blockquote>
<ul>
<li>path.normalize(’/path///normalize/hi/…’);//将不符合规范的路径经过格式化转换为标准路径,解析路径中的.与…外，还能去掉多余的斜杠</li>
<li>path.join(’///you’, ‘/are’, ‘//beautiful’);//结果：’/you/are/beautiful’。join函数将传入的多个路径拼接为标准路径并将其格式化，返回规范后的路径，避免手工拼接路径字符串的繁琐</li>
<li>path.dirname(’/foo/strong/cool/nice’); //用来返回路径中的目录名</li>
<li>basename函数可返回路径中的最后一部分，并且可以对其进行条件排除.</li>
</ul>
<ol>
<li>path.basename(‘路径字符串’);</li>
<li>path.basename(‘路径字符串’, ‘[ext]’)&lt;排除[ext]后缀字符串&gt;;</li>
</ol>
<ul>
<li>path.extname(‘index.html’); //返回路径中文件的扩展名</li>
</ul>
<h2 id="字符串转换"><a class="markdownIt-Anchor" href="#字符串转换"></a> 字符串转换</h2>
<blockquote>
<p>Query String模块用于==实现URL参数字符串与参数对象之间的互相转换==，提供了&quot;stringify&quot;、&quot;parse&quot;等一些实用函数来针对字符串进行处理，通过序列化和反序列化，来更好的应对实际开发中的条件需求，对于逻辑的处理也提供了很好的帮助</p>
</blockquote>
<h3 id="序列化"><a class="markdownIt-Anchor" href="#序列化"></a> 序列化</h3>
<hr>
<ul>
<li>querystring.stringify({foo:‘bar’,cool:[‘xux’, ‘yys’]}); //结果：foo=bar&amp;cool=xux&amp;cool=yys。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">作用就是序列化对象，也就是说将对象类型转换成一个字符串类型（默认的分割符（&quot;&amp;&quot;）和分配符（&quot;=&quot;））</span><br></pre></td></tr></table></figure>
<ul>
<li>querystring.stringify(“对象”，“分隔符”，“分配符”)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">querystring.stringify(&#123;foo:&apos;bar&apos;,cool:[&apos;xux&apos;, &apos;yys&apos;]&#125;,&apos;*&apos;,&apos;$&apos;);</span><br><span class="line">结果：&apos;foo$bar*cool$xux*cool$yys&apos;</span><br></pre></td></tr></table></figure>
<h3 id="反序列化"><a class="markdownIt-Anchor" href="#反序列化"></a> 反序列化</h3>
<hr>
<ul>
<li>querystring.parse(‘foo=bar&amp;cool=xux&amp;cool=yys’);</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">运行结果：&#123; foo: &apos;bar&apos;, cool: [&apos;xux&apos;, &apos;yys&apos;]&#125;</span><br><span class="line">parse函数的作用就是反序列化字符串（默认是由&quot;=&quot;、&quot;&amp;&quot;拼接而成），转换得到一个对象类型</span><br></pre></td></tr></table></figure>
<ul>
<li>querystring.parse(‘foo@bar<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>o</mi><mi>o</mi><mi>l</mi><mi mathvariant="normal">@</mi><mi>x</mi><mi>u</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">cool@xux</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord">@</span><span class="mord mathdefault">x</span><span class="mord mathdefault">u</span><span class="mord mathdefault">x</span></span></span></span>cool@yys’,’@’,’$’);</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">运行结果：&#123; foo: &apos;&apos;, bar: &apos;cool&apos;, xux: &apos;cool&apos;, yys: &apos;&apos; &#125;</span><br></pre></td></tr></table></figure>
<h2 id="实用工具"><a class="markdownIt-Anchor" href="#实用工具"></a> 实用工具</h2>
<blockquote>
<p>util模块。util模块呢，是一个Node.js核心模块，提供常用函数的集合，用于弥补核心JavaScript的一些功能过于精简的不足。并且还提供了一系列常用工具，用来对数据的输出和验证</p>
</blockquote>
<ul>
<li>util.inspect(object,[showHidden],[depth],[colors])； //将任意对象转换为字符串的函数，通常用于调试和错误输出</li>
<li>format函数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 如果占位符没有相对应的参数，占位符将不会被替换</span><br><span class="line">2. 如果有多个参数占位符，额外的参数将会调用util.inspect()转换为字符串。这些字符串被连接在一起，并且以空格分隔</span><br><span class="line">3. 如果第一个参数是一个非格式化字符串，则会把所有的参数转成字符串并以空格隔开拼接在一块，而且返回该字符串</span><br></pre></td></tr></table></figure>
<ul>
<li>util.isArray(object);  //判断对象是否为数组类型，是则返回ture,否则为fals</li>
<li>util.isDate(object); //判断对象是否为日期类型，是则返回ture,否则返回false</li>
<li>util.isRegExp(object); //判断对象是否为正则类型，是则返回ture,否则返回false</li>
</ul>

          
        
      
    </div>
    
    
    

    <div>
          
    </div>

    

    <div>
      
    </div>


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://chetaofeng.github.io/2018/10/26/前端开发-Express入门/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="行锋">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/pub-images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="行锋">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/26/前端开发-Express入门/" itemprop="url">Express入门</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-26T16:04:30+08:00">
                2018-10-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">中文网站：http://www.expressjs.com.cn/</span><br></pre></td></tr></table></figure>
<h1 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h1>
<ul>
<li>方法1:命令行模式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 确定已安装nodejs</span><br><span class="line">2. mkdir 项目名称；cd 项目名称</span><br><span class="line">3. npm init     //为应用创建一个 package.json 文件,然后根据提示操作或者一路回车</span><br><span class="line">4. npm install express --save   //安装 Express 并将其保存到依赖列表中</span><br><span class="line">5. 新建index.js文件进行编写</span><br></pre></td></tr></table></figure>
<ul>
<li>方法2:webstorm</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. npm install express -g //全局安装express</span><br><span class="line">2. webstorm中选择Node.js Expresss App,然后创建</span><br></pre></td></tr></table></figure>
<ul>
<li>方法3:Express 应用生成器</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 安装生成器：npm install express-generator -g</span><br><span class="line">2. 查看express 命令的用法：express -h</span><br><span class="line">3. 创建项目：express 项目名称</span><br><span class="line">4. 安装依赖：npm install</span><br></pre></td></tr></table></figure>
<ul>
<li>运行：node index.js</li>
<li>访问： <a href="http://localhost:3000/" target="_blank" rel="noopener">http://localhost:3000/</a></li>
</ul>
<h1 id="静态文件"><a class="markdownIt-Anchor" href="#静态文件"></a> 静态文件</h1>
<ul>
<li>通过 Express 内置的 express.static 可以方便地托管静态文件，例如图片、CSS、JavaScript 文件等</li>
<li>将静态资源文件所在的目录作为参数传递给 express.static 中间件就可以提供静态资源文件的访问了，如：app.use(express.static(‘public’))，这样public下面的文件就可以直接访问了，如：<a href="http://localhost:3000/images/kitten.jpg" target="_blank" rel="noopener">http://localhost:3000/images/kitten.jpg</a></li>
<li>通过为静态资源目录指定一个挂载路径的方式来实现访问的文件都存放在一个“虚拟（virtual）”目录（即目录根本不存在），如：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* app.use(&apos;/static&apos;, express.static(&apos;public&apos;));</span><br><span class="line">* 访问：http://localhost:3000/static/images/kitten.jpg</span><br></pre></td></tr></table></figure>
<h1 id="常见问题"><a class="markdownIt-Anchor" href="#常见问题"></a> 常见问题</h1>
<ol>
<li>如何处理 404</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Express 执行了所有中间件、路由之后还是没有获取到任何输出。你所需要做的就是在其所有他中间件的后面添加一个处理 404 的中间件</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>如何设置一个错误处理器</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">错误处理器中间件的定义和其他中间件一样，唯一的区别是 4 个而不是 3 个参数，即 (err, req, res, next)</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>如何渲染纯 HTML 文件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">无需通过 res.render() 渲染 HTML。你可以通过 res.sendFile() 直接对外输出 HTML 文件。如果你需要对外提供的资源文件很多，可以使用 express.static() 中间件</span><br></pre></td></tr></table></figure>
<h1 id="路由"><a class="markdownIt-Anchor" href="#路由"></a> 路由</h1>
<p>学习网址：<a href="http://www.expressjs.com.cn/guide/routing.html" target="_blank" rel="noopener">http://www.expressjs.com.cn/guide/routing.html</a></p>
<ul>
<li>路由（Routing）是由一个 URI（或者叫路径）和一个特定的 HTTP 方法（GET、POST 等）组成的，涉及到应用如何响应客户端对某个网站节点的访问</li>
<li>每一个路由都可以有一个或者多个处理器函数，当匹配到路由时，这个/些函数将被执行</li>
<li>路由的定义由如下结构组成：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">app.METHOD(PATH, HANDLER)</span><br><span class="line">其中，</span><br><span class="line">app 是一个 express 实例；</span><br><span class="line">METHOD 是某个 HTTP 请求方式中的一个；</span><br><span class="line">PATH 是服务器端的路径；</span><br><span class="line">HANDLER 是当路由匹配到时需要执行的函数</span><br></pre></td></tr></table></figure>
<ul>
<li>app.all() 是一个特殊的路由方法，没有任何 HTTP 方法与其对应，它的作用是对于一个路径上的所有请求加载中间件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//来自 “/secret” 的请求，不管使用 GET、POST、PUT等方法请求，句柄都会得到执行</span><br><span class="line">app.all(&apos;/secret&apos;, function (req, res, next) &#123;</span><br><span class="line">  console.log(&apos;Accessing the secret section ...&apos;);</span><br><span class="line">  next(); // pass control to the next handler</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ol>
<li>路由路径：路由路径和请求方法一起定义了请求的端点，它可以是字符串、字符串模式或者正则表达式</li>
<li>路由句柄：可以为请求处理提供多个回调函数，其行为类似 中间件；路由句柄有多种形式，可以是一个函数、一个函数数组，或者是两者混合</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">app.get(&apos;/example/b&apos;, function (req, res, next) &#123;</span><br><span class="line">  console.log(&apos;response will be sent by the next function ...&apos;);</span><br><span class="line">  next();</span><br><span class="line">&#125;, function (req, res) &#123;</span><br><span class="line">  res.send(&apos;Hello from B!&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">//混合方式</span><br><span class="line">app.get(&apos;/example/d&apos;, [cb0, cb1], function (req, res, next) &#123;</span><br><span class="line">  console.log(&apos;response will be sent by the next function ...&apos;);</span><br><span class="line">  next();</span><br><span class="line">&#125;, function (req, res) &#123;</span><br><span class="line">  res.send(&apos;Hello from D!&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>响应方法：下表中响应对象（res）的方法向客户端返回响应，终结请求响应的循环。如果在路由句柄中一个方法也不调用，来自客户端的请求会一直挂起</li>
</ol>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>res.download()</td>
<td>提示下载文件。</td>
</tr>
<tr>
<td>res.end()</td>
<td>终结响应处理流程。</td>
</tr>
<tr>
<td>res.json()</td>
<td>发送一个 JSON 格式的响应。</td>
</tr>
<tr>
<td>res.jsonp()</td>
<td>发送一个支持 JSONP 的 JSON 格式的响应。</td>
</tr>
<tr>
<td>res.redirect()</td>
<td>重定向请求。</td>
</tr>
<tr>
<td>res.render()</td>
<td>渲染视图模板。</td>
</tr>
<tr>
<td>res.send()</td>
<td>发送各种类型的响应。</td>
</tr>
<tr>
<td>res.sendFile</td>
<td>以八位字节流的形式发送文件。</td>
</tr>
<tr>
<td>res.sendStatus()</td>
<td>设置响应状态代码，并将其以字符串形式作为响应体的一部分发送。</td>
</tr>
</tbody>
</table>
<ul>
<li>app.route()：可使用 app.route() 创建路由路径的链式路由句柄</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">app.route(&apos;/book&apos;)</span><br><span class="line">  .get(function(req, res) &#123;</span><br><span class="line">    res.send(&apos;Get a random book&apos;);</span><br><span class="line">  &#125;)</span><br><span class="line">  .post(function(req, res) &#123;</span><br><span class="line">    res.send(&apos;Add a book&apos;);</span><br><span class="line">  &#125;)</span><br><span class="line">  .put(function(req, res) &#123;</span><br><span class="line">    res.send(&apos;Update the book&apos;);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>express.Router:可使用 express.Router 类创建模块化、可挂载的路由句柄。推荐。定于格式如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//brid.js</span><br><span class="line">var express = require(&apos;express&apos;);</span><br><span class="line">var router = express.Router();</span><br><span class="line"></span><br><span class="line">// 该路由使用的中间件  可选</span><br><span class="line">router.use(function timeLog(req, res, next) &#123;</span><br><span class="line">  console.log(&apos;Time: &apos;, Date.now());</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">// 定义 about 页面的路由</span><br><span class="line">router.get(&apos;/about&apos;, function(req, res) &#123;</span><br><span class="line">  res.send(&apos;About birds&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">module.exports = router;</span><br><span class="line"></span><br><span class="line">//加载使用</span><br><span class="line">var birds = require(&apos;./birds&apos;);</span><br><span class="line">...</span><br><span class="line">app.use(&apos;/birds&apos;, birds);</span><br></pre></td></tr></table></figure>
<h1 id="中间件"><a class="markdownIt-Anchor" href="#中间件"></a> 中间件</h1>
<blockquote>
<p>Express 是一个自身功能极简，完全是由路由和中间件构成一个的 web 开发框架：从本质上来说，一个 Express 应用就是在调用各种中间件</p>
</blockquote>
<blockquote>
<p>中间件（Middleware） 是一个函数，它可以访问请求对象（request object (req)）, 响应对象（response object (res)）, 和 web 应用中处于请求-响应循环流程中的中间件，一般被命名为 next 的变量；如果当前中间件没有终结请求-响应循环，则必须调用 next() 方法将控制权交给下一个中间件，否则请求就会挂起</p>
</blockquote>
<blockquote>
<p>中间件的功能：执行任何代码；修改请求和响应对象；终结请求-响应循环；调用堆栈中的下一个中间件</p>
</blockquote>
<p>Express 应用中间件种类：</p>
<ol>
<li>应用级中间件</li>
<li>路由级中间件</li>
<li>错误处理中间件</li>
<li>内置中间件</li>
<li>第三方中间件</li>
</ol>
<h2 id="应用级中间件"><a class="markdownIt-Anchor" href="#应用级中间件"></a> 应用级中间件</h2>
<p>应用级中间件绑定到 app 对象 使用 app.use() 和 app.METHOD()， 其中， METHOD 是需要处理的 HTTP 请求的方法，例如 GET, PUT, POST 等等，全部小写</p>
<ul>
<li>中间件系统的路由句柄可以为路径定义多个路由</li>
<li>各路由之间通过next()逐次调用</li>
<li>调用过程中如果某个路由句柄已经终止了请求-响应循环，则后面的路由及其句柄不会执行，也不会报错</li>
<li>如果需要在中间件栈中跳过剩余中间件，调用 next(‘route’) 方法将控制权交给下一个路由； next(‘route’) 只对使用 app.VERB() 或 router.VERB() 加载的中间件有效</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 一个中间件栈，处理指向 /user/:id 的 GET 请求</span><br><span class="line">app.get(&apos;/user/:id&apos;, function (req, res, next) &#123;</span><br><span class="line">  // 如果 user id 为 0, 跳到下一个路由</span><br><span class="line">  if (req.params.id == 0) next(&apos;route&apos;);</span><br><span class="line">  // 否则将控制权交给栈中下一个中间件</span><br><span class="line">  else next(); //</span><br><span class="line">&#125;, function (req, res, next) &#123;</span><br><span class="line">  // 渲染常规页面</span><br><span class="line">  res.render(&apos;regular&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 处理 /user/:id， 渲染一个特殊页面</span><br><span class="line">app.get(&apos;/user/:id&apos;, function (req, res, next) &#123;</span><br><span class="line">  res.render(&apos;special&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="路由级中间件"><a class="markdownIt-Anchor" href="#路由级中间件"></a> 路由级中间件</h2>
<ul>
<li>路由级中间件和应用级中间件一样，只是它绑定的对象为 express.Router(),使用：var router = express.Router();</li>
<li>路由级使用 router.use() 或 router.VERB() 加载</li>
<li>需要将路由挂载至应用，通过 app.use挂载</li>
</ul>
<h2 id="错误处理中间件"><a class="markdownIt-Anchor" href="#错误处理中间件"></a> 错误处理中间件</h2>
<p>错误处理中间件有 4 个参数，定义错误处理中间件时必须使用这 4 个参数。即使不需要 next 对象，也必须在签名中声明它，否则中间件会被识别为一个常规中间件，不能处理错误</p>
<h2 id="内置中间件"><a class="markdownIt-Anchor" href="#内置中间件"></a> 内置中间件</h2>
<p>从 4.x 版本开始，, Express 已经不再依赖 Connect 了。除了 express.static, Express 以前内置的中间件现在已经全部单独作为模块安装使用了</p>
<p>express.static(root, [options])</p>
<ul>
<li>参数 root 指提供静态资源的根目录</li>
<li>可选的 options 参数拥有如下属性</li>
</ul>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
<th>类型</th>
<th>缺省值</th>
</tr>
</thead>
<tbody>
<tr>
<td>dotfiles</td>
<td>是否对外输出文件名以点（.）开头的文件。可选值为 “allow”、“deny” 和 “ignore”</td>
<td>String</td>
<td>“ignore”</td>
</tr>
<tr>
<td>etag</td>
<td>是否启用 etag 生成</td>
<td>Boolean</td>
<td>true</td>
</tr>
<tr>
<td>extensions</td>
<td>设置文件扩展名备份选项</td>
<td>Array</td>
<td>[]</td>
</tr>
<tr>
<td>index</td>
<td>发送目录索引文件，设置为 false 禁用目录索引</td>
<td>Mixed</td>
<td>“index.html”</td>
</tr>
<tr>
<td>lastModified</td>
<td>设置 Last-Modified 头为文件在操作系统上的最后修改日期。可能值为 true 或 false</td>
<td>Boolean</td>
<td>true</td>
</tr>
<tr>
<td>maxAge</td>
<td>以毫秒或者其字符串格式设置 Cache-Control 头的 max-age 属性</td>
<td>Number</td>
<td>0</td>
</tr>
<tr>
<td>redirect</td>
<td>当路径为目录时，重定向至 “/”</td>
<td>Boolean</td>
<td>true</td>
</tr>
<tr>
<td>setHeaders</td>
<td>设置 HTTP 头以提供文件的函数</td>
<td>Function</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="第三方中间件"><a class="markdownIt-Anchor" href="#第三方中间件"></a> 第三方中间件</h2>
<ul>
<li>通过使用第三方中间件从而为 Express 应用增加更多功能</li>
<li>安装所需功能的 node 模块，并在应用中加载，可以在应用级加载，也可以在路由级加载</li>
</ul>
<h1 id="在-express-中使用模板引擎"><a class="markdownIt-Anchor" href="#在-express-中使用模板引擎"></a> 在 Express 中使用模板引擎</h1>
<p>需要在应用中进行如下设置才能让 Express 渲染模板文件：</p>
<ul>
<li>views, 放模板文件的目录，比如： app.set(‘views’, ‘./views’)</li>
<li>view engine, 模板引擎，比如： app.set(‘view engine’, ‘jade’)</li>
<li>安装相应的模板引擎 npm 软件包:npm install jade --save</li>
</ul>
<h1 id="错误处理"><a class="markdownIt-Anchor" href="#错误处理"></a> 错误处理</h1>
<ul>
<li>在其他 app.use() 和路由调用后，最后定义错误处理中间件</li>
<li>next() 和 next(err) 类似于 Promise.resolve() 和 Promise.reject()。它们让您可以向 Express 发信号，告诉它当前句柄执行结束并且处于什么状态。next(err) 会跳过后续句柄，除了那些用来处理错误的句柄</li>
</ul>
<h1 id="调试-express"><a class="markdownIt-Anchor" href="#调试-express"></a> 调试 Express</h1>
<ul>
<li>debug 有点像改装过的 console.log，不同的是，您不需要在生产代码中注释掉 debug。它会默认关闭，而且使用一个名为 DEBUG 的环境变量还可以打开</li>
<li>在启动应用时，设置 DEBUG 环境变量为 express:*，可以查看 Express 中用到的所有内部日志。webstorm中默认已设置</li>
<li>设置 DEBUG 的值为 express:router，只查看路由部分的日志；设置 DEBUG 的值为 express:application，只查看应用部分的日志</li>
</ul>
<h1 id="集成数据库"><a class="markdownIt-Anchor" href="#集成数据库"></a> 集成数据库</h1>
<p>为 Express 应用添加连接数据库的能力，只需要加载相应数据库的 Node.js 驱动即可</p>
<h2 id="mysql"><a class="markdownIt-Anchor" href="#mysql"></a> MySQL</h2>
<p>npm install mysql --save</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var mysql      = require(&apos;mysql&apos;);</span><br><span class="line">var connection = mysql.createConnection(&#123;</span><br><span class="line">  host     : &apos;localhost&apos;,</span><br><span class="line">  user     : &apos;dbuser&apos;,</span><br><span class="line">  password : &apos;s3kreee7&apos;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">connection.connect();</span><br><span class="line"></span><br><span class="line">connection.query(&apos;SELECT 1 + 1 AS solution&apos;, function(err, rows, fields) &#123;</span><br><span class="line">  if (err) throw err;</span><br><span class="line">  console.log(&apos;The solution is: &apos;, rows[0].solution);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">connection.end();</span><br></pre></td></tr></table></figure>
<h2 id="mongodb"><a class="markdownIt-Anchor" href="#mongodb"></a> MongoDB</h2>
<p>npm install mongoskin</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var db = require(&apos;mongoskin&apos;).db(&apos;localhost:27017/animals&apos;);</span><br><span class="line"></span><br><span class="line">db.collection(&apos;mamals&apos;).find().toArray(function(err, result) &#123;</span><br><span class="line">  if (err) throw err;</span><br><span class="line">  console.log(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="sqlite"><a class="markdownIt-Anchor" href="#sqlite"></a> SQLite</h2>
<p>npm install sqlite3</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var sqlite3 = require(&apos;sqlite3&apos;).verbose();</span><br><span class="line">var db = new sqlite3.Database(&apos;:memory:&apos;);</span><br><span class="line"></span><br><span class="line">db.serialize(function() &#123;</span><br><span class="line"></span><br><span class="line">  db.run(&apos;CREATE TABLE lorem (info TEXT)&apos;);</span><br><span class="line">  var stmt = db.prepare(&apos;INSERT INTO lorem VALUES (?)&apos;);</span><br><span class="line"></span><br><span class="line">  for (var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    stmt.run(&apos;Ipsum &apos; + i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  stmt.finalize();</span><br><span class="line"></span><br><span class="line">  db.each(&apos;SELECT rowid AS id, info FROM lorem&apos;, function(err, row) &#123;</span><br><span class="line">    console.log(row.id + &apos;: &apos; + row.info);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">db.close();</span><br></pre></td></tr></table></figure>
<h2 id="中文api"><a class="markdownIt-Anchor" href="#中文api"></a> 中文API</h2>
<p><a href="http://www.expressjs.com.cn/4x/api.html" target="_blank" rel="noopener">http://www.expressjs.com.cn/4x/api.html</a></p>

          
        
      
    </div>
    
    
    

    <div>
          
    </div>

    

    <div>
      
    </div>


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://chetaofeng.github.io/2018/10/26/前端开发-gulp入门/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="行锋">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/pub-images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="行锋">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/26/前端开发-gulp入门/" itemprop="url">gulp入门</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-26T16:04:30+08:00">
                2018-10-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[toc]</p>
<h1 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h1>
<p>gulpjs是一个前端构建工具，与gruntjs相比，gulpjs无需写一大堆繁杂的配置参数，API也非常简单，学习起来很容易，而且gulpjs使用的是nodejs中stream来读取和操作数据，其速度更快</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Gulp官网 http://gulpjs.com/</span><br><span class="line">Gulp中文网 http://www.gulpjs.com.cn/</span><br><span class="line">Gulp中文文档 https://github.com/lisposter/gulp-docs-zh-cn</span><br><span class="line">Gulp插件网 http://gulpjs.com/plugins/</span><br><span class="line">Awesome Gulp https://github.com/alferov/awesome-gulp</span><br><span class="line">StuQ-Gulp实战和原理解析 http://i5ting.github.io/stuq-gulp/</span><br></pre></td></tr></table></figure>
<h1 id="工作流程"><a class="markdownIt-Anchor" href="#工作流程"></a> 工作流程</h1>
<p>gulp的使用流程一般是这样子的：</p>
<ol>
<li>通过gulp.src()方法获取到我们想要处理的文件流，22. 把文件流通过pipe方法导入到gulp的插件中</li>
<li>把经过插件处理后的流再通过pipe方法导入到gulp.dest()中</li>
<li>gulp.dest()方法则把流中的内容写入到文件中</li>
</ol>
<p>==注意：== 给gulp.dest()传入的路径参数，只能用来指定要生成的文件的目录，而不能指定生成文件的文件名，它生成文件的文件名使用的是导入到它的文件流自身的文件名。==生成的文件名是由导入到它的文件流决定的==</p>
<h1 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h1>
<p>gulp基于node.js，要通过nodejs的npm安装gulp，所以先要安装nodejs环境</p>
<ul>
<li>全局方式：npm install -g gulp</li>
<li>gulp的项目中单独安装一次：npm install gulp</li>
<li>安装的时候把gulp写进项目package.json文件的依赖中：npm install --save-dev gulp</li>
</ul>
<p>在全局安装gulp后，还需要在项目中本地安装一次，是为了版本的灵活性，仅供参考</p>
<h1 id="开始使用gulp"><a class="markdownIt-Anchor" href="#开始使用gulp"></a> 开始使用gulp</h1>
<ol>
<li>建立gulpfile.js文件<br>
此时我们的目录结构是这样子的：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">├── gulpfile.js</span><br><span class="line">├── node_modules</span><br><span class="line">│ └── gulp</span><br><span class="line">└── package.json</span><br><span class="line">~</span><br></pre></td></tr></table></figure>
<p>最简gulpfile.js:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var gulp = require(&apos;gulp&apos;);</span><br><span class="line">gulp.task(&apos;default&apos;,function()&#123;</span><br><span class="line">    console.log(&apos;hello world&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>运行gulp任务<br>
切换到存放gulpfile.js文件的目录</li>
</ol>
<ul>
<li>执行gulp命令:会执行任务名为default的默认任务</li>
<li>gulp task1:执行task1任务</li>
</ul>
<h1 id="gulpfilejs文件"><a class="markdownIt-Anchor" href="#gulpfilejs文件"></a> gulpfile.js文件</h1>
<p>全局配置config：当gulpfile.js太大时就不好维护了，此时可以将需要在gulpfile中引用的参数，放到这里，包括一些路径，功能的开关等，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    name : &apos;.....&apos;,</span><br><span class="line">    devPath : &apos;.....&apos;,    //项目根路径，根路径下可以包含多个项目</span><br><span class="line">    prodPath : &apos;....&apos;, //生产路径根路径</span><br><span class="line">    sassPath : &apos;.....&apos;, //SASS包含文件路径</span><br><span class="line">    rmHtmlWhitespace : false,//html中是否去除空格</span><br><span class="line">    webpackEntry : &#123;</span><br><span class="line">        index : &apos;index.js&apos;//js合并</span><br><span class="line">    &#125;,</span><br><span class="line">    server : &#123;</span><br><span class="line">        port : 8088</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>意下这里使用了module.exports，这是nodejs的语法。在gulpfile中将会用require引用config。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var config = require(&apos;./config&apos;);//加载项目配置</span><br></pre></td></tr></table></figure>
<p>使用举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">//引入gulp，项目文件中安装的gulp的引入方式</span><br><span class="line">var gulp =require(&apos;gulp&apos;);</span><br><span class="line"></span><br><span class="line">//引入组件</span><br><span class="line">var jshint = require(&quot;gulp-jshint&quot;);</span><br><span class="line">var gutil = require(&quot;gulp-util&quot;);</span><br><span class="line">var sass= require(&quot;gulp-sass&quot;);</span><br><span class="line">var concat = require(&quot;gulp-concat&quot;);</span><br><span class="line">var uglify = require(&quot;gulp-uglify&quot;);</span><br><span class="line">var rename = require(&quot;gulp-rename&quot;);</span><br><span class="line"></span><br><span class="line">var path = require(&quot;path&quot;);</span><br><span class="line">var del = require(&quot;del&quot;);</span><br><span class="line"></span><br><span class="line">//你也许会想要在编译文件之前删除一些文件</span><br><span class="line">gulp.task(&apos;clean&apos;, function(cb) &#123;</span><br><span class="line">    return del([&apos;build/**/*&apos;], cb);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//检查脚本</span><br><span class="line">gulp.task(&apos;lint&apos;,function () &#123;</span><br><span class="line">    gulp.src(&apos;./src/javascript/**/*.js&apos;)</span><br><span class="line">        .pipe(jshint())</span><br><span class="line">        .pipe(jshint.reporter(&apos;default&apos;));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//编译sass</span><br><span class="line">//sass 任务会编译scss/目录下的scss文件，并把编译完成的css文件保存到/css目录中</span><br><span class="line">gulp.task(&apos;sass&apos;,function () &#123;</span><br><span class="line">    gulp.src(&quot;./src/scss/**/*.scss&quot;)</span><br><span class="line">        .pipe(sass(&#123;outputStyle: &apos;compact&apos;&#125;))</span><br><span class="line">        .pipe(gulp.dest(&quot;./build/css&quot;));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//合并，压缩文件</span><br><span class="line">//scipts 任务会合并js 目录下的所有js文件并输出到dist目录中，然后gulp会重命名。压缩合并的文件，也输出到dist/目录</span><br><span class="line">gulp.task(&apos;scripts&apos;,function () &#123;</span><br><span class="line">    gulp.src(&apos;./src/javascript/**/*.js&apos;)</span><br><span class="line">        .pipe(concat(&apos;all.js&apos;))</span><br><span class="line">        .pipe(gulp.dest(&apos;./dest&apos;))</span><br><span class="line">        .pipe(rename(&quot;all.min.js&quot;))</span><br><span class="line">        .pipe(uglify())</span><br><span class="line">        .pipe(gulp.dest(&quot;./build&quot;))</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//这时，我们创建了一个基于其他任务的default任务。</span><br><span class="line">//使用.run()方法关联和运行我们上面定义的任务，使用.watch() 方法去坚挺制定目录的文件变化,当有文件变化时，会运行回调定义的其他任务。</span><br><span class="line">gulp.task(&apos;default&apos;,function()&#123;</span><br><span class="line">    //将你的默认的任务代码放在这里</span><br><span class="line">    gulp.run(&apos;lint&apos;,&apos;sass&apos;,&apos;scripts&apos;);</span><br><span class="line">    //监听文件变化</span><br><span class="line">    gulp.watch(&quot;&quot;,function () &#123;</span><br><span class="line">        gulp.run(&apos;lint&apos;,&apos;sass&apos;,&apos;scripts&apos;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="gulp的api介绍"><a class="markdownIt-Anchor" href="#gulp的api介绍"></a> gulp的API介绍</h1>
<p>更多API介绍： <a href="http://www.gulpjs.com.cn/docs/api/" target="_blank" rel="noopener">http://www.gulpjs.com.cn/docs/api/</a></p>
<h2 id="gulpsrc"><a class="markdownIt-Anchor" href="#gulpsrc"></a> gulp.src()</h2>
<p>gulp.src()方法正是用来获取流的，但要注意这个流里的内容不是原始的文件流，而是一个虚拟文件对象流(Vinyl files)，这个虚拟文件对象中存储着原始文件的路径、文件名、内容等信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gulp.src(globs[, options])</span><br><span class="line"></span><br><span class="line">* globs参数是文件匹配模式(类似正则表达式)，用来匹配文件路径(包括文件名)，当然这里也可以直接指定某个具体的文件路径。当有多个匹配模式时，该参数可以为一个数组</span><br><span class="line">* options为可选参数</span><br></pre></td></tr></table></figure>
<ul>
<li>当我们没有在gulp.src()方法中配置base属性时，base的默认值为通配符开始出现之前那部分路径，例如：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gulp.src(&apos;app/src/**/*.css&apos;) //此时base的值为 app/src</span><br></pre></td></tr></table></figure>
<p>Gulp内部使用了node-glob模块来实现其文件匹配功能。我们可以使用下面这些特殊的字符来匹配我们想要的文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">* 匹配文件路径中的0个或多个字符，但不会匹配路径分隔符，除非路径分隔符出现在末尾</span><br><span class="line">** 匹配路径中的0个或多个目录及其子目录,需要单独出现，即它左右不能有其他东西了。如果出现在末尾，也能匹配文件。</span><br><span class="line">? 匹配文件路径中的一个字符(不会匹配路径分隔符)</span><br><span class="line">[...] 匹配方括号中出现的字符中的任意一个，当方括号中第一个字符为^或!时，则表示不匹配方括号中出现的其他字符中的任意一个，类似js正则表达式中的用法</span><br><span class="line">!(pattern|pattern|pattern) 匹配任何与括号中给定的任一模式都不匹配的</span><br><span class="line">?(pattern|pattern|pattern) 匹配括号中给定的任一模式0次或1次，类似于js正则中的(pattern|pattern|pattern)?</span><br><span class="line">+(pattern|pattern|pattern) 匹配括号中给定的任一模式至少1次，类似于js正则中的(pattern|pattern|pattern)+</span><br><span class="line">*(pattern|pattern|pattern) 匹配括号中给定的任一模式0次或多次，类似于js正则中的(pattern|pattern|pattern)*</span><br><span class="line">@(pattern|pattern|pattern) 匹配括号中给定的任一模式1次，类似于js正则中的(pattern|pattern|pattern)</span><br></pre></td></tr></table></figure>
<p>==注意：== 不能在数组中的第一个元素中使用排除模式</p>
<p>使用举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//使用数组的方式来匹配多种文件</span><br><span class="line">gulp.src([&apos;js/*.js&apos;,&apos;css/*.css&apos;,&apos;*.html&apos;])</span><br><span class="line"></span><br><span class="line">gulp.src([*.js,&apos;!b*.js&apos;]) //匹配所有js文件，但排除掉以b开头的js文件</span><br><span class="line">gulp.src([&apos;!b*.js&apos;,*.js]) //不会排除任何文件，因为排除模式不能出现在数组的第一个元素中</span><br></pre></td></tr></table></figure>
<h2 id="gulpdest"><a class="markdownIt-Anchor" href="#gulpdest"></a> gulp.dest()</h2>
<p>gulp.dest()方法是用来写文件的，其语法为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gulp.dest(path[,options])</span><br><span class="line"></span><br><span class="line">* path为写入文件的路径</span><br><span class="line">* options为一个可选的参数对象，通常我们不需要用到</span><br></pre></td></tr></table></figure>
<ul>
<li>生成的文件路径是我们传入的path参数后面再加上gulp.src()中有通配符开始出现的那部分路径</li>
</ul>
<h2 id="gulptask"><a class="markdownIt-Anchor" href="#gulptask"></a> gulp.task()</h2>
<p>gulp.task方法用来定义任务，内部使用的是Orchestrator，其语法为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(name[, deps], fn)</span><br><span class="line">* name 为任务名</span><br><span class="line">* deps 是当前定义的任务需要依赖的其他任务，为一个数组。当前定义的任务会在所有依赖的任务执行完毕后才开始执行。如果没有依赖，则可省略这个参数</span><br><span class="line">* fn 为任务函数，我们把任务要执行的代码都写在里面。该参数也是可选的。</span><br></pre></td></tr></table></figure>
<p>使用举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(&apos;mytask&apos;, [&apos;array&apos;, &apos;of&apos;, &apos;task&apos;, &apos;names&apos;], function() &#123; //定义一个有依赖的任务</span><br><span class="line">  // Do something</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ol>
<li>如果任务相互之间没有依赖，任务会按你书写的顺序来执行</li>
<li>如果有依赖的话则会先执行依赖的任务</li>
<li>如果某个任务所依赖的任务是异步的，就要注意了，gulp并不会等待那个所依赖的异步任务完成，而是会接着执行后续的任务</li>
</ol>
<h2 id="gulpwatch"><a class="markdownIt-Anchor" href="#gulpwatch"></a> gulp.watch()</h2>
<p>gulp.watch()用来监视文件的变化，当文件发生变化后，我们可以利用它来执行相应的任务，例如文件压缩等。其语法为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gulp.watch(glob[, opts], tasks)</span><br><span class="line">* glob 为要监视的文件匹配模式，规则和用法与gulp.src()方法中的glob相同。</span><br><span class="line">* opts 为一个可选的配置对象，通常不需要用到</span><br><span class="line">* tasks 为文件变化后要执行的任务，为一个数组</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(&apos;uglify&apos;,function()&#123;</span><br><span class="line">  //do something</span><br><span class="line">&#125;);</span><br><span class="line">gulp.task(&apos;reload&apos;,function()&#123;</span><br><span class="line">  //do something</span><br><span class="line">&#125;);</span><br><span class="line">gulp.watch(&apos;js/**/*.js&apos;, [&apos;uglify&apos;,&apos;reload&apos;]);</span><br></pre></td></tr></table></figure>
<h1 id="一些常用的gulp插件"><a class="markdownIt-Anchor" href="#一些常用的gulp插件"></a> 一些常用的gulp插件</h1>
<h2 id="自动加载插件pulp-load-plugins"><a class="markdownIt-Anchor" href="#自动加载插件pulp-load-plugins"></a> 自动加载插件pulp-load-plugins</h2>
<ul>
<li>这个插件能自动帮你加载package.json文件里的gulp插件</li>
<li>gulp-load-plugins是通过package.json文件来加载插件</li>
<li>gulp-load-plugins并不会一开始就加载所有package.json里的gulp插件，而是在我们需要用到某个插件的时候，才去加载那个插件</li>
<li>定义及启用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var gulp = require(&apos;gulp&apos;);</span><br><span class="line">//加载gulp-load-plugins插件，并马上运行它</span><br><span class="line">var plugins = require(&apos;gulp-load-plugins&apos;)();</span><br></pre></td></tr></table></figure>
<ul>
<li>使用举例：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plugins.rename          //gulp-rename插件的使用</span><br></pre></td></tr></table></figure>
<h2 id="重命名插件gulp-rename"><a class="markdownIt-Anchor" href="#重命名插件gulp-rename"></a> 重命名插件gulp-rename</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(&apos;rename&apos;, function () &#123;</span><br><span class="line">    gulp.src(&apos;js/jquery.js&apos;)</span><br><span class="line">    .pipe(uglify())  //压缩</span><br><span class="line">    .pipe(rename(&apos;jquery.min.js&apos;)) //会将jquery.js重命名为jquery.min.js</span><br><span class="line">    .pipe(gulp.dest(&apos;js&apos;)); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="js文件压缩插件gulp-uglify"><a class="markdownIt-Anchor" href="#js文件压缩插件gulp-uglify"></a> js文件压缩插件gulp-uglify</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var gulp = require(&apos;gulp&apos;),</span><br><span class="line">    uglify = require(&quot;gulp-uglify&quot;);</span><br><span class="line"> </span><br><span class="line">gulp.task(&apos;minify-js&apos;, function () &#123;</span><br><span class="line">    gulp.src(&apos;js/*.js&apos;) // 要压缩的js文件</span><br><span class="line">    .pipe(uglify())  //使用uglify进行压缩,更多配置请参考：</span><br><span class="line">    .pipe(gulp.dest(&apos;dist/js&apos;)); //压缩后的路径</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="css文件压缩插件gulp-minify-css"><a class="markdownIt-Anchor" href="#css文件压缩插件gulp-minify-css"></a> css文件压缩插件gulp-minify-css</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var gulp = require(&apos;gulp&apos;),</span><br><span class="line">    minifyCss = require(&quot;gulp-minify-css&quot;);</span><br><span class="line"> </span><br><span class="line">gulp.task(&apos;minify-css&apos;, function () &#123;</span><br><span class="line">    gulp.src(&apos;css/*.css&apos;) // 要压缩的css文件</span><br><span class="line">    .pipe(minifyCss()) //压缩css</span><br><span class="line">    .pipe(gulp.dest(&apos;dist/css&apos;));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="html文件压缩插件gulp-minify-html"><a class="markdownIt-Anchor" href="#html文件压缩插件gulp-minify-html"></a> html文件压缩插件gulp-minify-html</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var gulp = require(&apos;gulp&apos;),</span><br><span class="line">    minifyHtml = require(&quot;gulp-minify-html&quot;);</span><br><span class="line"> </span><br><span class="line">gulp.task(&apos;minify-html&apos;, function () &#123;</span><br><span class="line">    gulp.src(&apos;html/*.html&apos;) // 要压缩的html文件</span><br><span class="line">    .pipe(minifyHtml()) //压缩</span><br><span class="line">    .pipe(gulp.dest(&apos;dist/html&apos;));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="js代码检查插件"><a class="markdownIt-Anchor" href="#js代码检查插件"></a> js代码检查插件</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var gulp = require(&apos;gulp&apos;),</span><br><span class="line">    jshint = require(&quot;gulp-jshint&quot;);</span><br><span class="line"> </span><br><span class="line">gulp.task(&apos;jsLint&apos;, function () &#123;</span><br><span class="line">    gulp.src(&apos;js/*.js&apos;)</span><br><span class="line">    .pipe(jshint())</span><br><span class="line">    .pipe(jshint.reporter()); // 输出检查结果</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="文件合并插件gulp-concat"><a class="markdownIt-Anchor" href="#文件合并插件gulp-concat"></a> 文件合并插件gulp-concat</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var gulp = require(&apos;gulp&apos;),</span><br><span class="line">    concat = require(&quot;gulp-concat&quot;);</span><br><span class="line"> </span><br><span class="line">gulp.task(&apos;concat&apos;, function () &#123;</span><br><span class="line">    gulp.src(&apos;js/*.js&apos;)  //要合并的文件</span><br><span class="line">    .pipe(concat(&apos;all.js&apos;))  // 合并匹配到的js文件并命名为 &quot;all.js&quot;</span><br><span class="line">    .pipe(gulp.dest(&apos;dist/js&apos;));</span><br><span class="line">&#125;);</span><br><span class="line">~~~ </span><br><span class="line"></span><br><span class="line">## 图片压缩插件</span><br></pre></td></tr></table></figure>
<p>var gulp = require(‘gulp’);<br>
var imagemin = require(‘gulp-imagemin’);<br>
var pngquant = require(‘imagemin-pngquant’); //png图片压缩插件</p>
<p>gulp.task(‘default’, function () {<br>
return gulp.src(‘src/images/*’)<br>
.pipe(imagemin({<br>
progressive: true,<br>
use: [pngquant()] //使用pngquant来压缩png图片<br>
}))<br>
.pipe(gulp.dest(‘dist’));<br>
});</p>
<pre class="highlight"><code class=""></code></pre>

          
        
      
    </div>
    
    
    

    <div>
          
    </div>

    

    <div>
      
    </div>


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://chetaofeng.github.io/2018/10/26/前端开发-grunt入门/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="行锋">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/pub-images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="行锋">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/26/前端开发-grunt入门/" itemprop="url">grunt入门</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-26T16:04:30+08:00">
                2018-10-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[toc]</p>
<p>Grunt中文网：<a href="http://www.gruntjs.net/" target="_blank" rel="noopener">http://www.gruntjs.net/</a></p>
<h1 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h1>
<blockquote>
<p>Grunt和 Grunt 插件是通过 npm 安装并管理的，npm是 Node.js 的包管理器。Grunt配合Node.js有相应的版本要求，如：Grunt 0.4.x 必须配合Node.js &gt;= 0.8.0版本使用</p>
</blockquote>
<blockquote>
<p>奇数版本号的 Node.js 被认为是不稳定的开发版</p>
</blockquote>
<h1 id="grunt-cli"><a class="markdownIt-Anchor" href="#grunt-cli"></a> Grunt-CLI</h1>
<h2 id="简介-2"><a class="markdownIt-Anchor" href="#简介-2"></a> 简介</h2>
<p>安装：npm install -g grunt-cli</p>
<p>注意：</p>
<ol>
<li>安装grunt-cli并不等于安装了 Grunt！</li>
<li>Grunt CLI的任务很简单：调用与Gruntfile在同一目录中 Grunt。这样带来的好处是，允许你在同一个系统上同时安装多个版本的 Grunt。</li>
</ol>
<p>运行原理：</p>
<ol>
<li>每次运行grunt 时，他就利用node提供的require()系统查找本地安装的 Grunt。正是由于这一机制，你可以在项目的任意子目录中运行grunt 。</li>
<li>如果找到一份本地安装的 Grunt，CLI就将其加载，并传递Gruntfile中的配置信息，然后执行你所指定的任务。</li>
</ol>
<p>一份新的 Grunt项目一般需要在你的项目中添加两份文件：package.json 和 Gruntfile</p>
<h2 id="packagejson"><a class="markdownIt-Anchor" href="#packagejson"></a> package.json:</h2>
<p>package.json字段全解：<a href="http://blog.csdn.net/woxueliuyun/article/details/39294375" target="_blank" rel="noopener">http://blog.csdn.net/woxueliuyun/article/details/39294375</a></p>
<ol>
<li>被npm用于存储项目的元数据便将此项目发布为npm模块。你可以在此文件中列出项目依赖的grunt和Grunt插件，放置于devDependencies配置段内</li>
<li>package.json应当放置于项目的根目录中，与Gruntfile在同一目录中，并且应该与项目的源代码一起被提交</li>
<li>在目录(package.json所在目录)中运行npm install将依据package.json文件中所列出的每个依赖来自动安装适当版本的依赖</li>
<li>为项目添加package.json文件的方式：</li>
</ol>
<ul>
<li>大部分 grunt-init 模版都会自动创建特定于项目的package.json文件</li>
<li>npm init命令会创建一个基本的package.json文件</li>
<li>复制下面的案例，并根据需要做扩充，参考https://npmjs.org/doc/json.html</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> &quot;name&quot;: &quot;my-project-name&quot;,</span><br><span class="line"> &quot;version&quot;: &quot;0.1.0&quot;,</span><br><span class="line"> &quot;devDependencies&quot;: &#123;</span><br><span class="line">      &quot;grunt&quot;: &quot;~0.4.1&quot;,</span><br><span class="line">      &quot;grunt-contrib-jshint&quot;: &quot;~0.6.0&quot;,</span><br><span class="line">      &quot;grunt-contrib-nodeunit&quot;: &quot;~0.2.0&quot;,</span><br><span class="line">      &quot;grunt-contrib-uglify&quot;: &quot;~0.2.2&quot;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="gruntfile"><a class="markdownIt-Anchor" href="#gruntfile"></a> Gruntfile:</h2>
<ol>
<li>此文件被命名为 Gruntfile.js 或 Gruntfile.coffee，用来配置或定义任务（task）并加载Grunt插件的</li>
<li>Gruntfile.js 或 Gruntfile.coffee 文件是有效的 JavaScript 或 CoffeeScript 文件，应当放在你的项目根目录中，和package.json文件在同一目录层级</li>
<li>Gruntfile由以下几部分构成：“wrapper” 函数；项目与任务配置；加载grunt插件和任务；自定义任务</li>
</ol>
<ul>
<li>&quot;wrapper&quot;函数:<br>
每一份 Gruntfile（和grunt插件）都遵循同样的格式，你所书写的Grunt代码必须放在此函数内：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module.exports = function(grunt) &#123;</span><br><span class="line"> // Do grunt-related things in here</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>项目与任务配置:大部分的Grunt任务都依赖某些配置数据，这些数据被定义在一个object内，并传递给grunt.initConfig方法，如package.json文件</li>
<li>加载grunt插件和任务:像 concatenation、[minification]、grunt-contrib-uglify 和 linting这些常用的任务（task）都已经以grunt插件的形式被开发出来了。只要在 package.json 文件中被列为dependency（依赖）的包，并通过npm install安装之后，都可以在Gruntfile中以简单命令的形式使用：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 加载能够提供&quot;uglify&quot;任务的插件。</span><br><span class="line">grunt.loadNpmTasks(&apos;grunt-contrib-uglify&apos;);</span><br></pre></td></tr></table></figure>
<p>注意： grunt --help 命令将列出所有可用的任务。</p>
<ul>
<li>自定义任务:通过定义 default 任务，可以让Grunt默认执行一个或多个任务</li>
</ul>
<p>Gruntfile.js文件示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">module.exports = function(grunt) &#123;</span><br><span class="line">    // Project configuration.</span><br><span class="line">    grunt.initConfig(&#123;</span><br><span class="line">        pkg: grunt.file.readJSON(&apos;package.json&apos;), //package.json文件中的项目元数据（metadata）被导入到 Grunt 配置中</span><br><span class="line">        uglify: &#123;</span><br><span class="line">            options: &#123;</span><br><span class="line">                banner: &apos;/*! &lt;%= pkg.name %&gt; &lt;%= grunt.template.today(&quot;yyyy-mm-dd&quot;) %&gt; */\n&apos;</span><br><span class="line">            &#125;,</span><br><span class="line">            build: &#123;</span><br><span class="line">                src: &apos;src/&lt;%= pkg.name %&gt;.js&apos;,</span><br><span class="line">                dest: &apos;build/&lt;%= pkg.name %&gt;.min.js&apos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;); </span><br><span class="line">    // 加载包含 &quot;uglify&quot; 任务的插件。</span><br><span class="line">    grunt.loadNpmTasks(&apos;grunt-contrib-uglify&apos;);</span><br><span class="line">    // 默认被执行的任务列表。</span><br><span class="line">    grunt.registerTask(&apos;default&apos;, [&apos;uglify&apos;]);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Gurnt CLI参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">--help, -h ==Display help text</span><br><span class="line">--base, -b ==Specify an alternate base path. By default, all file paths are relative to the Gruntfile.</span><br><span class="line">==Alternative to grunt.file.setBase(...)</span><br><span class="line">--no-color ==Disable colored output.</span><br><span class="line">--gruntfile ==Specify an alternate Gruntfile.</span><br><span class="line">==By default,grunt looks in the current or parent directories for the nearest Gruntfile.(js/coffee) file.</span><br><span class="line">--debug, -d ==Enable debugging mode for tasks that support it.</span><br><span class="line">--stack ==Print a stack trace when exiting with a warning or fatal error.</span><br><span class="line">--force, -f ==A way to force your way past warnings.Want a suggestion? Don&apos;t use this option, fix your code.</span><br><span class="line">--tasks ==Additional directory paths to scan for task and &quot;extra&quot; files.Alternative to grunt.loadTasks(...)</span><br><span class="line">--npm ==Npm-installed grunt plugins to scan for task and &quot;extra&quot; files.Alternative to grunt.loadNpmTasks(...)</span><br><span class="line">--no-write ==Disable writing files (dry run).</span><br><span class="line">--verbose, -v ==Verbose mode. A lot more information output.</span><br><span class="line">--version, -V ==Print the grunt version. Combine with --verbose for more info.</span><br><span class="line">--completion ==Output shell auto-completion rules. See the grunt-cli documentation for more information.</span><br></pre></td></tr></table></figure>
<h1 id="安装gurnt和gurnt插件"><a class="markdownIt-Anchor" href="#安装gurnt和gurnt插件"></a> 安装Gurnt和Gurnt插件</h1>
<h2 id="安装命令"><a class="markdownIt-Anchor" href="#安装命令"></a> 安装命令</h2>
<ul>
<li>npm install grunt --save-dev</li>
<li>npm install grunt ==[@VERSION]== --save-dev</li>
</ul>
<h2 id="gurnt插件"><a class="markdownIt-Anchor" href="#gurnt插件"></a> Gurnt插件</h2>
<blockquote>
<p><a href="http://gruntjs.com/plugins" target="_blank" rel="noopener">http://gruntjs.com/plugins</a></p>
</blockquote>
<blockquote>
<p>Grunt官方插件列表，其中带星号的为官方维护的插件</p>
</blockquote>
<p>创建插件：</p>
<ol>
<li>通过 npm install -g grunt-init 命令安装 grunt-init 。</li>
<li>通过 git clone git://github.com/gruntjs/grunt-init-gruntplugin.git ~/.grunt-init/gruntplugin 命令安装grunt插件模版。</li>
<li>在一个空的目录中执行 grunt-init gruntplugin 。</li>
<li>执行 npm install 命令以准备开发环境。</li>
<li>为你的插件书写代码。</li>
<li>执行 npm publish 命令将你创建的 Grunt 插件提发布npm</li>
</ol>
<p>注意：</p>
<ol>
<li>grunt-contrib&quot; 命名空间保留给 Grunt 团队维护的task使用，请给你自己的task起一个合适名字，并且避免使用被保留的命名空间</li>
<li>Grunt默认隐藏error stack traces，但可–stack启用方便调试自己的task;在bash中可通过alias grunt='grunt --stack’创建别名默认记录下stack trace</li>
<li>存储任务文件：建议使用几个常用npm模块（例如 temporary、tmp）来调用操作系统级别的临时目录功能</li>
<li>避免改变当前工作目录：process.cwd()</li>
</ol>
<ul>
<li>默认包含gruntfile文件的目录被设置为当前工作目录。用户可在自己的gruntfile中通过grunt.file.setBase()改变改变当前工作目录，但是插件不应该改变它</li>
<li>path.resolve(‘foo’) 可以被用来获取’foo’ 相对于 Gruntfile 所在目录的绝对路径</li>
</ul>
<ol start="5">
<li>Grunt常用插件</li>
</ol>
<ul>
<li>grunt-contrib-uglify：压缩js代码</li>
<li>grunt-contrib-concat：合并js文件</li>
<li>grunt-contrib-qunit：单元测试</li>
<li>grunt-contrib-jshint：js代码检查</li>
<li>grunt-contrib-watch：监控文件修改并重新执行注册的任务</li>
</ul>
<h1 id="task"><a class="markdownIt-Anchor" href="#task"></a> Task</h1>
<blockquote>
<p>Grunt就只支持两种任务：基本的Task以及MultiTasks</p>
</blockquote>
<blockquote>
<p>区别是基本的Task的任务配置只有一个，而MultiTasks则有多个。大多数的grunt插件任务都是MultiTasks</p>
</blockquote>
<h2 id="task的创建"><a class="markdownIt-Anchor" href="#task的创建"></a> Task的创建</h2>
<ul>
<li>grunt注册任务的格式:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grunt.registerTask(taskName, [description, ] taskList)</span><br></pre></td></tr></table></figure>
<ul>
<li>grunt默认任务:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//如果运行Grunt时没有指定任何任务，它将自动执行&apos;jshint&apos;、&apos;qunit&apos;、&apos;concat&apos; 和 &apos;uglify&apos; 任务</span><br><span class="line">grunt.registerTask(&apos;default&apos;, [&apos;jshint&apos;, &apos;qunit&apos;, &apos;concat&apos;, &apos;uglify&apos;]);</span><br></pre></td></tr></table></figure>
<ul>
<li>grunt任务带参数的格式:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grunt.registerTask(&apos;dist&apos;, [&apos;concat:distArg&apos;, &apos;uglify:distArg&apos;]);</span><br></pre></td></tr></table></figure>
<ol>
<li>当一个基本任务执行时，Grunt并不会检查配置和环境 – 它仅仅执行指定的任务函数，并传递任何使用冒号分割的参数作为函数的参数</li>
<li>如果你的任务并没有遵循 “多任务” 结构，那就使用自定义任务，在一个任务内部，执行其他的任务，使用grunt.task.run(‘bar’, ‘baz’);</li>
<li>任务还可以依赖于其他任务的成功执行。注意 grunt.task.requires 并不会真正的运行其他任务，它仅仅检查其它任务是否已经执行，并且没有失败</li>
</ol>
<h2 id="task的配置"><a class="markdownIt-Anchor" href="#task的配置"></a> Task的配置</h2>
<p>Grunt的task配置都是在 Gruntfile 中的grunt.initConfig方法中指定的。此配置主要是以任务名称命名的属性，也可以包含其他任意数据。一旦这些代表任意数据的属性与任务所需要的属性相冲突，就将被忽略。</p>
<p>在一个任务配置中:</p>
<ul>
<li>options属性可以用来指定覆盖内置属性的默认。</li>
<li>每一个目标（target）中还可以拥有一个专门针对此目标（target）的options属性</li>
<li>目标（target）级的options将会覆盖任务级的options</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">grunt.initConfig(&#123;</span><br><span class="line">    concat: &#123; =================Task</span><br><span class="line">        options: &#123;</span><br><span class="line">         // 这里是任务级的Options，覆盖默认值</span><br><span class="line">        &#125;,</span><br><span class="line">        foo: &#123; =================Target，并非子任务</span><br><span class="line">            options: &#123;</span><br><span class="line">            // &quot;foo&quot; target options may go here, overriding task-level options.</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        bar: &#123;</span><br><span class="line">        // No options specified; this target will use task-level options.</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="文件"><a class="markdownIt-Anchor" href="#文件"></a> 文件</h2>
<p>由于大多的任务都是执行文件操作，Grunt有一个强大的抽象层用于声明任务应该操作哪些文件。这里有好几种定义src-dest(源文件-目标文件)文件映射的方式，均提供了不同程度的描述和控制操作方式。任何一种多任务（multi-task）都能理解下面的格式，所以你只需要选择满足你需求的格式就行。</p>
<p>详见：<a href="http://www.gruntjs.net/configuring-tasks" target="_blank" rel="noopener">http://www.gruntjs.net/configuring-tasks</a></p>
<h1 id="项目实战"><a class="markdownIt-Anchor" href="#项目实战"></a> 项目实战</h1>
<p>Nodejs和CLI安装好之后，参考：<a href="http://www.bluesdream.com/blog/windows-installs-the-grunt-and-instructions.html" target="_blank" rel="noopener">http://www.bluesdream.com/blog/windows-installs-the-grunt-and-instructions.html</a></p>
<ol>
<li>mkdir testProject  -&gt; cd testProject</li>
<li>创建package.json文件</li>
</ol>
<p>package.json官方文档:<a href="https://docs.npmjs.com/json" target="_blank" rel="noopener">https://docs.npmjs.com/json</a></p>
<ul>
<li>A: npm init ==自动创建pachage.json文件</li>
<li>B: 手动创建package.json文件，添加项目/模块的描述信息</li>
</ul>
<ol start="3">
<li>安装Grunt和Grunt插件：</li>
</ol>
<ul>
<li>手动添加，修改package.json文件，然后执行npm install<br>
{<br>
“name”: “my-project”,<br>
“version”: “0.1.0”,<br>
“devDependencies”: {<br>
“grunt”: “~0.4.1”,<br>
“grunt-contrib-cssmin”: “~0.7.0” //其中&quot;~0.7.0&quot;代表安装该插件的某个特定版本，如果只需安装最新版本，可以改成&quot;*&quot;<br>
}<br>
}</li>
<li>自动安装： 其中–save-dev，表示将它作为你的项目依赖添加到package.json文件中devDependencies内</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install grunt --save-dev //安装最新版的Grunt</span><br><span class="line">npm install grunt-contrib-cssmin --save-dev //安装我们所需要的插件</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>创建Gruntfile.js文件：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">module.exports = function(grunt) &#123;</span><br><span class="line">    // 配置任务参数</span><br><span class="line">    grunt.initConfig(&#123;</span><br><span class="line">        pkg: grunt.file.readJSON(&apos;package.json&apos;),</span><br><span class="line">        cssmin: &#123;</span><br><span class="line">            combine: &#123;</span><br><span class="line">                files: &#123;</span><br><span class="line">                    &apos;css/release/compress.css&apos;: [&apos;css/*.css&apos;] // 指定合并的CSS文件 [&apos;css/base.css&apos;, &apos;css/global.css&apos;]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            minify: &#123;</span><br><span class="line">                options: &#123;</span><br><span class="line">                    keepSpecialComments: 0, /* 删除所有注释 */</span><br><span class="line">                    banner: &apos;/* minified css file */&apos;</span><br><span class="line">                &#125;,</span><br><span class="line">                files: &#123;</span><br><span class="line">                    &apos;css/release/master.min.css&apos;: [&apos;css/master.css&apos;]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    // 插件加载（加载 &quot;cssmin&quot; 模块）</span><br><span class="line">    grunt.loadNpmTasks(&apos;grunt-contrib-cssmin&apos;);</span><br><span class="line">    // 自定义任务：通过定义 default 任务，可以让Grunt默认执行一个或多个任务。</span><br><span class="line">    grunt.registerTask(&apos;default&apos;, [&apos;cssmin&apos;]);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>执行：</li>
</ol>
<ul>
<li>grunt //执行配置中所有的任务</li>
<li>grunt cssmin //执行特定的任务</li>
</ul>
<ol start="6">
<li>测试：</li>
</ol>
<ul>
<li>在项目文件夹中创建个子文件夹，命名为：CSS</li>
<li>在里面创建base.css和master.css，2个CSS文件，你可以随便写点内容在里面。</li>
<li>在命令行中执行grunt，看到如下提示说明执行成功：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Running &quot;cssmin:combine&quot; (cssmin) task</span><br><span class="line">File css/release/compress.css created.</span><br><span class="line">Running &quot;cssmin:minify&quot; (cssmin) task</span><br><span class="line">File css/release/master.min.css created.</span><br><span class="line">Done, without errors.</span><br></pre></td></tr></table></figure>
<h1 id="jsdocgrunt"><a class="markdownIt-Anchor" href="#jsdocgrunt"></a> JSDoc&amp;Grunt</h1>
<p>grunt-jsdoc是一个Grunt的插件。这个插件集成了JsDoc Toolkit 3，并且你能够通过配置Grunt任务来生成API文档</p>
<p>补充：grunt-jsdoc-plugin是同一个开发者，但是区别是grunt-jsdoc是基于JsDoc Toolkit 3而grunt-jsdoc-plugin是基于JsDoc Toolkit 2的</p>
<p>安装:</p>
<ol>
<li>已安装好JAVA且配置好了Java环境变量</li>
<li>npm install grunt-jsdoc --save-dev //安装jsdoc插件</li>
</ol>
<p>grunt-jsdoc的grunt任务配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">grunt.initConfig(&#123;</span><br><span class="line">    jsdoc : &#123;</span><br><span class="line">        dist : &#123;</span><br><span class="line">            src: [&apos;src/*.js&apos;, &apos;test/*.js&apos;],</span><br><span class="line">            options: &#123;</span><br><span class="line">                destination: &apos;doc&apos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">src: 要自动生成API文档的源文件路径数组</span><br><span class="line">jsdoc: jsdoc的bin文件夹目录</span><br><span class="line">options: jsdoc单独使用的配置项</span><br><span class="line">destination： 必填，指定文档输出路径</span><br><span class="line">configure： jsdoc配置文件路径</span><br><span class="line">template： 文档模板路径</span><br><span class="line">private： 是否在文档中输出private成员，默认为true</span><br></pre></td></tr></table></figure>
<p>更多参数：参考官方文档：Command-line arguments to JSDoc: <a href="http://usejsdoc.org/about-commandline.html" target="_blank" rel="noopener">http://usejsdoc.org/about-commandline.html</a></p>
<h1 id="gruntjs和gulpjs工作方式的区别"><a class="markdownIt-Anchor" href="#gruntjs和gulpjs工作方式的区别"></a> Grunt.js和Gulp.js工作方式的区别</h1>
<ul>
<li>Grunt主要是以文件为媒介来运行它的工作流的，比如在Grunt中执行完一项任务后，会把结果写入到一个临时文件中，然后可以在这个临时文件内容的基础上执行其它任务，执行完成后又把结果写入到临时文件中，然后又以这个为基础继续执行其它任务…就这样反复下去。</li>
<li>在Gulp中，使用的是Nodejs中的stream(流)，首先获取到需要的stream，然后可以通过stream的pipe()方法把流导入到你想要的地方，比如Gulp的插件中，经过插件处理后的流又可以继续导入到其他插件中，当然也可以把流写入到文件中。所以Gulp是以stream为媒介的，它不需要频繁的生成临时文件，这也是Gulp的速度比Grunt快的一个原因</li>
</ul>

          
        
      
    </div>
    
    
    

    <div>
          
    </div>

    

    <div>
      
    </div>


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://chetaofeng.github.io/2018/10/26/前端开发-vue入门/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="行锋">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/pub-images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="行锋">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/26/前端开发-vue入门/" itemprop="url">Vue入门</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-26T16:04:30+08:00">
                2018-10-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://cn.vuejs.org/</span><br><span class="line">https://vuejs.org/</span><br><span class="line">https://cn.vuejs.org/v2/api/</span><br></pre></td></tr></table></figure>
<h1 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h1>
<blockquote>
<p>Vue.js是当下很火的一个JavaScript MVVM库，它是以数据驱动和组件化的思想构建的。相比于Angular.js，Vue.js提供了更加简洁、更易于理解的。是个人维护项目</p>
</blockquote>
<blockquote>
<p>Vue.js是数据驱动的，你无需手动操作DOM</p>
</blockquote>
<blockquote>
<p>通过一些特殊的HTML语法，将DOM和数据绑定起来。一旦你创建了绑定，DOM将和数据保持同步，每当变更了数据，DOM也会相应地更新</p>
</blockquote>
<blockquote>
<p>使用Vue.js时，也可以结合其他库一起使用，比如jQuery</p>
</blockquote>
<p>使用Vue的过程就是定义MVVM各个组成部分的过程的过程</p>
<ol>
<li>定义View</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &#123;&#123; message &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>定义Model，如：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var exampleData = &#123;</span><br><span class="line">    message: &apos;Hello World!&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>创建一个Vue实例或&quot;ViewModel&quot;，它用于连接View和Model</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">    el: &apos;#app&apos;,</span><br><span class="line">    data: exampleData</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="vue实例"><a class="markdownIt-Anchor" href="#vue实例"></a> Vue实例</h1>
<h2 id="构造器"><a class="markdownIt-Anchor" href="#构造器"></a> 构造器</h2>
<p>每个 Vue.js 应用都是通过构造函数 Vue 创建一个 Vue 的根实例 启动的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  // 选项</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>实例化 Vue 时，需要传入一个选项对象，它可以包含数据、模板、挂载元素、方法、生命周期钩子等选项,具体API查看：<a href="https://cn.vuejs.org/v2/api/" target="_blank" rel="noopener">https://cn.vuejs.org/v2/api/</a></p>
<h2 id="属性和方法"><a class="markdownIt-Anchor" href="#属性和方法"></a> 属性和方法</h2>
<ul>
<li>每个 Vue 实例都会代理其 data 对象里所有的属性</li>
<li>==只有这些被代理的属性是响应的==</li>
<li>如果在实例创建之后添加新的属性到实例上，它不会触发视图更新</li>
<li>Vue 实例暴露了一些有用的实例属性与方法。这些属性与方法都有前缀 $，以便与代理的 data 属性区分</li>
</ul>
<h2 id="实例生命周期"><a class="markdownIt-Anchor" href="#实例生命周期"></a> 实例生命周期</h2>
<p>每个 Vue 实例在被创建之前都要经过一系列的初始化过程</p>
<p><img src="http://note.youdao.com/yws/api/personal/file/WEB57f1826aa9ca7087a82b38e583419433?method=download&amp;shareKey=33f8412154b6172b3bf4b99f8bcf0a40" alt="image"></p>
<h1 id="vuejs的常用指令"><a class="markdownIt-Anchor" href="#vuejs的常用指令"></a> Vue.js的常用指令</h1>
<p>Vue.js的指令是以v-开头的，它们作用于HTML元素，指令提供了一些特殊的特性，将指令绑定在元素上时，指令会为绑定的目标元素添加一些特殊的行为，我们可以将指令看作特殊的HTML特性（attribute）</p>
<ul>
<li>用 key 管理可复用的元素:添加一个具有唯一值的 key 属性,来声明“这两个元素是完全独立的——不要复用它们”</li>
</ul>
<p>Vue.js提供了一些常用的内置指令，接下来我们将介绍以下几个内置指令：</p>
<h2 id="v-if指令"><a class="markdownIt-Anchor" href="#v-if指令"></a> v-if指令</h2>
<p>条件渲染指令，它根据表达式的真假来删除和插入元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 v-if=&quot;age &gt;= 25&quot;&gt;Age: &#123;&#123; age &#125;&#125;&lt;/h1&gt;</span><br></pre></td></tr></table></figure>
<h2 id="v-show指令"><a class="markdownIt-Anchor" href="#v-show指令"></a> v-show指令</h2>
<p>控制显示／隐藏，true／false</p>
<ul>
<li>和v-if指令不同的是，使用v-show指令的元素始终会被渲染到HTML，它只是简单地为元素设置CSS的style属性</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 v-show=&quot;age &gt;= 25&quot;&gt;Age: &#123;&#123; age &#125;&#125;&lt;/h1&gt;</span><br></pre></td></tr></table></figure>
<h2 id="v-else指令"><a class="markdownIt-Anchor" href="#v-else指令"></a> v-else指令</h2>
<ul>
<li>可以用v-else指令为v-if或v-show添加一个“else块”</li>
<li>v-else元素必须立即跟在v-if或v-show元素的后面——否则它不能被识别</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 v-show=&quot;name.indexOf(&apos;keep&apos;) &gt;= 0&quot;&gt;Name: &#123;&#123; name &#125;&#125;&lt;/h1&gt;</span><br><span class="line">&lt;h1 v-else&gt;Sex: &#123;&#123; sex &#125;&#125;&lt;/h1&gt;</span><br></pre></td></tr></table></figure>
<h2 id="v-for指令"><a class="markdownIt-Anchor" href="#v-for指令"></a> v-for指令</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li v-for=&quot;value in json&quot;&gt;</span><br><span class="line">        &#123;&#123;value&#125;&#125; &#123;&#123;$index&#125;&#125; &#123;&#123;$key&#125;&#125;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">     &lt;li v-for=&quot;(k,v) in json&quot;&gt;</span><br><span class="line">        &#123;&#123;k&#125;&#125; &#123;&#123;v&#125;&#125; &#123;&#123;$index&#125;&#125; &#123;&#123;$key&#125;&#125;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>
<h2 id="v-bind指令"><a class="markdownIt-Anchor" href="#v-bind指令"></a> v-bind指令</h2>
<ul>
<li>如果属性中要绑定Vue数据，最好用绑定的方式</li>
<li>v-bind指令可以在其名称后面带一个参数，中间放一个冒号隔开，这个参数通常是HTML元素的特性（attribute）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img v-bind:src=&quot;&#123;&#123;url&#125;&#125; alt=&quot;&quot;/&gt;&quot;//后台不会报错误，不绑定后台会报错，界面不影响</span><br></pre></td></tr></table></figure>
<ul>
<li>class</li>
</ul>
<p>用法一：其值为数组形式，数组中的值为Vue的data中定义的属性，而vue中属性对应的值为真正的css样式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.astyle&#123; color:red&#125;</span><br><span class="line">.bstyle&#123; background-color:bule&#125;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    new Vue()&#123;</span><br><span class="line">        data:&#123;</span><br><span class="line">            a:&quot;astyle&quot;,</span><br><span class="line">            b:&quot;bstyle&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;div id=&quot;box&quot;&gt;</span><br><span class="line">    &lt;strong :class=&quot;[a,b]&quot;&gt;测试文字&lt;/strong&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>方式二：其值为json格式，json的key为真正的css样式名称，value为true/false／data中的属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;box&quot;&gt;</span><br><span class="line">    &lt;strong :class=&quot;&#123;astyle:true,bstyle:a&#125;&quot;&gt;测试文字&lt;/strong&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>方式三：class的值直接是data的一个json数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">new Vue()&#123;</span><br><span class="line">    data:&#123;</span><br><span class="line">       jsonData:&#123;</span><br><span class="line">            astyle:true,</span><br><span class="line">            bstyle:false</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;div id=&quot;box&quot;&gt;</span><br><span class="line">    &lt;strong :class=&quot;jsonData&quot;&gt;测试文字&lt;/strong&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>style：复合样式采用的是驼峰命名法</li>
</ul>
<p>方法一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;strong :style=&quot;color:red&quot;&gt;文字&lt;/strong&gt;</span><br></pre></td></tr></table></figure>
<p>方式二：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">new Vue()&#123;</span><br><span class="line">    data:&#123;</span><br><span class="line">        astyle:&#123;color:&apos;red&apos;&#125;,</span><br><span class="line">        bstyle:&#123;backgroudColor:&apos;blue&apos;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;div id=&quot;box&quot;&gt;</span><br><span class="line">    &lt;strong :style=&quot;[astyle,bstyle]]&quot;&gt;测试文字&lt;/strong&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>方式三：官方推荐</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">new Vue()&#123;</span><br><span class="line">    data:&#123;</span><br><span class="line">        jsonData:&#123;</span><br><span class="line">            color:&apos;red&apos;,</span><br><span class="line">            backgroudColor:&apos;blue&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;div id=&quot;box&quot;&gt;</span><br><span class="line">    &lt;strong :style=&quot;jsonData&quot;&gt;测试文字&lt;/strong&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<h2 id="v-on指令"><a class="markdownIt-Anchor" href="#v-on指令"></a> v-on指令</h2>
<p>用于监听DOM事件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">new Vue()&#123;</span><br><span class="line">    methods:&#123;</span><br><span class="line">        show:function()&#123;alert(124);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;input type=&quot;button&quot; value=&quot;弹框&quot; v-on:click=&quot;show()&quot;</span><br></pre></td></tr></table></figure>
<p>==知识点==：v-bind指令可以缩写为一个冒号，v-on指令可以缩写为@符号</p>
<h2 id="v-model"><a class="markdownIt-Anchor" href="#v-model"></a> v-model</h2>
<p>表单元素的双向绑定，它会根据控件类型自动选取正确的方法来更新元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model=&quot;message.trim&quot; placeholder=&quot;edit me&quot;&gt;</span><br><span class="line">&lt;p&gt;Message is: &#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>.number:将用户的输入值转为 Number 类型（如果原值的转换结果为 NaN 则返回原值）,如：<input v-model.number="age" type="number"></li>
<li>.trim：自动过滤用户输入的首尾空格</li>
<li>.lazy：在默认情况下， v-model 在 input 事件中同步输入框的值与数据 ，但可以添加一个修饰符 lazy ，从而转变为在 change 事件中同步</li>
</ul>
<h1 id="事件"><a class="markdownIt-Anchor" href="#事件"></a> 事件</h1>
<h2 id="事件修饰符"><a class="markdownIt-Anchor" href="#事件修饰符"></a> 事件修饰符</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 阻止单击事件冒泡 --&gt;</span><br><span class="line">&lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;</span><br><span class="line">&lt;!-- 提交事件不再重载页面 --&gt;</span><br><span class="line">&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;</span><br><span class="line">&lt;!-- 修饰符可以串联  --&gt;</span><br><span class="line">&lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;</span><br><span class="line">&lt;!-- 只有修饰符 --&gt;</span><br><span class="line">&lt;form v-on:submit.prevent&gt;&lt;/form&gt;</span><br><span class="line">&lt;!-- 添加事件侦听器时使用事件捕获模式 --&gt;</span><br><span class="line">&lt;div v-on:click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt;</span><br><span class="line">&lt;!-- 只当事件在该元素本身（而不是子元素）触发时触发回调 --&gt;</span><br><span class="line">&lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<h3 id="事件冒泡阻止"><a class="markdownIt-Anchor" href="#事件冒泡阻止"></a> 事件冒泡阻止</h3>
<ol>
<li>传递事件$event，ev.cancleBubble=true;</li>
<li>@click.stop</li>
</ol>
<h3 id="默认行为"><a class="markdownIt-Anchor" href="#默认行为"></a> 默认行为</h3>
<p>如网页中添加了右键事件后，系统还有默认右键事件</p>
<ol>
<li>传递事件$event，ev.preventDefault();</li>
<li>@contextmenu.prevent</li>
</ol>
<h3 id="键盘事件"><a class="markdownIt-Anchor" href="#键盘事件"></a> 键盘事件</h3>
<ol>
<li>传递事件$event，ev.keyCode，判断后进行操作</li>
<li>@keyup.键值，如：@keyup.13</li>
<li>@keyup.键盘键面值，如：@keyup.enter</li>
</ol>
<h2 id="按键修饰符"><a class="markdownIt-Anchor" href="#按键修饰符"></a> 按键修饰符</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-on:keyup.13=&quot;submit&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>全部的按键别名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.enter</span><br><span class="line">.tab</span><br><span class="line">.delete (捕获 “删除” 和 “退格” 键)</span><br><span class="line">.esc</span><br><span class="line">.space</span><br><span class="line">.up</span><br><span class="line">.down</span><br><span class="line">.left</span><br><span class="line">.right</span><br></pre></td></tr></table></figure>
<h1 id="模版语法"><a class="markdownIt-Anchor" href="#模版语法"></a> 模版语法</h1>
<p>msg类似为js变量,Mustache中可以进行JS编程，如申明变量，条件判断等</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 数据绑定最常见的形式就是使用 “Mustache” 语法（双大括号）的文本插值：&#123;&#123;msg&#125;&#125; 数据更新模版变化</span><br><span class="line">* &#123;&#123;*msg&#125;&#125; 只绑定一次</span><br><span class="line">* &#123;&#123;&#123;msg&#125;&#125;&#125;  HTML转义，html语法会翻译</span><br></pre></td></tr></table></figure>
<h1 id="计算属性"><a class="markdownIt-Anchor" href="#计算属性"></a> 计算属性</h1>
<ul>
<li>在模板中放入太多的逻辑会让模板过重且难以维护，应当考虑使用计算属性</li>
<li>可以像绑定普通属性一样在模板中绑定计算属性</li>
<li>计算属性是基于它们的依赖进行缓存的。计算属性只有在它的相关依赖发生改变时才会重新求值,==这也是计算属性和methods的区别，需依据具体情况使用==</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;example&quot;&gt;</span><br><span class="line">  &lt;p&gt;Original message: &quot;&#123;&#123; message &#125;&#125;&quot;&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;Computed reversed message: &quot;&#123;&#123; reversedMessage &#125;&#125;&quot;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  el: &apos;#example&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: &apos;Hello&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    // a computed getter</span><br><span class="line">    reversedMessage: function () &#123;</span><br><span class="line">      // `this` points to the vm instance</span><br><span class="line">      return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>计算属性默认只有 getter ，不过在需要时你也可以提供一个 setter</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  fullName: &#123;</span><br><span class="line">    // getter</span><br><span class="line">    get: function () &#123;</span><br><span class="line">      return this.firstName + &apos; &apos; + this.lastName</span><br><span class="line">    &#125;,</span><br><span class="line">    // setter</span><br><span class="line">    set: function (newValue) &#123;</span><br><span class="line">      var names = newValue.split(&apos; &apos;)</span><br><span class="line">      this.firstName = names[0]</span><br><span class="line">      this.lastName = names[names.length - 1]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">在运行 vm.fullName = &apos;John Doe&apos; 时， setter 会被调用</span><br></pre></td></tr></table></figure>
<h1 id="过滤器"><a class="markdownIt-Anchor" href="#过滤器"></a> 过滤器</h1>
<blockquote>
<p>过滤模版数据</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;msg|filterA 参数|filterB 参数|...&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>系统默认提供过滤器，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">* &#123;&#123;&apos;welcome&apos;|uppercase&#125;&#125;</span><br><span class="line">* &#123;&#123;&apos;welcome&apos;|lowercase&#125;&#125;</span><br><span class="line">* &#123;&#123;&apos;welcome&apos;|capitalize&#125;&#125;</span><br><span class="line">* &#123;&#123;&apos;welcome&apos;|currency&#125;&#125;</span><br><span class="line">* &#123;&#123;&apos;welcome&apos;|currency &quot;$&quot;&#125;&#125;    //传参</span><br><span class="line">* &#123;&#123; message | filterA(&apos;arg1&apos;, arg2) &#125;&#125;  //穿参</span><br></pre></td></tr></table></figure>
<h1 id="交互"><a class="markdownIt-Anchor" href="#交互"></a> 交互</h1>
<p>Vue本身不支持Ajax框架，需引入官方库vue-resource,支持get、post、jsonp</p>
<ul>
<li>get</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">    getFun:function()&#123;</span><br><span class="line">        this.$http.get(&quot;a.txt&quot;).then(function(res)&#123;</span><br><span class="line">            console.log(res.data);</span><br><span class="line">        &#125;,function(res)&#123;</span><br><span class="line">            console.log(res.status);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    //传递参数</span><br><span class="line">    get2Fun:function()&#123;</span><br><span class="line">        this.$http.get(&quot;a.php&quot;,&#123;a:1,b:2&#125;&#125;).then(function(res)&#123;</span><br><span class="line">            console.log(res.data);</span><br><span class="line">        &#125;,function(res)&#123;</span><br><span class="line">            console.log(res.status);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>post</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">    postFun:function()&#123;</span><br><span class="line">        this.$http.post(&quot;a.php&quot;,&#123;a:1,b:2&#125;,&#123;emulateJSON:true&#125;).then(function(res)&#123;</span><br><span class="line">            console.log(res.data);</span><br><span class="line">        &#125;,function(res)&#123;</span><br><span class="line">            console.log(res.status);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>jsonp</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">    postFun:function()&#123;</span><br><span class="line">        this.$http.jsonp(</span><br><span class="line">            &quot;https://www.baidu....&quot;,</span><br><span class="line">            &#123;a:1&#125;,</span><br><span class="line">            &#123;jsonp:&apos;&apos;cb&apos;&apos;&#125;//callback 名字</span><br><span class="line">        )</span><br><span class="line">        .then(function(res)&#123;</span><br><span class="line">                console.log(res.data);</span><br><span class="line">            &#125;,function(res)&#123;</span><br><span class="line">                console.log(res.status);</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="组件"><a class="markdownIt-Anchor" href="#组件"></a> 组件</h1>
<h2 id="使用组件"><a class="markdownIt-Anchor" href="#使用组件"></a> 使用组件</h2>
<ul>
<li>要注册一个全局组件，你可以使用 Vue.component(tagName, options)。 例如：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;my-component&apos;, &#123;</span><br><span class="line">  // 选项</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>Vue.js建议自定义标签名：==小写，并且包含一个短杠==</li>
<li>要确保在初始化根实例 之前 注册了组件</li>
<li>局部注册</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var Child = &#123;</span><br><span class="line">  template: &apos;&lt;div&gt;A custom component!&lt;/div&gt;&apos;</span><br><span class="line">&#125;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  // ...</span><br><span class="line">  components: &#123;</span><br><span class="line">    // &lt;my-component&gt; 将只在父模板可用</span><br><span class="line">    &apos;my-component&apos;: Child</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="组件通信"><a class="markdownIt-Anchor" href="#组件通信"></a> 组件通信</h2>
<p>在 Vue.js 中，父子组件的关系可以总结为 props down, events up 。父组件通过 props 向下传递数据给子组件，子组件通过 events 给父组件发送消息</p>
<h3 id="prop"><a class="markdownIt-Anchor" href="#prop"></a> Prop</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;child&apos;, &#123;</span><br><span class="line">  // 声明 props</span><br><span class="line">  props: [&apos;myMessage&apos;],</span><br><span class="line">  // 就像 data 一样，prop 可以用在模板内</span><br><span class="line">  // 同样也可以在 vm 实例中像 “this.myMessage” 这样使用</span><br><span class="line">  template: &apos;&lt;span&gt;&#123;&#123; myMessage &#125;&#125;&lt;/span&gt;&apos;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&lt;child my-message=&quot;hello!&quot;&gt;&lt;/child&gt;   //传入属性值</span><br></pre></td></tr></table></figure>
<ul>
<li>HTML 特性是不区分大小写的。所以，当使用的不是字符串模版，camelCased (驼峰式) 命名的 prop 需要转换为相对应的 kebab-case (短横线隔开式) 命名</li>
<li>每次父组件更新时，子组件的所有 prop 都会更新为最新值,不应该在子组件内部改变 prop,如果有改变的需要，可通过A.定义一个局部变量;B.定义一个计算属性</li>
</ul>
<p>Prop验证</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;example&apos;, &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    // 基础类型检测 （`null` 意思是任何类型都可以）</span><br><span class="line">    propA: Number,</span><br><span class="line">    // 多种类型</span><br><span class="line">    propB: [String, Number],</span><br><span class="line">    // 必传且是字符串</span><br><span class="line">    propC: &#123;</span><br><span class="line">      type: String,</span><br><span class="line">      required: true</span><br><span class="line">    &#125;,</span><br><span class="line">    // 数字，有默认值</span><br><span class="line">    propD: &#123;</span><br><span class="line">      type: Number,</span><br><span class="line">      default: 100</span><br><span class="line">    &#125;,</span><br><span class="line">    // 数组／对象的默认值应当由一个工厂函数返回</span><br><span class="line">    propE: &#123;</span><br><span class="line">      type: Object,</span><br><span class="line">      default: function () &#123;</span><br><span class="line">        return &#123; message: &apos;hello&apos; &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 自定义验证函数</span><br><span class="line">    propF: &#123;</span><br><span class="line">      validator: function (value) &#123;</span><br><span class="line">        return value &gt; 10</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>type 可以：String/Number/Boolean/Function/Object/Array</p>
<h3 id="自定义事件"><a class="markdownIt-Anchor" href="#自定义事件"></a> 自定义事件</h3>
<p>每个 Vue 实例都实现了事件接口(Events interface)，即：</p>
<ul>
<li>使用 $on(eventName) 监听事件</li>
<li>使用 $emit(eventName) 触发事件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;counter-event-example&quot;&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123; total &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;button-counter v-on:increment=&quot;incrementTotal&quot;&gt;&lt;/button-counter&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">Vue.component(&apos;button-counter&apos;, &#123;</span><br><span class="line">  template: &apos;&lt;button v-on:click=&quot;increment&quot;&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;&apos;,</span><br><span class="line">  data: function () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      counter: 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    increment: function () &#123;</span><br><span class="line">      this.counter += 1</span><br><span class="line">      this.$emit(&apos;increment&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &apos;#counter-event-example&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    total: 0</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    incrementTotal: function () &#123;</span><br><span class="line">      this.total += 1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="非父子组件通信"><a class="markdownIt-Anchor" href="#非父子组件通信"></a> 非父子组件通信</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var bus = new Vue()</span><br><span class="line">// 触发组件 A 中的事件</span><br><span class="line">bus.$emit(&apos;id-selected&apos;, 1)</span><br><span class="line">// 在组件 B 创建的钩子中监听事件</span><br><span class="line">bus.$on(&apos;id-selected&apos;, function (id) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="使用slot分发内容"><a class="markdownIt-Anchor" href="#使用slot分发内容"></a> 使用Slot分发内容</h2>
<ul>
<li>为了让组件可以组合，我们需要一种方式来混合父组件的内容与子组件自己的模板，这个过程被称为 内容分发</li>
<li>使用特殊的 <slot> 元素作为原始内容的插槽</slot></li>
<li>父组件模板的内容在父组件作用域内编译；子组件模板的内容在子组件作用域内编译</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 无效,试图在父组件模板内将一个指令绑定到子组件的属性/方法 --&gt;</span><br><span class="line">&lt;child-component v-show=&quot;someChildProperty&quot;&gt;&lt;/child-component&gt;</span><br></pre></td></tr></table></figure>
<p>如果要绑定作用域内的指令到一个组件的根节点，你应当在组件自己的模板上做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;child-component&apos;, &#123;</span><br><span class="line">  // 有效，因为是在正确的作用域内</span><br><span class="line">  template: &apos;&lt;div v-show=&quot;someChildProperty&quot;&gt;Child&lt;/div&gt;&apos;,</span><br><span class="line">  data: function () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      someChildProperty: true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    <div>
          
    </div>

    

    <div>
      
    </div>


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://chetaofeng.github.io/2018/10/26/前端开发-webpack入门/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="行锋">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/pub-images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="行锋">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/26/前端开发-webpack入门/" itemprop="url">webpack入门</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-26T16:04:30+08:00">
                2018-10-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[toc]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://webpack.org/</span><br><span class="line">https://github.com/webpack-china/webpack.js.org</span><br><span class="line">http://www.css88.com/doc/webpack2/</span><br></pre></td></tr></table></figure>
<h1 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h1>
<p><img src="http://note.youdao.com/yws/api/personal/file/WEB7518457dae5c37c455088010c54f1e6c?method=download&amp;shareKey=13db111168a449f1c1833f09e42da606" alt="image"><br>
Webpack 是当下最热门的前端资源模块化管理和打包工具。它可以将许多松散的模块按照依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分隔，等到实际需要的时候再异步加载。通过 loader 的转换，任何形式的资源都可以视作模块，比如 CommonJs 模块、 AMD 模块、 ES6 模块、CSS、图片、 JSON、Coffeescript、 LESS 等。</p>
<p>前身叫browserify，缺点为只能转换js</p>
<h1 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h1>
<h2 id="入口entry"><a class="markdownIt-Anchor" href="#入口entry"></a> 入口(Entry)</h2>
<ul>
<li>webpack 将创建所有应用程序的依赖关系图表(dependency graph)。图表的起点被称之为入口起点(entry point)</li>
<li>入口起点告诉 webpack 从哪里开始，并遵循着依赖关系图表知道要打包什么</li>
<li>可以将应用程序的入口起点认为是根上下文(contextual root)或 app 第一个启动文件</li>
</ul>
<h2 id="出口output"><a class="markdownIt-Anchor" href="#出口output"></a> 出口(Output)</h2>
<ul>
<li>将所有的资源(assets)归拢在一起后，我们还需要告诉 webpack 在哪里打包我们的应用程序。webpack 的 output 属性描述了如何处理归拢在一起的代码(bundled code)</li>
<li>即使可以存在多个入口起点，但只指定一个输出配置</li>
<li>更多配置：<a href="http://www.css88.com/doc/webpack2/concepts/output/" target="_blank" rel="noopener">http://www.css88.com/doc/webpack2/concepts/output/</a></li>
</ul>
<h2 id="加载器loader"><a class="markdownIt-Anchor" href="#加载器loader"></a> 加载器(Loader)</h2>
<ul>
<li>webpack 的目标是，让 webpack 聚焦于项目中的所有资源(asset)，而浏览器不需要关注考虑这些（这并不意味着资源(asset)都必须打包在一起）。webpack 把每个文件(.css, .html, .scss, .jpg, etc.) 都作为模块处理。而且 webpack 只理解 JavaScript</li>
<li>webpack loader 会将这些文件转换为模块，而转换后的文件会被添加到依赖图表中</li>
<li>在 webpack 配置中定义 loader 时，要定义在 module.rules 中，而不是 rules</li>
<li>webparck默认加载的是js，如果要加载如css，需要额外loader</li>
</ul>
<ol>
<li>npm install style-loader css-loader -D</li>
<li>在webpack中，多个loader加载通过！连接，后面的“-loader可以省略”，如：require(“style!css!./mystyle.css”)</li>
</ol>
<h2 id="插件plugins"><a class="markdownIt-Anchor" href="#插件plugins"></a> 插件(Plugins)</h2>
<p>想要使用一个插件，</p>
<ol>
<li>需要 require() 它，</li>
<li>它添加到 plugins 数组中</li>
<li>多数插件可以通过选项(option)自定义</li>
<li>由于需要在一个配置中，多次使用一个插件，来针对不同的目的，因此你需要使用 new 来创建插件的实例，并且通过实例来调用插件</li>
</ol>
<p>webpack 插件是一个具有 apply 属性的 JavaScript 对象。 apply 属性会被 webpack compiler 调用，并且 compiler 对象可在整个 compilation 生命周期访问</p>
<p>webpack.config.js示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;); //installed via npm</span><br><span class="line">const webpack = require(&apos;webpack&apos;); //to access built-in plugins</span><br><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line"></span><br><span class="line">const config = &#123;</span><br><span class="line">  entry: &apos;./path/to/my/entry/file.js&apos;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, &apos;dist&apos;),</span><br><span class="line">    filename: &apos;my-first-webpack.bundle.js&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;test: /\.(js|jsx)$/, use: &apos;babel-loader&apos;&#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new webpack.optimize.UglifyJsPlugin(),</span><br><span class="line">    new HtmlWebpackPlugin(&#123;template: &apos;./src/index.html&apos;&#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module.exports = config;</span><br></pre></td></tr></table></figure>
<h1 id="webpack安装及起步"><a class="markdownIt-Anchor" href="#webpack安装及起步"></a> webpack安装及起步</h1>
<h2 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h2>
<ul>
<li>cnpm install webpack-cli -g//webpack的cli环境</li>
<li>cnpm install webpack-dev-server //webpack的自带服务器</li>
</ul>
<p>运行：</p>
<ol>
<li>开发环境：webpack</li>
<li>生产环境：webpack -p //会压缩</li>
<li>监听模式：webpack -w //自动编译</li>
<li>开启sourcemaps：webpack -d //方便调试</li>
</ol>
<h2 id="起步"><a class="markdownIt-Anchor" href="#起步"></a> 起步</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir webpack-demo &amp;&amp; cd webpack-demo</span><br><span class="line">npm init -y</span><br><span class="line">npm install --save-dev webpack</span><br></pre></td></tr></table></figure>
<p>创建并编辑app/index.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import _ from &apos;lodash&apos;;</span><br><span class="line"></span><br><span class="line">function component () &#123;</span><br><span class="line">  var element = document.createElement(&apos;div&apos;);</span><br><span class="line"></span><br><span class="line">  /* 需要引入 lodash，下一行才能正常工作 */</span><br><span class="line">  element.innerHTML = _.join([&apos;Hello&apos;,&apos;webpack&apos;], &apos; &apos;);</span><br><span class="line"></span><br><span class="line">  return element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">document.body.appendChild(component());</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save lodash</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;webpack 2 demo&lt;/title&gt; </span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt; </span><br><span class="line">       &lt;script src=&quot;dist/bundle.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">webpack</span><br><span class="line">查看浏览器index.html页面内容：Hello webpack</span><br></pre></td></tr></table></figure>
<p>#代码拆分<br>
分离资源，实现缓存资源和并行加载资源:</p>
<ul>
<li>一个典型的应用程序，会依赖于许多提供框架/功能需求的第三方库代码。不同于应用程序代码，这些第三方库代码不会频繁修改</li>
<li>如果我们将这些库(library)中的代码，保留到与应用程序代码相独立的 bundle 上，我们就可以利用浏览器缓存机制，把这些文件长时间的缓存到用户的机器上</li>
</ul>
<h2 id="css分割"><a class="markdownIt-Anchor" href="#css分割"></a> CSS分割</h2>
<p>要通过webpack打包CSS，像任何其他模块一样将CSS导入JavaScript代码，并使用css-loader（它输出CSS作为JS模块），并可选地应用ExtractTextWebpackPlugin（它提取打包的CSS并输出CSS文件</p>
<ol>
<li>导入 CSS</li>
</ol>
<ul>
<li>import ‘bootstrap/dist/css/bootstrap.css’;</li>
</ul>
<ol start="2">
<li>使用 css-loader:webpack.config.js中配置 css-loader</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [&#123;</span><br><span class="line">            test: /\.css$/,</span><br><span class="line">            use: &apos;css-loader&apos;</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>使用 ExtractTextWebpackPlugin</li>
</ol>
<ul>
<li>npm install --save-dev extract-text-webpack-plugin</li>
</ul>
<ol start="4">
<li>webpack.config.js中添加插件配置</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    module: &#123;</span><br><span class="line">         rules: [&#123;</span><br><span class="line">             test: /\.css$/,</span><br><span class="line">-            use: &apos;css-loader&apos;</span><br><span class="line">+            use: ExtractTextPlugin.extract(&#123;</span><br><span class="line">+                use: &apos;css-loader&apos;</span><br><span class="line">+            &#125;)</span><br><span class="line">         &#125;]</span><br><span class="line">     &#125;,</span><br><span class="line">+    plugins: [</span><br><span class="line">+        new ExtractTextPlugin(&apos;styles.css&apos;),</span><br><span class="line">+    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="libraries分割"><a class="markdownIt-Anchor" href="#libraries分割"></a> Libraries分割</h2>
<p>默认会将库文件打包，可通过为库，如moment 添加一个单独的入口点并将其命名为 vendor 来缓解这一情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var path = require(&apos;path&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = function(env) &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        entry: &#123;</span><br><span class="line">            main: &apos;./index.js&apos;,</span><br><span class="line">            vendor: &apos;moment&apos;</span><br><span class="line">        &#125;,</span><br><span class="line">        output: &#123;</span><br><span class="line">            filename: &apos;[chunkhash].[name].js&apos;,</span><br><span class="line">            path: path.resolve(__dirname, &apos;dist&apos;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行webpakc生成了两个 bundle，都包含lodash，所以还需要插件</p>
<ul>
<li>CommonsChunkPlugin：它从根本上允许我们从不同的 bundle 中提取所有的公共模块，并且将他们加入公共 bundle 中。如果公共 bundle 不存在，那么它将会创建一个出来</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var webpack = require(&apos;webpack&apos;);</span><br><span class="line">var path = require(&apos;path&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = function(env) &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        entry: &#123;</span><br><span class="line">            main: &apos;./index.js&apos;,</span><br><span class="line">            vendor: &apos;moment&apos;</span><br><span class="line">        &#125;,</span><br><span class="line">        output: &#123;</span><br><span class="line">            filename: &apos;[chunkhash].[name].js&apos;,</span><br><span class="line">            path: path.resolve(__dirname, &apos;dist&apos;)</span><br><span class="line">        &#125;,</span><br><span class="line">        plugins: [</span><br><span class="line">            new webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">                name: &apos;vendor&apos; // 指定公共 bundle 的名字。</span><br><span class="line">            &#125;)</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上完成之后，每次运行的vendor文件的hash码会改变，需在plugins配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">    new webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">        names: [&apos;vendor&apos;, &apos;manifest&apos;] // 指定公共 bundle 的名字</span><br><span class="line">    &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>将运行时代码提取到一个单独的 manifest 文件中就解决了</p>
<h2 id="生产环境构建"><a class="markdownIt-Anchor" href="#生产环境构建"></a> 生产环境构建</h2>
<ol>
<li>自动方式</li>
</ol>
<ul>
<li>运行webpack -p (也可以运行 webpack --optimize-minimize --define process.env.NODE_ENV=&quot;‘production’&quot;, 他们是等效的). 它会执行如下步骤:</li>
</ul>
<ul>
<li>
<ul>
<li>使用UglifyJsPlugin进行 JS文件压缩</li>
</ul>
</li>
<li>
<ul>
<li>运行LoaderOptionsPlugin</li>
</ul>
</li>
<li>
<ul>
<li>设置Node环境变量</li>
</ul>
</li>
</ul>
<ol start="2">
<li>手动方式: 为多环境配置Webpack<br>
编写一个基本配置文件,把所有公用的功能放在里面。再编写特定环境的文件,使用’webpack-merge’来合并他们</li>
</ol>
<p>base.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">module.exports = function() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        entry: &#123; </span><br><span class="line">            &apos;vendor&apos;: &apos;./src/vendor.ts&apos;,</span><br><span class="line">            &apos;main&apos;: &apos;./src/main.ts&apos;</span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line">        output: &#123;</span><br><span class="line">            path: path.join(__dirname, &apos;/../dist/assets&apos;),</span><br><span class="line">            filename: &apos;[name].bundle.js&apos;,</span><br><span class="line">            publicPath: publicPath,</span><br><span class="line">            sourceMapFilename: &apos;[name].map&apos;</span><br><span class="line">        &#125;,</span><br><span class="line">        resolve: &#123;</span><br><span class="line">            extensions: [&apos;&apos;, &apos;.js&apos;, &apos;.json&apos;],</span><br><span class="line">            modules: [path.join(__dirname, &apos;src&apos;), &apos;node_modules&apos;]</span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line">        module: &#123;</span><br><span class="line">            loaders: [&#123;</span><br><span class="line">                test: /\.css$/,</span><br><span class="line">                loaders: [&apos;to-string-loader&apos;, &apos;css-loader&apos;]</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                test: /\.(jpg|png|gif)$/,</span><br><span class="line">                loader: &apos;file-loader&apos;</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                test: /\.(woff|woff2|eot|ttf|svg)$/,</span><br><span class="line">                loader: &apos;url-loader?limit=100000&apos;</span><br><span class="line">            &#125;],</span><br><span class="line">        &#125;,</span><br><span class="line">        plugins: [</span><br><span class="line">            new ForkCheckerPlugin(),</span><br><span class="line"></span><br><span class="line">            new webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">                name: [&apos;polyfills&apos;, &apos;vendor&apos;].reverse()</span><br><span class="line">            &#125;),</span><br><span class="line">            new HtmlWebpackPlugin(&#123;</span><br><span class="line">                template: &apos;src/index.html&apos;,</span><br><span class="line">                chunksSortMode: &apos;dependency&apos;</span><br><span class="line">            &#125;)</span><br><span class="line">        ],</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用’webpack-merge’合并这个基础配置和针对环境的特定的配置</p>
<p>prod.js (updated)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">const webpackMerge = require(&apos;webpack-merge&apos;);</span><br><span class="line"></span><br><span class="line">const commonConfig = require(&apos;./base.js&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = function(env) &#123;</span><br><span class="line">    return webpackMerge(commonConfig(), &#123;</span><br><span class="line">        plugins: [</span><br><span class="line">            new webpack.LoaderOptionsPlugin(&#123;</span><br><span class="line">                minimize: true,</span><br><span class="line">                debug: false</span><br><span class="line">            &#125;),</span><br><span class="line">            new webpack.DefinePlugin(&#123;</span><br><span class="line">                &apos;process.env&apos;: &#123;</span><br><span class="line">                    &apos;NODE_ENV&apos;: JSON.stringify(&apos;prod&apos;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;),</span><br><span class="line">            new webpack.optimize.UglifyJsPlugin(&#123;</span><br><span class="line">                beautify: false,</span><br><span class="line">                mangle: &#123;</span><br><span class="line">                    screw_ie8: true,</span><br><span class="line">                    keep_fnames: true</span><br><span class="line">                &#125;,</span><br><span class="line">                compress: &#123;</span><br><span class="line">                    screw_ie8: true</span><br><span class="line">                &#125;,</span><br><span class="line">                comments: false</span><br><span class="line">            &#125;)</span><br><span class="line">        ]</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="缓存"><a class="markdownIt-Anchor" href="#缓存"></a> 缓存</h1>
<blockquote>
<p>这一块没有理解，需重新看<br>
为了能够长期缓存webpack生成的静态资源:</p>
</blockquote>
<ol>
<li>使用[chunkhash]向每个文件添加一个依赖于内容的缓存杀手(cache-buster)</li>
<li>将webpack mainfest提取到一个单独的文件中去</li>
<li>对于一组依赖关系相同的资源，确保包含引导代码的入口起点模块(entrychunk)不会随时间改变它的哈希值</li>
<li>当需要在HTML中加载资源时，使用编译器统计信息(compiler stats)来获取文件名</li>
<li>生成模块清单(chunk manifest)的JSON内容，并在页面资源加载之前内联进HTML中去</li>
</ol>
<ul>
<li>将开发和生产模式的配置分开，并在开发模式中使用[name].js的文件名， 在生产模式中使用[name].[chunkhash].js文件名</li>
<li>为了在HTML中引用正确的文件,因为有hash生存文件名的一部分，可以使用下面这个插件，从webpack编译统计中提取：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// webpack.config.js</span><br><span class="line">const path = require(&quot;path&quot;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123; </span><br><span class="line">  plugins: [</span><br><span class="line">    function() &#123;</span><br><span class="line">      this.plugin(&quot;done&quot;, function(stats) &#123;</span><br><span class="line">        require(&quot;fs&quot;).writeFileSync(</span><br><span class="line">          path.join(__dirname, &quot;build&quot;, &quot;stats.json&quot;),</span><br><span class="line">          JSON.stringify(stats.toJson()));</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>或者使用插件：<a href="https://www.npmjs.com/package/webpack-manifest-plugin" target="_blank" rel="noopener">https://www.npmjs.com/package/webpack-manifest-plugin</a></p>
<h1 id="开发"><a class="markdownIt-Anchor" href="#开发"></a> 开发</h1>
<h2 id="调整你的文本编辑器"><a class="markdownIt-Anchor" href="#调整你的文本编辑器"></a> 调整你的文本编辑器</h2>
<ul>
<li>一些文本编辑器有“safe write”（安全写入）功能，并且默认启用。因此，保存文件后并不总是会导致 webpack 重新编译</li>
<li>WebStorm - 在 Preferences &gt; Appearance &amp; Behavior &gt; System Settings 中取消选中 Use “safe write”</li>
</ul>
<h2 id="source-maps"><a class="markdownIt-Anchor" href="#source-maps"></a> Source Maps</h2>
<p>更多配置：<a href="http://www.css88.com/doc/webpack2/configuration/devtool/" target="_blank" rel="noopener">http://www.css88.com/doc/webpack2/configuration/devtool/</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">devtool:&apos;source-map&apos;</span><br></pre></td></tr></table></figure>
<h2 id="选择一个工具"><a class="markdownIt-Anchor" href="#选择一个工具"></a> 选择一个工具</h2>
<ul>
<li>webpack 可以在 watch mode(监视模式)下使用。在这种模式下，webpack 将监视您的文件，并在更改时重新编译</li>
<li>webpack-dev-server 提供了一个易于部署的开发服务器，具有快速的实时重载（live reloading）功能</li>
<li>如果你已经有一个开发服务器并且需要完全的灵活性，可以使用 webpack-dev-middleware 作为中间件</li>
</ul>
<h3 id="webpack-dev-server"><a class="markdownIt-Anchor" href="#webpack-dev-server"></a> webpack-dev-server</h3>
<ol>
<li>npm install webpack-dev-server --save-dev</li>
<li>webpack-dev-server --open</li>
</ol>
<h3 id="webpack-dev-middleware"><a class="markdownIt-Anchor" href="#webpack-dev-middleware"></a> webpack-dev-middleware</h3>
<p>webpack-dev-middleware 适用于基于链接的中间件环境（connect-based middleware stacks）。如果你已经有一个 Node.js 服务器或者你想要完全控制服务器，这将很实用</p>
<ol>
<li>npm install express webpack-dev-middleware --save-dev</li>
<li>使用</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var express = require(&quot;express&quot;);</span><br><span class="line">var webpackDevMiddleware = require(&quot;webpack-dev-middleware&quot;);</span><br><span class="line">var webpack = require(&quot;webpack&quot;);</span><br><span class="line">var webpackConfig = require(&quot;./webpack.config&quot;);</span><br><span class="line"></span><br><span class="line">var app = express();</span><br><span class="line">var compiler = webpack(webpackConfig);</span><br><span class="line"></span><br><span class="line">app.use(webpackDevMiddleware(compiler, &#123;</span><br><span class="line">  publicPath: &quot;/&quot; // 大部分情况下和 `output.publicPath`相同</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line">app.listen(3000, function () &#123;</span><br><span class="line">  console.log(&quot;Listening on port 3000!&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>根据你在 output.publicPath 和 output.filename 中设置的内容，你的 bundle 现在应该在 <a href="http://localhost:3000/bundle.js" target="_blank" rel="noopener">http://localhost:3000/bundle.js</a> 中可以看到了<br>
3. 默认情况下会使用watch mode。也可以使用 lazy mode，这使得 webpack 只在对入口点进行请求时再进行重新编译</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.use(webpackDevMiddleware(compiler, &#123;</span><br><span class="line">  lazy: true,</span><br><span class="line">  filename: &quot;bundle.js&quot; // Same as `output.filename` in most cases.</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>命令说明</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* webpack-dev-server  //默认8080</span><br><span class="line">* webpack-dev-server --port 8088</span><br><span class="line">* webpack-dev-server --inline //改变代码之后，自动刷新浏览器</span><br><span class="line">* webpack-dev-server --hot //热重载（局部更改）</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>此功能设置在webpack.config.js配置文件中如下：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">devServer:&#123;</span><br><span class="line">    port:8088,</span><br><span class="line">    inline:true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>也可以配置在package.json文件中，如：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;:&#123;</span><br><span class="line">    &quot;dev&quot;:&quot;webpack-dev-server --port 8088 --inline --hot&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ run npm dev</span><br></pre></td></tr></table></figure>
<ol start="7">
<li>resolve配置</li>
</ol>
<ul>
<li>配置扩展名,即代码中引用的时候可以省略后缀</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">resolve:&#123;</span><br><span class="line">    &quot;extensions&quot;:[&apos;&apos;,&apos;.js&apos;,&apos;.css&apos;,&apos;.json&apos;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="配合babel的使用"><a class="markdownIt-Anchor" href="#配合babel的使用"></a> 配合babel的使用</h2>
<p>以下为react配合webpack的各种依赖库：</p>
<ul>
<li>cnpm install babel-core -D</li>
<li>cnpm install babel-preset-es2015 --save-dev</li>
<li>cnpm install babel-loader -D</li>
</ul>
<p>设置js的转换</p>
<ol>
<li>通过weback.config.js设置</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">moudule:&#123;</span><br><span class="line">    loaders:[</span><br><span class="line">        &#123;</span><br><span class="line">            test:/\.js$/,</span><br><span class="line">            loader:&apos;babel&apos;,</span><br><span class="line">            exclude:/node_moudules/</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br><span class="line">babel:&#123;</span><br><span class="line">    &quot;presets&quot;:[&apos;es2015&apos;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>通过.babelrc文件，文件内容为：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;presets&quot;:[&quot;es2015&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="配合react使用"><a class="markdownIt-Anchor" href="#配合react使用"></a> 配合react使用</h2>
<p>前提：配合babel的配置已经安装</p>
<ul>
<li>cnpm install babel-preset-react -D //babel的react预设，babel可以给其他用，react是支持的一种</li>
<li>cnpm install react-hot-loader</li>
<li>设置预设.babelrc</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;presets&quot;:[</span><br><span class="line">        [&quot;es2015&quot;],</span><br><span class="line">        [&quot;react&quot;]</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>预设webpack.config</li>
</ul>

          
        
      
    </div>
    
    
    

    <div>
          
    </div>

    

    <div>
      
    </div>


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://chetaofeng.github.io/2018/10/26/前端开发-2018-10-26-CommonJS规范-AMD-CMD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="行锋">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/pub-images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="行锋">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/26/前端开发-2018-10-26-CommonJS规范-AMD-CMD/" itemprop="url">CommonJS规范&AMD&CMD</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-26T15:41:00+08:00">
                2018-10-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>浏览器端的js和服务器端js都主要做了哪些事</p>
</blockquote>
<table>
<thead>
<tr>
<th>服务器端JS</th>
<th>浏览器端JS</th>
</tr>
</thead>
<tbody>
<tr>
<td>相同的代码需要多次执行</td>
<td>代码需要从一个服务器端分发到多个客户端执行</td>
</tr>
<tr>
<td>CPU和内存资源是瓶颈</td>
<td>带宽是瓶颈</td>
</tr>
<tr>
<td>加载时从磁盘中加载</td>
<td>加载时需要通过网络加载</td>
</tr>
</tbody>
</table>
<blockquote>
<p>CommonJS是主要为了JS在==后端的表现制定==的，他是不适合前端的;AMD(异步模块定义)出现了，它就主要==为前端JS的表现制定规范==</p>
</blockquote>
<blockquote>
<p>CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。</p>
</blockquote>
<blockquote>
<p>AMD规范则是非同步加载模块，允许指定回调函数。</p>
</blockquote>
<blockquote>
<p>由于Node.js主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以CommonJS规范比较适用。但是，如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用AMD规范</p>
</blockquote>
<p>[toc]</p>
<h1 id="commonjs"><a class="markdownIt-Anchor" href="#commonjs"></a> CommonJS</h1>
<blockquote>
<p>CommonJS规范: <a href="http://javascript.ruanyifeng.com/nodejs/module.html" target="_blank" rel="noopener">http://javascript.ruanyifeng.com/nodejs/module.html</a></p>
</blockquote>
<blockquote>
<p>CommonJS模块的特点如下:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">所有代码都运行在模块作用域，不会污染全局作用域。</span><br><span class="line">模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。</span><br><span class="line">模块加载的顺序，按照其在代码中出现的顺序</span><br></pre></td></tr></table></figure>
<blockquote>
<p>CommonJS是一种规范，NodeJS是这种规范的实现</p>
</blockquote>
<blockquote>
<p>JavaScript是一个强大面向对象语言，它有很多快速高效的解释器。官方JavaScript标准定义的API是为了构建基于浏览器的应用程序。然而，并没有定于一个用于更广泛的应用程序的标准库。</p>
</blockquote>
<blockquote>
<p>CommonJS API定义很多普通应用程序（主要指非浏览器的应用）使用的API，从而填补了这个空白。它的终极目标是提供一个类似Python，Ruby和Java标准库。这样的话，开发者可以使用CommonJS API编写==应用程序==，然后这些应用可以运行在不同的JavaScript解释器和不同的主机环境中。</p>
</blockquote>
<p>CommonJS定义的模块分为:模块引用(require)；模块定义(exports)；模块标识(module)</p>
<h2 id="require"><a class="markdownIt-Anchor" href="#require"></a> require</h2>
<blockquote>
<p>require命令用于加载文件，后缀名默认为.js</p>
</blockquote>
<blockquote>
<p>每个模块中有一个自由变量require，它是一个方法，这个方法接受一个参数，即模块的唯一ID。</p>
</blockquote>
<blockquote>
<p>CommonJS模块的加载机制是，输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值</p>
</blockquote>
<blockquote>
<p>require根据外部模块ID，返回该模块输出的API。如果外部模块被required的时候还没有执行完，require至少应改返回该模块的exports（另一个自由变量）。如果必需的模块不存在，require方法应该抛出一个异常。</p>
</blockquote>
<blockquote>
<p>require可以有一个main属性，属性值要么为undefined，要么等于module（另一个自由变量）;可以用来判断模块是直接执行，还是被调用执行。直接执行的时候（node module.js），require.main属性指向模块本身;调用执行的时候（通过require加载该脚本执行），==require.main === module== 返回false</p>
</blockquote>
<blockquote>
<p>require可以有一个paths属性，属性值为由路径字符串组成的数组，路径按优先级从高到低的顺序排列</p>
</blockquote>
<p>根据参数的不同格式，require命令去不同路径寻找模块文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">* 如果参数字符串以“/”开头，则表示加载的是一个位于绝对路径的模块文</span><br><span class="line">* 如果参数字符串以“./”开头，则表示加载的是一个位于相对路径的模块文件</span><br><span class="line">* 如果参数字符串不以“./“或”/“开头，则表示加载的是一个默认提供的核心模块或者一个位于各级node_modules目录的已安装模块</span><br><span class="line">* 如果参数字符串不以“./“或”/“开头，而且是一个路径如果参数字符串不以“./“或”/“开头，而且是一个路径，比如require(&apos;example-module/path/to/file&apos;)，则将先找到example-module的位置，然后再以它为参数，找到后续路径。</span><br><span class="line">* 如果指定的模块文件没有发现，Node会尝试为文件名添加.js、.json、.node后，再去搜索</span><br><span class="line">* 如果想得到require命令加载的确切文件名，使用require.resolve()方法</span><br></pre></td></tr></table></figure>
<h2 id="exports"><a class="markdownIt-Anchor" href="#exports"></a> exports</h2>
<p>每个模块中还有一个自由变量exports，它是一个对象，==模块对外输出的API就绑定在这个对象上==。而且==exports是模块对外输出API的唯一途径==。Node为每个模块提供一个exports变量，指向module.exports</p>
<blockquote>
<p>不能直接将exports变量指向一个值，因为这样等于切断了exports与module.exports的联系</p>
</blockquote>
<h2 id="module"><a class="markdownIt-Anchor" href="#module"></a> module</h2>
<p>CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。==加载某个模块，其实是加载该模块的module.exports属性==</p>
<blockquote>
<p>每个模块中必须有一个自由变量module，它是对象。这个对象有一个id属性，表示该模块的id，同时应该是只读属性。</p>
</blockquote>
<blockquote>
<p>module对象可以有一个uri属性，表示这个模块被加载的来源。</p>
</blockquote>
<p>每个模块内部，都有一个module对象，代表当前模块。它有以下属性:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">module.id 模块的识别符，通常是带有绝对路径的模块文件名。</span><br><span class="line">module.filename 模块的文件名，带有绝对路径。</span><br><span class="line">module.loaded 返回一个布尔值，表示模块是否已经完成加载。</span><br><span class="line">module.parent 返回一个对象，表示调用该模块的模块。</span><br><span class="line">module.children 返回一个数组，表示该模块要用到的其他模块。</span><br><span class="line">module.exports 表示模块对外输出的值</span><br></pre></td></tr></table></figure>
<h2 id="目录的加载规则"><a class="markdownIt-Anchor" href="#目录的加载规则"></a> 目录的加载规则</h2>
<blockquote>
<p>通常，我们会把相关的文件会放在一个目录里面，便于组织。这时，最好为该目录设置一个入口文件，让require方法可以通过这个入口文件，加载整个目录</p>
</blockquote>
<blockquote>
<p>在目录中放置一个package.json文件，并且将入口文件写入main字段</p>
</blockquote>
<blockquote>
<p>如果package.json文件没有main字段，或者根本就没有package.json文件，则会加载该目录下的index.js文件或index.node文件</p>
</blockquote>
<h2 id="模块的缓存"><a class="markdownIt-Anchor" href="#模块的缓存"></a> 模块的缓存</h2>
<blockquote>
<p>第一次加载某个模块时，Node会缓存该模块。以后再加载该模块，就直接从缓存取出该模块的module.exports属性</p>
</blockquote>
<blockquote>
<p>所有缓存的模块保存在require.cache之中，如果想删除模块的缓存，可以像下面这样写</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 删除指定模块的缓存</span><br><span class="line">delete require.cache[moduleName];</span><br><span class="line"></span><br><span class="line">// 删除所有模块的缓存</span><br><span class="line">Object.keys(require.cache).forEach(function(key) &#123;</span><br><span class="line">  delete require.cache[key];</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="amd"><a class="markdownIt-Anchor" href="#amd"></a> AMD</h1>
<blockquote>
<p>AMD就只有一个接口：define(id?,dependencies?,factory);</p>
</blockquote>
<blockquote>
<p>RequireJS就是实现了AMD规范</p>
</blockquote>
<h1 id="cmd"><a class="markdownIt-Anchor" href="#cmd"></a> CMD</h1>
<blockquote>
<p>大名远扬的玉伯写了seajs，就是遵循他提出的CMD规范，与AMD蛮相近的，不过用起来感觉更加方便些，最重要的是中文版</p>
</blockquote>

          
        
      
    </div>
    
    
    

    <div>
          
    </div>

    

    <div>
      
    </div>


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://chetaofeng.github.io/2018/10/26/react-rn-2018-10-26-middleware/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="行锋">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/pub-images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="行锋">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/26/react-rn-2018-10-26-middleware/" itemprop="url">middleware</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-26T15:32:09+08:00">
                2018-10-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/React/" itemprop="url" rel="index">
                    <span itemprop="name">React</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://zhuanlan.zhihu.com/p/20597452" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/20597452</a></p>
<h1 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h1>
<ul>
<li>middleware 提供了一个分类处理 action 的机会，在 middleware 中你可以检阅每一个流过的 action，挑选出特定类型的 action 进行相应操作，给你一次改变 action 的机会</li>
<li>redux 的 middleware 是为了增强 dispatch 而出现的</li>
<li>redux 提供了 applyMiddleware 这个 api 来加载 middleware</li>
</ul>
<p><img src="/pub-images/redux-middleware1.png" alt="image"><br>
<img src="/pub-images/redux-middleware2.png" alt="image"></p>
<h1 id="四步理解-middleware-机制"><a class="markdownIt-Anchor" href="#四步理解-middleware-机制"></a> 四步理解 middleware 机制</h1>
<p><img src="/pub-images/middleware%E6%9C%BA%E5%88%B6%E7%A4%BA%E4%BE%8B.png" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var middlewareAPI = &#123;</span><br><span class="line">  getState: store.getState,</span><br><span class="line">  dispatch: (action) =&gt; dispatch(action)</span><br><span class="line">&#125;;</span><br><span class="line">chain = middlewares.map(middleware =&gt; middleware(middlewareAPI));</span><br></pre></td></tr></table></figure>
<h2 id="函数式编程思想设计-middleware"><a class="markdownIt-Anchor" href="#函数式编程思想设计-middleware"></a> 函数式编程思想设计 middleware</h2>
<p>middleware 的设计有点特殊，是一个层层包裹的匿名函数，这其实是函数式编程中的柯里化 curry，一种使用匿名单参数函数来实现多参数函数的方法。applyMiddleware 会对 logger 这个 middleware 进行层层调用，动态地对 store 和 next 参数赋值</p>
<p>柯里化的 middleware 结构好处在于：</p>
<ol>
<li>易串联，柯里化函数具有延迟执行的特性，通过不断柯里化形成的 middleware 可以累积参数，配合组合（ compose，函数式编程的概念，Step. 2 中会介绍）的方式，很容易形成 pipeline 来处理数据流</li>
<li>共享store，在 applyMiddleware 执行过程中，store 还是旧的，但是因为闭包的存在，applyMiddleware 完成后，所有的 middlewares 内部拿到的 store 是最新且相同的</li>
</ol>
<h2 id="给-middleware-分发-store"><a class="markdownIt-Anchor" href="#给-middleware-分发-store"></a> 给 middleware 分发 store</h2>
<p>创建一个普通的 store 通过如下方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//applyMiddleware 函数陆续获得了三个参数</span><br><span class="line">//第一个是 middlewares 数组，[mid1, mid2, mid3, ...]</span><br><span class="line">//第二个 next 是 Redux 原生的 createStore</span><br><span class="line">//最后一个是 reducer</span><br><span class="line">let newStore = applyMiddleware(mid1, mid2, mid3, ...)(createStore)(reducer, null);</span><br></pre></td></tr></table></figure>
<h2 id="组合串联-middlewares"><a class="markdownIt-Anchor" href="#组合串联-middlewares"></a> 组合串联 middlewares</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch = compose(...chain)(store.dispatch);</span><br></pre></td></tr></table></figure>
<p>compose 是函数式编程中的组合，compose 将 chain 中的所有匿名函数，[f1, f2, … , fx, …, fn]，组装成一个新的函数，即新的 dispatch，当新 dispatch 执行时，[f1, f2, … , fx, …, fn]，从右到左依次执行（ 所以顺序很重要）</p>
<h2 id="在-middleware-中调用-dispatch"><a class="markdownIt-Anchor" href="#在-middleware-中调用-dispatch"></a> 在 middleware 中调用 dispatch</h2>
<p>在middleware 中调用 store.dispatch() 和在其他任何地方调用效果是一样的，而在 middleware 中调用 next()，效果是进入下一个 middleware</p>

          
        
      
    </div>
    
    
    

    <div>
          
    </div>

    

    <div>
      
    </div>


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          
       
         <div id="gitment-container"></div>
       



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/pub-images/avatar.png"
                alt="行锋" />
            
              <p class="site-author-name" itemprop="name">行锋</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">127</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">70</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/chetaofeng" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:chetaofeng@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-heartbeat"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

      <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=505221860&auto=0&height=66"></iframe>
    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="theme-info">
  <span>自古写字楼如青楼,不许楼里见白头</span>
</div>

<div class="copyright">&copy; 2015 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">行锋</span>

  
</div>

<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
 <span id="busuanzi_value_site_uv"></span>
</span>
</div>

<!--

  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>

-->




<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共128.1k字</span>
</div>



        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  







<!-- LOCAL: You can save these files to your site and update links -->
    
        
        <link rel="stylesheet" href="https://aimingoo.github.io/gitmint/style/default.css">
        <script src="https://aimingoo.github.io/gitmint/dist/gitmint.browser.js"></script>
    
<!-- END LOCAL -->

    

    







  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'manual') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  


  <script type="text/javascript" src="/js/src/love.js"></script>
</body>
</html>
